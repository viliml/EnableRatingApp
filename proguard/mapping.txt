com.google.appinventor.components.runtime.AndroidNonvisibleComponent -> com.a.a.a.a.a:
    com.google.appinventor.components.runtime.Form form -> a
    com.google.appinventor.components.runtime.HandlesEventDispatching getDispatchDelegate() -> a
com.google.appinventor.components.runtime.Button -> com.a.a.a.a.b:
    void click() -> b
    boolean longClick() -> c
com.google.appinventor.components.runtime.ButtonBase -> com.a.a.a.a.c:
    android.widget.Button view -> a
    float[] ROUNDED_CORNERS_ARRAY -> c
    int backgroundColor -> d
    int fontTypeface -> e
    boolean showFeedback -> f
    int shape -> g
    java.lang.String imagePath -> h
    android.graphics.drawable.Drawable defaultButtonDrawable -> i
    android.content.res.ColorStateList defaultColorStateList -> j
    android.graphics.drawable.Drawable backgroundImageDrawable -> k
    boolean onTouch(android.view.View,android.view.MotionEvent) -> onTouch
    android.view.View getView() -> d
    void updateAppearance() -> e
    void Text(java.lang.String) -> a
    void click() -> b
    boolean longClick() -> c
    void onClick(android.view.View) -> onClick
    void onFocusChange(android.view.View,boolean) -> onFocusChange
    boolean onLongClick(android.view.View) -> onLongClick
com.google.appinventor.components.runtime.Component -> com.a.a.a.a.d:
    com.google.appinventor.components.runtime.HandlesEventDispatching getDispatchDelegate() -> a
com.google.appinventor.components.runtime.ComponentContainer -> com.a.a.a.a.e:
    android.app.Activity $context() -> b
    com.google.appinventor.components.runtime.Form $form() -> c
    void $add$57b72e4(com.google.appinventor.components.runtime.VisibleComponent) -> a
    void setChildWidth$560ca361(com.google.appinventor.components.runtime.VisibleComponent,int) -> a
    void setChildHeight$560ca361(com.google.appinventor.components.runtime.VisibleComponent,int) -> b
com.google.appinventor.components.runtime.EventDispatcher -> com.a.a.a.a.f:
    java.util.Map mapDispatchDelegateToEventRegistry -> a
    com.google.appinventor.components.runtime.EventDispatcher$1 getEventRegistry$2685113e(com.google.appinventor.components.runtime.HandlesEventDispatching) -> b
    void registerEventForDelegation(com.google.appinventor.components.runtime.HandlesEventDispatching,java.lang.String,java.lang.String) -> a
    void removeDispatchDelegate(com.google.appinventor.components.runtime.HandlesEventDispatching) -> a
    boolean dispatchEvent(com.google.appinventor.components.runtime.Component,java.lang.String,java.lang.Object[]) -> a
com.google.appinventor.components.runtime.EventDispatcher$1 -> com.a.a.a.a.g:
    java.util.HashMap eventClosuresMap -> a
    java.util.HashMap access$000$589fc2d2(com.google.appinventor.components.runtime.EventDispatcher$1) -> a
com.google.appinventor.components.runtime.EventDispatcher$EventClosure -> com.a.a.a.a.h:
    java.lang.String componentId -> a
    java.lang.String eventName -> b
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String access$200(com.google.appinventor.components.runtime.EventDispatcher$EventClosure) -> a
    java.lang.String access$300(com.google.appinventor.components.runtime.EventDispatcher$EventClosure) -> b
com.google.appinventor.components.runtime.Form -> com.a.a.a.a.i:
    com.google.appinventor.components.runtime.Form activeForm -> a
    float deviceDensity -> b
    float compatScalingFactor -> c
    boolean applicationIsBeingClosed -> d
    android.os.Handler androidUIHandler -> e
    java.lang.String formName -> f
    boolean screenInitialized -> g
    int backgroundColor -> h
    java.lang.String aboutScreen -> i
    boolean showStatusBar -> j
    boolean showTitle -> k
    java.lang.String backgroundImagePath -> l
    android.graphics.drawable.Drawable backgroundDrawable -> m
    com.google.appinventor.components.runtime.LinearLayout viewLayout -> n
    com.google.appinventor.components.runtime.util.AlignmentUtil alignmentSetter -> o
    android.widget.FrameLayout frameLayout -> p
    boolean scrollable -> q
    com.google.appinventor.components.runtime.ScaledFrameLayout scaleLayout -> r
    boolean sCompatibilityMode -> s
    java.util.HashMap activityResultMap -> t
    java.util.Set onStopListeners -> u
    java.util.Set onNewIntentListeners -> v
    java.util.Set onResumeListeners -> w
    java.util.Set onPauseListeners -> x
    java.util.Set onDestroyListeners -> y
    java.util.Set onInitializeListeners -> z
    long minimumToastWait -> A
    com.google.appinventor.components.runtime.util.FullScreenVideoUtil fullScreenVideoUtil -> B
    java.util.ArrayList dimChanges -> C
    java.lang.String yandexTranslateTagline -> D
    void onCreate(android.os.Bundle) -> onCreate
    void defaultPropertyValues() -> k
    void onConfigurationChanged(android.content.res.Configuration) -> onConfigurationChanged
    boolean onKeyDown(int,android.view.KeyEvent) -> onKeyDown
    void onActivityResult(int,int,android.content.Intent) -> onActivityResult
    java.lang.Object decodeJSONStringForForm(java.lang.String,java.lang.String) -> a
    void ReplayFormOrientation() -> d
    void registerPercentLength$3b05eb8e(com.google.appinventor.components.runtime.VisibleComponent,int,com.google.appinventor.components.runtime.Form$PercentStorageRecord$Dim) -> a
    void onResume() -> onResume
    void onNewIntent(android.content.Intent) -> onNewIntent
    void onPause() -> onPause
    void onStop() -> onStop
    void onDestroy() -> onDestroy
    android.app.Dialog onCreateDialog(int) -> onCreateDialog
    void onPrepareDialog(int,android.app.Dialog) -> onPrepareDialog
    void $define() -> e
    boolean canDispatchEvent(com.google.appinventor.components.runtime.Component,java.lang.String) -> a
    boolean dispatchEvent(com.google.appinventor.components.runtime.Component,java.lang.String,java.lang.String,java.lang.Object[]) -> a
    void ScreenOrientationChanged() -> f
    void ErrorOccurred(com.google.appinventor.components.runtime.Component,java.lang.String,int,java.lang.String) -> a
    void dispatchErrorOccurredEvent(com.google.appinventor.components.runtime.Component,java.lang.String,int,java.lang.Object[]) -> a
    void Scrollable(boolean) -> a
    void BackgroundImage(java.lang.String) -> b
    java.lang.String ScreenOrientation() -> g
    void Sizing(java.lang.String) -> a
    int Height() -> l
    com.google.appinventor.components.runtime.HandlesEventDispatching getDispatchDelegate() -> a
    android.app.Activity $context() -> b
    com.google.appinventor.components.runtime.Form $form() -> c
    void $add$57b72e4(com.google.appinventor.components.runtime.VisibleComponent) -> a
    float deviceDensity() -> h
    void setChildWidth$560ca361(com.google.appinventor.components.runtime.VisibleComponent,int) -> a
    void setChildHeight$560ca361(com.google.appinventor.components.runtime.VisibleComponent,int) -> b
    void closeApplication() -> m
    boolean onCreateOptionsMenu(android.view.Menu) -> onCreateOptionsMenu
    void clear() -> i
    void setBackground(android.view.View) -> a
    android.widget.FrameLayout access$000(com.google.appinventor.components.runtime.Form) -> a
    android.os.Handler access$100(com.google.appinventor.components.runtime.Form) -> b
    boolean access$200() -> j
    boolean access$302(com.google.appinventor.components.runtime.Form,boolean) -> a
    java.util.Set access$400(com.google.appinventor.components.runtime.Form) -> c
    void access$500(com.google.appinventor.components.runtime.Form) -> d
    void access$600(com.google.appinventor.components.runtime.Form) -> e
    void access$700(com.google.appinventor.components.runtime.Form) -> f
com.google.appinventor.components.runtime.Form$1 -> com.a.a.a.a.j:
    int val$newOrientation -> b
    com.google.appinventor.components.runtime.Form this$0 -> a
    void run() -> run
com.google.appinventor.components.runtime.Form$1$1 -> com.a.a.a.a.k:
    com.google.appinventor.components.runtime.Form$1 this$1 -> a
    void run() -> run
com.google.appinventor.components.runtime.Form$10 -> com.a.a.a.a.l:
    void run() -> run
com.google.appinventor.components.runtime.Form$2 -> com.a.a.a.a.m:
    com.google.appinventor.components.runtime.Form this$0 -> a
    void run() -> run
com.google.appinventor.components.runtime.Form$3 -> com.a.a.a.a.n:
    int val$errorNumber -> a
    java.lang.Object[] val$messageArgs -> b
    com.google.appinventor.components.runtime.Component val$component -> c
    java.lang.String val$functionName -> d
    com.google.appinventor.components.runtime.Form this$0 -> e
    void run() -> run
com.google.appinventor.components.runtime.Form$5 -> com.a.a.a.a.o:
    com.google.appinventor.components.runtime.VisibleComponent val$component$75ed272f -> a
    int val$fWidth -> b
    com.google.appinventor.components.runtime.Form this$0 -> c
    void run() -> run
com.google.appinventor.components.runtime.Form$6 -> com.a.a.a.a.p:
    com.google.appinventor.components.runtime.VisibleComponent val$component$75ed272f -> a
    int val$fHeight -> b
    com.google.appinventor.components.runtime.Form this$0 -> c
    void run() -> run
com.google.appinventor.components.runtime.Form$7 -> com.a.a.a.a.q:
    com.google.appinventor.components.runtime.Form this$0 -> a
    boolean onMenuItemClick(android.view.MenuItem) -> onMenuItemClick
com.google.appinventor.components.runtime.Form$8 -> com.a.a.a.a.r:
    com.google.appinventor.components.runtime.Form this$0 -> a
    boolean onMenuItemClick(android.view.MenuItem) -> onMenuItemClick
com.google.appinventor.components.runtime.Form$9 -> com.a.a.a.a.s:
    com.google.appinventor.components.runtime.Form this$0 -> a
    void run() -> run
com.google.appinventor.components.runtime.Form$PercentStorageRecord -> com.a.a.a.a.t:
    com.google.appinventor.components.runtime.VisibleComponent component$75ed272f -> a
    int length -> b
    com.google.appinventor.components.runtime.Form$PercentStorageRecord$Dim dim -> c
    void runAsynchronously(java.lang.Runnable) -> a
    java.lang.String writeStreamToFile(java.io.InputStream,java.lang.String) -> a
    void copy(java.io.InputStream,java.io.OutputStream) -> a
    java.util.List getListFromJsonArray(org.json.JSONArray) -> a
    java.util.List getListFromJsonObject(org.json.JSONObject) -> a
    java.lang.Object convertJsonItem(java.lang.Object) -> a
    java.lang.String getJsonRepresentation(java.lang.Object) -> b
    java.lang.Object getObjectFromJson(java.lang.String) -> a
    void getRawScreenDim(android.content.Context,android.graphics.Point) -> a
    void setAlignment(android.widget.TextView,int,boolean) -> a
    void setEnabled(android.widget.TextView,boolean) -> a
    void setFontSize(android.widget.TextView,float) -> a
    void setFontTypeface(android.widget.TextView,int,boolean,boolean) -> a
    void setText(android.widget.TextView,java.lang.String) -> a
    int calculatePixels(android.view.View,int) -> c
    void setChildWidthForVerticalLayout(android.view.View,int) -> a
    void setChildHeightForVerticalLayout(android.view.View,int) -> b
    void setBackgroundImage(android.view.View,android.graphics.drawable.Drawable) -> a
    void setBackgroundDrawable(android.view.View,android.graphics.drawable.Drawable) -> b
    int checkKnownClass(gnu.bytecode.Type,gnu.expr.Compilation) -> a
    void printQuoted(java.lang.CharSequence,java.io.PrintWriter,int) -> a
    void stringValue(java.lang.Object,java.lang.StringBuffer) -> a
    void textValue(java.lang.Object,gnu.lists.Consumer) -> a
    java.lang.String replaceWhitespace(java.lang.String,boolean) -> a
com.google.appinventor.components.runtime.Form$PercentStorageRecord$Dim -> com.a.a.a.a.u:
    com.google.appinventor.components.runtime.Form$PercentStorageRecord$Dim HEIGHT -> a
    com.google.appinventor.components.runtime.Form$PercentStorageRecord$Dim WIDTH -> b
com.google.appinventor.components.runtime.HandlesEventDispatching -> com.a.a.a.a.v:
    boolean canDispatchEvent(com.google.appinventor.components.runtime.Component,java.lang.String) -> a
    boolean dispatchEvent(com.google.appinventor.components.runtime.Component,java.lang.String,java.lang.String,java.lang.Object[]) -> a
com.google.appinventor.components.runtime.LinearLayout -> com.a.a.a.a.w:
    android.widget.LinearLayout layoutManager -> a
    android.view.ViewGroup getLayoutManager() -> a
    void add$57b72e4(com.google.appinventor.components.runtime.VisibleComponent) -> a
    void setHorizontalGravity(int) -> a
    void setVerticalGravity(int) -> b
com.google.appinventor.components.runtime.LinearLayout$1 -> com.a.a.a.a.x:
    java.lang.Integer val$preferredEmptyWidth -> a
    java.lang.Integer val$preferredEmptyHeight -> b
    void onMeasure(int,int) -> onMeasure
    int getSize(int,int) -> a
com.google.appinventor.components.runtime.Notifier -> com.a.a.a.a.y:
    android.app.Activity activity -> b
    android.os.Handler handler -> c
    int notifierLength -> d
    int backgroundColor -> e
    int textColor -> f
    void ShowMessageDialog(java.lang.String,java.lang.String,java.lang.String) -> a
    void oneButtonAlert(android.app.Activity,java.lang.String,java.lang.String,java.lang.String) -> a
    android.text.SpannableString stringToHTML(java.lang.String) -> b
    void twoButtonDialog(android.app.Activity,java.lang.String,java.lang.String,java.lang.String,java.lang.String,boolean,java.lang.Runnable,java.lang.Runnable,java.lang.Runnable) -> a
    void ShowAlert(java.lang.String) -> a
    void access$000(com.google.appinventor.components.runtime.Notifier,java.lang.String) -> a
com.google.appinventor.components.runtime.Notifier$1 -> com.a.a.a.a.z:
    void onClick(android.content.DialogInterface,int) -> onClick
com.google.appinventor.components.runtime.Notifier$10 -> com.a.a.a.a.A:
    java.lang.String val$notice -> a
    com.google.appinventor.components.runtime.Notifier this$0 -> b
    void run() -> run
com.google.appinventor.components.runtime.Notifier$5 -> com.a.a.a.a.B:
    java.lang.Runnable val$positiveAction -> a
    void onClick(android.content.DialogInterface,int) -> onClick
com.google.appinventor.components.runtime.Notifier$6 -> com.a.a.a.a.C:
    java.lang.Runnable val$negativeAction -> a
    void onClick(android.content.DialogInterface,int) -> onClick
com.google.appinventor.components.runtime.OnDestroyListener -> com.a.a.a.a.D:
    void onDestroy() -> a_
com.google.appinventor.components.runtime.PhoneStatus -> com.a.a.a.a.E:
    com.google.appinventor.components.runtime.PhoneStatus mainInstance -> b
    void doSettings() -> b
com.google.appinventor.components.runtime.ReplForm -> com.a.a.a.a.F:
    com.google.appinventor.components.runtime.util.AppInvHTTPD httpdServer -> b
    boolean assetsLoaded -> c
    java.lang.Object replResult -> d
    java.lang.String replResultFormName -> e
    void onCreate(android.os.Bundle) -> onCreate
    void onResume() -> onResume
    void onStop() -> onStop
    void onDestroy() -> onDestroy
    boolean onCreateOptionsMenu(android.view.Menu) -> onCreateOptionsMenu
    void onNewIntent(android.content.Intent) -> onNewIntent
    void HandleReturnValues() -> k
    void processExtras(android.content.Intent,boolean) -> a
    boolean isAssetsLoaded() -> l
com.google.appinventor.components.runtime.ReplForm$2 -> com.a.a.a.a.G:
    boolean onMenuItemClick(android.view.MenuItem) -> onMenuItemClick
com.google.appinventor.components.runtime.ScaledFrameLayout -> com.a.a.a.a.H:
    int mLeftWidth -> a
    int mRightWidth -> b
    android.graphics.Rect mTmpContainerRect -> c
    android.graphics.Rect mTmpChildRect -> d
    float mScale -> e
    void dispatchDraw(android.graphics.Canvas) -> dispatchDraw
    android.view.ViewParent invalidateChildInParent(int[],android.graphics.Rect) -> invalidateChildInParent
    boolean dispatchTouchEvent(android.view.MotionEvent) -> dispatchTouchEvent
    void setScale(float) -> a
    void updatePadding(int,int) -> a
    void onSizeChanged(int,int,int,int) -> onSizeChanged
    boolean shouldDelayChildPressedState() -> shouldDelayChildPressedState
    void onMeasure(int,int) -> onMeasure
    void onLayout(boolean,int,int,int,int) -> onLayout
com.google.appinventor.components.runtime.TextBox -> com.a.a.a.a.I:
com.google.appinventor.components.runtime.TextBoxBase -> com.a.a.a.a.J:
    android.widget.EditText view -> a
    int fontTypeface -> c
    android.view.View getView() -> d
    void Hint(java.lang.String) -> a
    java.lang.String Text() -> b
    void Text(java.lang.String) -> b
    void onFocusChange(android.view.View,boolean) -> onFocusChange
com.google.appinventor.components.runtime.TinyDB -> com.a.a.a.a.K:
    android.content.SharedPreferences sharedPreferences -> b
    android.content.Context context -> c
    void StoreValue(java.lang.String,java.lang.Object) -> a
    java.lang.Object GetValue(java.lang.String,java.lang.Object) -> b
    void ClearAll() -> b
com.google.appinventor.components.runtime.VideoPlayer -> com.a.a.a.a.L:
    com.google.appinventor.components.runtime.VideoPlayer$ResizableVideoView videoView -> a
    java.lang.String sourcePath -> c
    boolean inFullScreen -> d
    boolean mediaReady -> e
    boolean delayedStart -> f
    android.media.MediaPlayer mPlayer -> g
    android.view.View getView() -> d
    void Start() -> c
    void onCompletion(android.media.MediaPlayer) -> onCompletion
    void Completed() -> b
    boolean onError(android.media.MediaPlayer,int,int) -> onError
    void onPrepared(android.media.MediaPlayer) -> onPrepared
    void onDestroy() -> a_
    void Width(int) -> a
    void Height(int) -> b
    void fullScreenKilled(android.os.Bundle) -> a
com.google.appinventor.components.runtime.VideoPlayer$ResizableVideoView -> com.a.a.a.a.M:
    android.media.MediaPlayer mVideoPlayer -> c
    java.lang.Boolean mFoundMediaPlayer -> d
    int forcedWidth -> a
    int forcedHeight -> b
    void onMeasure(int,int) -> onMeasure
    void changeVideoSize(int,int) -> a
    void invalidateMediaPlayer(boolean) -> a
    void setMediaPlayer(android.media.MediaPlayer,boolean) -> a
com.google.appinventor.components.runtime.VisibleComponent -> com.a.a.a.a.N:
    com.google.appinventor.components.runtime.ComponentContainer container -> b
    android.view.View getView() -> d
    void Visible(java.lang.Boolean) -> a
    void Width(int) -> a
    void Height(int) -> b
    com.google.appinventor.components.runtime.HandlesEventDispatching getDispatchDelegate() -> a
com.google.appinventor.components.runtime.Web -> com.a.a.a.a.O:
    java.util.Map mimeTypeToExtension -> b
    android.app.Activity activity -> c
    java.net.CookieHandler cookieHandler -> d
    java.lang.String urlString -> e
    com.google.appinventor.components.runtime.util.YailList requestHeaders -> f
    java.lang.String responseFileName -> g
    void Url(java.lang.String) -> a
    void RequestHeaders(com.google.appinventor.components.runtime.util.YailList) -> a
    void PostText(java.lang.String) -> b
    void GotText(java.lang.String,int,java.lang.String,java.lang.String) -> a
    java.lang.String BuildRequestData(com.google.appinventor.components.runtime.util.YailList) -> b
    java.lang.String UriEncode(java.lang.String) -> c
    void writeRequestFile(java.net.HttpURLConnection,java.lang.String) -> a
    java.lang.String getResponseContent(java.net.HttpURLConnection) -> a
    java.io.InputStream getConnectionStream(java.net.HttpURLConnection) -> b
    java.util.Map processRequestHeaders(com.google.appinventor.components.runtime.util.YailList) -> d
    com.google.appinventor.components.runtime.Web$CapturedProperties capturePropertyValues(java.lang.String) -> d
    java.lang.String access$000(com.google.appinventor.components.runtime.Web) -> a
    boolean access$100(com.google.appinventor.components.runtime.Web) -> b
    boolean access$200(com.google.appinventor.components.runtime.Web) -> c
    java.lang.String access$300(com.google.appinventor.components.runtime.Web) -> d
    com.google.appinventor.components.runtime.util.YailList access$400(com.google.appinventor.components.runtime.Web) -> e
    java.util.Map access$500(com.google.appinventor.components.runtime.util.YailList) -> c
    java.net.CookieHandler access$600(com.google.appinventor.components.runtime.Web) -> f
    void access$700(com.google.appinventor.components.runtime.Web,com.google.appinventor.components.runtime.Web$CapturedProperties,byte[],java.lang.String,java.lang.String) -> a
com.google.appinventor.components.runtime.Web$5 -> com.a.a.a.a.P:
    java.lang.String val$encoding -> a
    java.lang.String val$text -> b
    java.lang.String val$functionName -> c
    com.google.appinventor.components.runtime.Web$CapturedProperties val$webProps -> d
    java.lang.String val$httpVerb -> e
    com.google.appinventor.components.runtime.Web this$0 -> f
    void run() -> run
com.google.appinventor.components.runtime.Web$7 -> com.a.a.a.a.Q:
    com.google.appinventor.components.runtime.Web$CapturedProperties val$webProps -> a
    int val$responseCode -> b
    java.lang.String val$responseType -> c
    java.lang.String val$responseContent -> d
    com.google.appinventor.components.runtime.Web this$0 -> e
    void run() -> run
com.google.appinventor.components.runtime.Web$BuildRequestDataException -> com.a.a.a.a.R:
    int errorNumber -> a
    int index -> b
com.google.appinventor.components.runtime.Web$CapturedProperties -> com.a.a.a.a.S:
    java.lang.String urlString -> a
    java.net.URL url -> b
    boolean allowCookies -> f
    java.lang.String responseFileName -> c
    java.util.Map requestHeaders -> d
    java.util.Map cookies -> e
com.google.appinventor.components.runtime.Web$InvalidRequestHeadersException -> com.a.a.a.a.T:
    int errorNumber -> a
    int index -> b
com.google.appinventor.components.runtime.errors.RuntimeError -> com.a.a.a.a.a.a:
com.google.appinventor.components.runtime.errors.YailRuntimeError -> com.a.a.a.a.a.b:
com.google.appinventor.components.runtime.util.AlignmentUtil -> com.a.a.a.a.b.a:
    com.google.appinventor.components.runtime.LinearLayout viewLayout -> a
    void setHorizontalAlignment(int) -> a
    void setVerticalAlignment(int) -> b
    com.google.appinventor.components.runtime.util.YailList fromCsvTable(java.lang.String) -> a
com.google.appinventor.components.runtime.util.AppInvHTTPD -> com.a.a.a.a.b.b:
    java.io.File rootDir -> b
    gnu.expr.Language scheme -> c
    com.google.appinventor.components.runtime.ReplForm form -> d
    boolean secure -> e
    byte[] hmacKey -> f
    int seq -> g
    android.os.Handler androidUIHandler -> h
    com.google.appinventor.components.runtime.util.NanoHTTPD$Response serve(java.lang.String,java.lang.String,java.util.Properties,java.util.Properties,java.util.Properties,java.net.Socket) -> a
    void copyFile(java.io.File,java.io.File) -> a
    void setHmacKey(java.lang.String) -> a
    void resetSeq() -> a
    com.google.appinventor.components.runtime.ReplForm access$000(com.google.appinventor.components.runtime.util.AppInvHTTPD) -> a
com.google.appinventor.components.runtime.util.AppInvHTTPD$1 -> com.a.a.a.a.b.c:
    com.google.appinventor.components.runtime.util.AppInvHTTPD this$0 -> a
    void run() -> run
com.google.appinventor.components.runtime.util.CsvUtil$CsvParser -> com.a.a.a.a.b.d:
    java.util.regex.Pattern ESCAPED_QUOTE_PATTERN -> a
    char[] buf -> b
    java.io.Reader in -> c
    int pos -> d
    int limit -> e
    boolean opened -> f
    int cellLength -> g
    int delimitedCellLength -> h
    java.lang.Exception lastException -> i
    long previouslyRead -> j
    boolean hasNext() -> hasNext
    java.util.ArrayList next() -> a
    int indexAfterCompactionAndFilling(int) -> a
    void fill() -> c
    boolean lookingAtCell() -> d
    int checkedIndex(int) -> b
    boolean findUnquotedCellEnd(int) -> c
    void remove() -> remove
    void throwAnyProblem() -> b
    java.lang.Object next() -> next
com.google.appinventor.components.runtime.util.CustomMediaController -> com.a.a.a.a.b.e:
    android.view.View mAnchorView -> a
    int mShowTime -> b
    void show(int) -> show
    void show() -> show
    boolean addTo(android.view.ViewGroup,android.view.ViewGroup$LayoutParams) -> a
    void setAnchorView(android.view.View) -> setAnchorView
    void hide() -> hide
    boolean onTouch(android.view.View,android.view.MotionEvent) -> onTouch
com.google.appinventor.components.runtime.util.ErrorMessages -> com.a.a.a.a.b.f:
    java.util.Map errorMessages -> a
    java.lang.String formatMessage(int,java.lang.Object[]) -> a
com.google.appinventor.components.runtime.util.FileUtil$FileException -> com.a.a.a.a.b.g:
    int msgNumber -> a
    int getErrorMessageNumber() -> a
com.google.appinventor.components.runtime.util.FullScreenVideoUtil -> com.a.a.a.a.b.h:
    android.app.Dialog mFullScreenVideoDialog -> a
    android.widget.FrameLayout mFullScreenVideoHolder -> b
    android.widget.VideoView mFullScreenVideoView -> c
    com.google.appinventor.components.runtime.util.CustomMediaController mFullScreenVideoController -> d
    android.widget.FrameLayout$LayoutParams mMediaControllerParams -> e
    com.google.appinventor.components.runtime.Form mForm -> f
    com.google.appinventor.components.runtime.VideoPlayer mFullScreenPlayer -> g
    android.os.Bundle mFullScreenVideoBundle -> h
    android.os.Handler mHandler -> i
    android.app.Dialog createFullScreenVideoDialog() -> a
    void prepareFullScreenVideoDialog$46a48fae() -> b
    void onCompletion(android.media.MediaPlayer) -> onCompletion
    void onPrepared(android.media.MediaPlayer) -> onPrepared
    void startDialog() -> c
    android.widget.VideoView access$000(com.google.appinventor.components.runtime.util.FullScreenVideoUtil) -> a
    android.os.Bundle access$100(com.google.appinventor.components.runtime.util.FullScreenVideoUtil) -> b
    com.google.appinventor.components.runtime.VideoPlayer access$200(com.google.appinventor.components.runtime.util.FullScreenVideoUtil) -> c
com.google.appinventor.components.runtime.util.FullScreenVideoUtil$1 -> com.a.a.a.a.b.i:
    com.google.appinventor.components.runtime.util.FullScreenVideoUtil this$0 -> a
    void onBackPressed() -> onBackPressed
    void onStart() -> onStart
com.google.appinventor.components.runtime.util.FullScreenVideoUtil$2 -> com.a.a.a.a.b.j:
    com.google.appinventor.components.runtime.util.FullScreenVideoUtil this$0 -> a
    void onStop() -> onStop
    void onStart() -> onStart
com.google.appinventor.components.runtime.util.FullScreenVideoUtil$3 -> com.a.a.a.a.b.k:
    boolean onTouch(android.view.View,android.view.MotionEvent) -> onTouch
com.google.appinventor.components.runtime.util.FullScreenVideoUtil$4 -> com.a.a.a.a.b.l:
    com.google.appinventor.components.runtime.util.FullScreenVideoUtil this$0 -> a
    void run() -> run
com.google.appinventor.components.runtime.util.MediaUtil -> com.a.a.a.a.b.m:
    java.util.Map tempFileMap -> a
    java.util.concurrent.ConcurrentHashMap pathCache -> b
    java.lang.String replAssetPath(java.lang.String) -> a
    java.lang.String fileUrlToFilePath(java.lang.String) -> b
    com.google.appinventor.components.runtime.util.MediaUtil$MediaSource determineMediaSource(com.google.appinventor.components.runtime.Form,java.lang.String) -> c
    java.io.InputStream getAssetsIgnoreCaseInputStream(com.google.appinventor.components.runtime.Form,java.lang.String) -> d
    java.io.InputStream openMedia(com.google.appinventor.components.runtime.Form,java.lang.String,com.google.appinventor.components.runtime.util.MediaUtil$MediaSource) -> a
    java.io.InputStream openMedia(com.google.appinventor.components.runtime.Form,java.lang.String) -> a
    java.io.File copyMediaToTempFile(com.google.appinventor.components.runtime.Form,java.lang.String,com.google.appinventor.components.runtime.util.MediaUtil$MediaSource) -> b
    android.graphics.drawable.BitmapDrawable getBitmapDrawable(com.google.appinventor.components.runtime.Form,java.lang.String) -> b
    android.graphics.Bitmap decodeStream(java.io.InputStream,android.graphics.Rect,android.graphics.BitmapFactory$Options) -> a
    android.graphics.BitmapFactory$Options getBitmapOptions(com.google.appinventor.components.runtime.Form,java.io.InputStream) -> a
    void loadVideoView(android.widget.VideoView,com.google.appinventor.components.runtime.Form,java.lang.String) -> a
com.google.appinventor.components.runtime.util.MediaUtil$1 -> com.a.a.a.a.b.n:
    int[] $SwitchMap$com$google$appinventor$components$runtime$util$MediaUtil$MediaSource -> a
com.google.appinventor.components.runtime.util.MediaUtil$FlushedInputStream -> com.a.a.a.a.b.o:
    long skip(long) -> skip
com.google.appinventor.components.runtime.util.MediaUtil$MediaSource -> com.a.a.a.a.b.p:
    com.google.appinventor.components.runtime.util.MediaUtil$MediaSource ASSET -> a
    com.google.appinventor.components.runtime.util.MediaUtil$MediaSource REPL_ASSET -> b
    com.google.appinventor.components.runtime.util.MediaUtil$MediaSource SDCARD -> c
    com.google.appinventor.components.runtime.util.MediaUtil$MediaSource FILE_URL -> d
    com.google.appinventor.components.runtime.util.MediaUtil$MediaSource URL -> e
    com.google.appinventor.components.runtime.util.MediaUtil$MediaSource CONTENT_URI -> f
    com.google.appinventor.components.runtime.util.MediaUtil$MediaSource CONTACT_URI -> g
    com.google.appinventor.components.runtime.util.MediaUtil$MediaSource[] $VALUES -> h
    com.google.appinventor.components.runtime.util.MediaUtil$MediaSource[] values() -> a
com.google.appinventor.components.runtime.util.NanoHTTPD -> com.a.a.a.a.b.q:
    java.util.concurrent.ThreadPoolExecutor myExecutor -> b
    int myTcpPort -> c
    java.net.ServerSocket myServerSocket -> d
    java.lang.Thread myThread -> e
    java.io.File myRootDir -> f
    java.util.Hashtable theMimeTypes -> g
    int theBufferSize -> h
    java.io.PrintStream myOut -> i
    java.io.PrintStream myErr -> a
    java.text.SimpleDateFormat gmtFrmt -> j
    com.google.appinventor.components.runtime.util.NanoHTTPD$Response serve(java.lang.String,java.lang.String,java.util.Properties,java.util.Properties,java.util.Properties,java.net.Socket) -> a
    void stop() -> b
    java.lang.String encodeUri(java.lang.String) -> a
    com.google.appinventor.components.runtime.util.NanoHTTPD$Response serveFile(java.lang.String,java.util.Properties,java.io.File,boolean) -> a
    java.net.ServerSocket access$000(com.google.appinventor.components.runtime.util.NanoHTTPD) -> a
    java.util.concurrent.ThreadPoolExecutor access$200(com.google.appinventor.components.runtime.util.NanoHTTPD) -> b
    java.text.SimpleDateFormat access$300() -> c
    int access$400() -> d
com.google.appinventor.components.runtime.util.NanoHTTPD$1 -> com.a.a.a.a.b.r:
    com.google.appinventor.components.runtime.util.NanoHTTPD this$0 -> a
    void run() -> run
com.google.appinventor.components.runtime.util.NanoHTTPD$2 -> com.a.a.a.a.b.s:
    long val$dataLen -> a
    int available() -> available
com.google.appinventor.components.runtime.util.NanoHTTPD$HTTPSession -> com.a.a.a.a.b.t:
    java.net.Socket mySocket -> a
    com.google.appinventor.components.runtime.util.NanoHTTPD this$0 -> b
    void run() -> run
    void decodeHeader(java.io.BufferedReader,java.util.Properties,java.util.Properties,java.util.Properties) -> a
    void decodeMultipartData(java.lang.String,byte[],java.io.BufferedReader,java.util.Properties,java.util.Properties) -> a
    java.lang.String saveTmpFile(byte[],int,int) -> a
    int stripMultipartHeaders(byte[],int) -> a
    java.lang.String decodePercent(java.lang.String) -> a
    void decodeParms(java.lang.String,java.util.Properties) -> a
    void sendError(java.lang.String,java.lang.String) -> a
    void sendResponse(java.lang.String,java.lang.String,java.util.Properties,java.io.InputStream) -> a
com.google.appinventor.components.runtime.util.NanoHTTPD$Response -> com.a.a.a.a.b.u:
    java.lang.String status -> a
    java.lang.String mimeType -> b
    java.io.InputStream data -> c
    java.util.Properties header -> d
    void addHeader(java.lang.String,java.lang.String) -> a
com.google.appinventor.components.runtime.util.NanoHTTPD$myThreadFactory -> com.a.a.a.a.b.v:
    java.lang.Thread newThread(java.lang.Runnable) -> newThread
com.google.appinventor.components.runtime.util.PackageInstaller$1 -> com.a.a.a.a.b.w:
    java.lang.String val$inurl -> a
    com.google.appinventor.components.runtime.Form val$form -> b
    void run() -> run
com.google.appinventor.components.runtime.util.RetValManager -> com.a.a.a.a.b.x:
    java.lang.Object semaphore -> a
    java.util.ArrayList currentArray -> b
    void appendReturnValue(java.lang.String,java.lang.String,java.lang.String) -> a
    java.lang.String fetch(boolean) -> a
com.google.appinventor.components.runtime.util.YailConstants -> com.a.a.a.a.b.y:
    gnu.mapping.SimpleSymbol YAIL_HEADER -> a
com.google.appinventor.components.runtime.util.YailList -> com.a.a.a.a.b.z:
    com.google.appinventor.components.runtime.util.YailList makeList(java.lang.Object[]) -> a
    com.google.appinventor.components.runtime.util.YailList makeList(java.util.List) -> a
    java.lang.Object[] toArray() -> toArray
    java.lang.String toJSONString() -> a
    int size() -> size
    java.lang.String toString() -> toString
    java.lang.String getString(int) -> a
    java.lang.Object getObject(int) -> b
com.vlendvaj.gamerating.AbstractDatabaseForm -> com.vlendvaj.gamerating.a:
    com.google.appinventor.components.runtime.TinyDB tinyDB -> b
    com.google.appinventor.components.runtime.Notifier notifier -> c
    java.lang.String getUserName() -> k
    java.util.ArrayList getIds() -> l
    java.util.ArrayList getNames() -> m
    java.util.ArrayList getRatings() -> n
    java.util.ArrayList getCounts() -> o
    void setIds(java.util.ArrayList) -> a
    void setNames(java.util.ArrayList) -> b
    void setRatings(java.util.ArrayList) -> c
    void setCounts(java.util.ArrayList) -> d
    void dispatchErrorOccurredEvent(com.google.appinventor.components.runtime.Component,java.lang.String,int,java.lang.Object[]) -> a
    void _dispatchErrorOccurredEvent$6631805d(com.google.appinventor.components.runtime.Component,java.lang.String,int) -> a
    java.lang.String replace(java.lang.String) -> b
    void showMessageDialog(java.lang.String,java.lang.String,java.lang.String) -> a
com.vlendvaj.gamerating.AbstractDatabaseForm$1 -> com.vlendvaj.gamerating.b:
    com.vlendvaj.gamerating.AbstractDatabaseForm this$0 -> a
    java.lang.String val$message -> b
    java.lang.String val$title -> c
    java.lang.String val$buttonText -> d
    void run() -> run
com.vlendvaj.gamerating.AppDetailActivity -> com.vlendvaj.gamerating.AppDetailActivity:
    void onCreate(android.os.Bundle) -> onCreate
    void $define() -> e
    void onSaveInstanceState(android.os.Bundle) -> onSaveInstanceState
    void _dispatchErrorOccurredEvent$6631805d(com.google.appinventor.components.runtime.Component,java.lang.String,int) -> a
com.vlendvaj.gamerating.AppViewActivity -> com.vlendvaj.gamerating.AppViewActivity:
    void $define() -> e
    void _dispatchErrorOccurredEvent$6631805d(com.google.appinventor.components.runtime.Component,java.lang.String,int) -> a
com.vlendvaj.gamerating.Constants -> com.vlendvaj.gamerating.c:
    com.google.appinventor.components.runtime.util.YailList requestHeaders -> a
    void runQuery(com.google.appinventor.components.runtime.Web,java.lang.String) -> a
com.vlendvaj.gamerating.FirstLaunchActivity -> com.vlendvaj.gamerating.FirstLaunchActivity:
    com.google.appinventor.components.runtime.TextBox txbUserName -> b
    com.google.appinventor.components.runtime.Button btnProceed -> c
    void $define() -> e
    boolean dispatchEvent(com.google.appinventor.components.runtime.Component,java.lang.String,java.lang.String,java.lang.Object[]) -> a
com.vlendvaj.gamerating.MainActivity -> com.vlendvaj.gamerating.MainActivity:
    boolean DEBUG -> e
    java.lang.String EXTRA_USERNAME_TAG -> d
    java.lang.String userName -> f
    com.google.appinventor.components.runtime.Button btnAdd -> g
    com.google.appinventor.components.runtime.Button btnApps -> h
    com.google.appinventor.components.runtime.TextBox txbName -> i
    com.google.appinventor.components.runtime.Button btnSubmit -> j
    com.google.appinventor.components.runtime.Button btnDeleteDB -> k
    com.google.appinventor.components.runtime.Web web -> l
    com.vlendvaj.gamerating.MainActivity$State state -> m
    int[] $SWITCH_TABLE$com$vlendvaj$gamerating$MainActivity$State -> n
    void $define() -> e
    void _dispatchErrorOccurredEvent$6631805d(com.google.appinventor.components.runtime.Component,java.lang.String,int) -> a
    boolean dispatchEvent(com.google.appinventor.components.runtime.Component,java.lang.String,java.lang.String,java.lang.Object[]) -> a
    void refresh() -> p
    void updateList(com.google.appinventor.components.runtime.util.YailList) -> a
    int[] $SWITCH_TABLE$com$vlendvaj$gamerating$MainActivity$State() -> q
com.vlendvaj.gamerating.MainActivity$State -> com.vlendvaj.gamerating.d:
    com.vlendvaj.gamerating.MainActivity$State NORMAL -> a
    com.vlendvaj.gamerating.MainActivity$State SHOW_APPS -> b
    com.vlendvaj.gamerating.MainActivity$State[] ENUM$VALUES -> c
    com.vlendvaj.gamerating.MainActivity$State[] values() -> a
com.vlendvaj.gamerating.fragment.AppDetailFragment -> com.vlendvaj.gamerating.fragment.a:
    android.widget.RatingBar ratingBar -> a
    android.widget.TextView ratingText -> b
    android.widget.EditText comment -> c
    android.widget.Button btnSubmit -> d
    com.google.appinventor.components.runtime.Web web -> e
    com.google.appinventor.components.runtime.TinyDB tinyDB -> f
    com.vlendvaj.gamerating.fragment.AppDetailFragment newInstance(int) -> a
    android.view.View onCreateView(android.view.LayoutInflater,android.view.ViewGroup,android.os.Bundle) -> onCreateView
    void onActivityCreated(android.os.Bundle) -> onActivityCreated
    int getShownIndex() -> a
    void onClick(android.view.View) -> onClick
    void updateDatabase(java.lang.Integer,java.lang.Double) -> a
    boolean dispatchEvent(com.google.appinventor.components.runtime.Component,java.lang.String,java.lang.String,java.lang.Object[]) -> a
    void updateComments(com.google.appinventor.components.runtime.util.YailList) -> a
    void dispatchErrorOccurredEvent$6631805d(com.google.appinventor.components.runtime.Component,java.lang.String,int) -> a
    java.lang.Integer getShownId() -> d
    java.lang.Double getShownRating() -> e
    android.app.Activity $context() -> b
    com.google.appinventor.components.runtime.Form $form() -> c
    void $add$57b72e4(com.google.appinventor.components.runtime.VisibleComponent) -> a
    void setChildWidth$560ca361(com.google.appinventor.components.runtime.VisibleComponent,int) -> a
    void setChildHeight$560ca361(com.google.appinventor.components.runtime.VisibleComponent,int) -> b
    boolean canDispatchEvent(com.google.appinventor.components.runtime.Component,java.lang.String) -> a
com.vlendvaj.gamerating.fragment.AppDetailFragment$1 -> com.vlendvaj.gamerating.fragment.b:
    com.vlendvaj.gamerating.fragment.AppDetailFragment this$0 -> b
    com.google.appinventor.components.runtime.HandlesEventDispatching getDispatchDelegate() -> a
com.vlendvaj.gamerating.fragment.AppDetailFragment$2 -> com.vlendvaj.gamerating.fragment.c:
    int compare(java.lang.Object,java.lang.Object) -> compare
com.vlendvaj.gamerating.fragment.AppDetailFragment$3 -> com.vlendvaj.gamerating.fragment.d:
    boolean setViewValue(android.view.View,java.lang.Object,java.lang.String) -> setViewValue
com.vlendvaj.gamerating.fragment.AppListFragment -> com.vlendvaj.gamerating.fragment.AppListFragment:
    boolean dualPane -> a
    int currentPosition -> b
    int currentIndex -> c
    void onActivityCreated(android.os.Bundle) -> onActivityCreated
    android.view.View onCreateView(android.view.LayoutInflater,android.view.ViewGroup,android.os.Bundle) -> onCreateView
    void onResume() -> onResume
    void onSaveInstanceState(android.os.Bundle) -> onSaveInstanceState
    void onListItemClick(android.widget.ListView,android.view.View,int,long) -> onListItemClick
    void showDetails(int,int) -> a
    int access$0(com.vlendvaj.gamerating.fragment.AppListFragment) -> a
    void access$1(com.vlendvaj.gamerating.fragment.AppListFragment,int) -> a
com.vlendvaj.gamerating.fragment.AppListFragment$1 -> com.vlendvaj.gamerating.fragment.e:
    com.vlendvaj.gamerating.fragment.AppListFragment this$0 -> a
    void onTextChanged(java.lang.CharSequence,int,int,int) -> onTextChanged
    void beforeTextChanged(java.lang.CharSequence,int,int,int) -> beforeTextChanged
    void afterTextChanged(android.text.Editable) -> afterTextChanged
com.vlendvaj.gamerating.fragment.AppListFragment$MyAdapter -> com.vlendvaj.gamerating.fragment.f:
    java.util.Map ids -> a
    com.vlendvaj.gamerating.fragment.AppListFragment$MyAdapter$MyFilter filter -> b
    android.view.View getView(int,android.view.View,android.view.ViewGroup) -> getView
    long getItemId(int) -> getItemId
    android.widget.Filter getFilter() -> getFilter
    void access$0(com.vlendvaj.gamerating.fragment.AppListFragment$MyAdapter,java.util.Map) -> a
    java.util.Map access$1(com.vlendvaj.gamerating.fragment.AppListFragment$MyAdapter) -> a
com.vlendvaj.gamerating.fragment.AppListFragment$MyAdapter$MyFilter -> com.vlendvaj.gamerating.fragment.g:
    com.vlendvaj.gamerating.fragment.AppListFragment$MyAdapter this$1 -> a
    android.widget.Filter$FilterResults performFiltering(java.lang.CharSequence) -> performFiltering
    void publishResults(java.lang.CharSequence,android.widget.Filter$FilterResults) -> publishResults
gnu.bytecode.ArrayClassLoader -> a.a.a:
    java.util.Hashtable map -> a
    java.util.Hashtable cmap -> b
    java.net.URL context -> c
    void setResourceContext(java.net.URL) -> a
    void addClass(java.lang.Class) -> a
    void addClass(java.lang.String,byte[]) -> a
    void addClass(gnu.bytecode.ClassType) -> a
    java.io.InputStream getResourceAsStream(java.lang.String) -> getResourceAsStream
    java.net.URL findResource(java.lang.String) -> findResource
    java.lang.Class loadClass(java.lang.String,boolean) -> loadClass
    java.lang.Class loadClass(java.lang.String) -> loadClass
    java.lang.Package getContextPackage(java.lang.String) -> a
gnu.bytecode.ArrayType -> a.a.b:
    gnu.bytecode.Type elements -> a
    java.lang.String getSignature() -> c_
    gnu.bytecode.Type getImplementationType() -> b
    gnu.bytecode.ArrayType make(java.lang.String) -> a
    gnu.bytecode.ArrayType make(gnu.bytecode.Type) -> a
    gnu.bytecode.Type getComponentType() -> c
    java.lang.String getInternalName() -> d
    java.lang.Class getReflectClass() -> b_
    int getMethods(gnu.bytecode.Filter,int,java.util.List) -> a
    int compare(gnu.bytecode.Type) -> b
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.bytecode.AttrContainer -> a.a.c:
    gnu.bytecode.Attribute getAttributes() -> a
    void setAttributes(gnu.bytecode.Attribute) -> a
gnu.bytecode.Attribute -> a.a.d:
    gnu.bytecode.AttrContainer container -> a
    gnu.bytecode.Attribute next -> b
    java.lang.String name -> c
    int name_index -> d
    void addToFrontOf(gnu.bytecode.AttrContainer) -> a
    boolean isSkipped() -> b
    void setSkipped(boolean) -> a
    void assignConstants(gnu.bytecode.ClassType) -> a
    void assignConstants(gnu.bytecode.AttrContainer,gnu.bytecode.ClassType) -> a
    int getLength() -> c
    void write(java.io.DataOutputStream) -> a
    void writeAll(gnu.bytecode.AttrContainer,java.io.DataOutputStream) -> a
gnu.bytecode.ClassType -> a.a.e:
    int classfileFormatVersion -> a
    int thisClassIndex -> ac
    gnu.bytecode.ClassType superClass -> ad
    int superClassIndex -> ae
    gnu.bytecode.ClassType[] interfaces -> af
    int[] interfaceIndexes -> ag
    int access_flags -> ah
    gnu.bytecode.Attribute attributes -> ai
    gnu.bytecode.ClassType[] noClasses -> aj
    gnu.bytecode.ConstantPool constants -> b
    gnu.bytecode.ClassType firstInnerClass -> ak
    gnu.bytecode.ClassType nextInnerClass -> al
    gnu.bytecode.Member enclosingMember -> am
    gnu.bytecode.SourceDebugExtAttr sourceDbgExt -> c
    gnu.bytecode.Field fields -> d
    int fields_count -> e
    gnu.bytecode.Field last_field -> f
    gnu.bytecode.Method methods -> g
    int methods_count -> h
    gnu.bytecode.Method last_method -> i
    gnu.bytecode.Method constructor -> j
    short getClassfileMajorVersion() -> c
    void setClassfileVersion(int) -> a
    int getClassfileVersion() -> f
    gnu.bytecode.ClassType make(java.lang.String) -> a
    gnu.bytecode.Attribute getAttributes() -> a
    void setAttributes(gnu.bytecode.Attribute) -> a
    gnu.bytecode.ConstantPool getConstants() -> g
    int getModifiers() -> h
    boolean getStaticFlag() -> i
    void setModifiers(int) -> b
    void addModifiers(int) -> c
    java.lang.String getSimpleName() -> j
    void addMemberClass(gnu.bytecode.ClassType) -> a
    gnu.bytecode.ClassType getDeclaringClass() -> k
    void setEnclosingMember(gnu.bytecode.Member) -> a
    void addEnclosingMember() -> B
    boolean hasOuterLink() -> l
    gnu.bytecode.ClassType getOuterLinkType() -> m
    gnu.bytecode.Field setOuterLink(gnu.bytecode.ClassType) -> b
    boolean isAccessible(gnu.bytecode.Member,gnu.bytecode.ObjectType) -> a
    boolean isAccessible(gnu.bytecode.ClassType,gnu.bytecode.ObjectType,int) -> a
    void setName(java.lang.String) -> b
    void setStratum(java.lang.String) -> c
    void setSourceFile(java.lang.String) -> d
    void setSuper(gnu.bytecode.ClassType) -> c
    gnu.bytecode.ClassType getSuperclass() -> n
    gnu.bytecode.ClassType[] getInterfaces() -> o
    void setInterfaces(gnu.bytecode.ClassType[]) -> a
    void addInterface(gnu.bytecode.ClassType) -> d
    boolean isInterface() -> p
    void setInterface(boolean) -> a
    gnu.bytecode.Field getFields() -> q
    gnu.bytecode.Field getDeclaredField(java.lang.String) -> e
    gnu.bytecode.Field getField(java.lang.String,int) -> a
    gnu.bytecode.Field getField(java.lang.String) -> f
    gnu.bytecode.Field addField(java.lang.String,gnu.bytecode.Type) -> a
    gnu.bytecode.Field addField(java.lang.String,gnu.bytecode.Type,int) -> a
    void addFields() -> C
    gnu.bytecode.Method addMethod(java.lang.String,gnu.bytecode.Type[],gnu.bytecode.Type,int) -> a
    gnu.bytecode.Method addMethod(java.lang.String,int,gnu.bytecode.Type[],gnu.bytecode.Type) -> a
    gnu.bytecode.Method addMethod(java.lang.reflect.Method) -> a
    gnu.bytecode.Method addMethod(java.lang.reflect.Constructor) -> a
    gnu.bytecode.Method getDeclaredMethods() -> r
    gnu.bytecode.Method[] getMethods(gnu.bytecode.Filter,int) -> a
    int getMethods(gnu.bytecode.Filter,int,java.util.List) -> a
    gnu.bytecode.Method[] getAbstractMethods() -> s
    gnu.bytecode.Method getDeclaredMethod(java.lang.String,gnu.bytecode.Type[]) -> a
    gnu.bytecode.Method getDeclaredMethod(java.lang.String,int) -> b
    gnu.bytecode.Method getMethod(java.lang.String,gnu.bytecode.Type[]) -> b
    void addMethods(java.lang.Class) -> c
    void doFixups() -> D
    void writeToStream(java.io.OutputStream) -> a
    void writeToFile(java.lang.String) -> g
    byte[] writeToArray() -> t
    boolean implementsInterface(gnu.bytecode.ClassType) -> f
    boolean isSubclass(java.lang.String) -> h
    boolean isSubclass(gnu.bytecode.ClassType) -> e
    int compare(gnu.bytecode.Type) -> b
    java.lang.String toString() -> toString
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
    void cleanupAfterCompilation() -> u
    gnu.bytecode.Method checkSingleAbstractMethod() -> v
gnu.bytecode.ClassType$AbstractMethodFilter -> a.a.f:
    gnu.bytecode.ClassType$AbstractMethodFilter instance -> a
    boolean select(java.lang.Object) -> a
gnu.bytecode.CodeAttr -> a.a.g:
    gnu.bytecode.Attribute attributes -> q
    gnu.bytecode.LineNumbersAttr lines -> d
    gnu.bytecode.LocalVarsAttr locals -> e
    gnu.bytecode.StackMapTableAttr stackMap -> r
    gnu.bytecode.SourceDebugExtAttr sourceDbgExt -> f
    int flags -> s
    gnu.bytecode.Type[] stack_types -> g
    gnu.bytecode.Type[] local_types -> h
    gnu.bytecode.Label previousLabel -> i
    boolean[] varsSetInCurrentBlock -> j
    int SP -> k
    int max_stack -> t
    int max_locals -> u
    int PC -> l
    byte[] code -> v
    short[] exception_table -> w
    int exception_table_length -> x
    int[] fixup_offsets -> y
    gnu.bytecode.Label[] fixup_labels -> z
    int fixup_count -> m
    boolean instructionLineMode -> A
    gnu.bytecode.IfState if_stack -> n
    gnu.bytecode.TryState try_stack -> o
    boolean unreachable_here -> B
    gnu.bytecode.ExitableBlock currentExitableBlock -> C
    int exitableBlockLevel -> p
    gnu.bytecode.Attribute getAttributes() -> a
    void setAttributes(gnu.bytecode.Attribute) -> a
    boolean useJsr() -> d
    void fixupChain(gnu.bytecode.Label,gnu.bytecode.Label) -> a
    void fixupAdd(int,gnu.bytecode.Label) -> a
    void fixupAdd(int,int,gnu.bytecode.Label) -> a
    int fixupOffset(int) -> k
    gnu.bytecode.Method getMethod() -> e
    int getPC() -> f
    gnu.bytecode.ConstantPool getConstants() -> g
    boolean reachableHere() -> h
    void setReachable(boolean) -> b
    void setUnreachable() -> i
    int getMaxLocals() -> j
    void setMaxLocals(int) -> a
    void reserve(int) -> b
    void put1(int) -> c
    void put2(int) -> l
    void put4(int) -> d
    void putIndex2(gnu.bytecode.CpoolEntry) -> a
    void putLineNumber(java.lang.String,int) -> a
    void putLineNumber(int) -> e
    void noteParamTypes() -> k
    void noteVarType(int,gnu.bytecode.Type) -> a
    void setTypes(gnu.bytecode.Label) -> a
    void setTypes(gnu.bytecode.Type[],gnu.bytecode.Type[]) -> a
    void pushType(gnu.bytecode.Type) -> a
    gnu.bytecode.Type popType() -> l
    gnu.bytecode.Type topType() -> m
    void emitPop(int) -> f
    gnu.bytecode.Label getLabel() -> n
    void emitSwap() -> o
    void emitDup() -> p
    void emitDupX() -> q
    void emitDup(int,int) -> a
    void emitDup(int) -> g
    void emitDup(gnu.bytecode.Type) -> b
    void enterScope(gnu.bytecode.Scope) -> a
    gnu.bytecode.Scope pushScope() -> r
    gnu.bytecode.Scope getCurrentScope() -> s
    gnu.bytecode.Scope popScope() -> t
    gnu.bytecode.Variable getArg(int) -> h
    gnu.bytecode.Variable addLocal(gnu.bytecode.Type) -> c
    void addParamLocals() -> u
    void emitPushConstant(gnu.bytecode.CpoolEntry) -> b
    void emitPushInt(int) -> i
    void emitPushLong(long) -> a
    void emitPushFloat(float) -> a
    void emitPushDouble(double) -> a
    java.lang.String calculateSplit(java.lang.String) -> a
    void emitPushString(java.lang.String) -> b
    void emitPushClass(gnu.bytecode.ObjectType) -> a
    void emitPushNull() -> v
    void emitStoreDefaultValue(gnu.bytecode.Variable) -> a
    void emitPushThis() -> w
    void emitPushPrimArray(java.lang.Object,gnu.bytecode.ArrayType) -> a
    void emitArrayLength() -> x
    int adjustTypedOp(gnu.bytecode.Type) -> i
    void emitTypedOp(int,gnu.bytecode.Type) -> b
    void emitArrayStore(gnu.bytecode.Type) -> d
    void emitArrayLoad(gnu.bytecode.Type) -> e
    void emitArrayLoad() -> y
    void emitNew(gnu.bytecode.ClassType) -> b
    void emitNewArray(gnu.bytecode.Type) -> f
    void emitBinop(int,gnu.bytecode.Type) -> c
    void emitAdd(gnu.bytecode.PrimType) -> a
    void emitSub(gnu.bytecode.PrimType) -> b
    void emitAnd() -> z
    void emitPrimop(int,int,gnu.bytecode.Type) -> a
    void emitMaybeWide(int,int) -> b
    void emitLoad(gnu.bytecode.Variable) -> b
    void emitStore(gnu.bytecode.Variable) -> c
    void emitInc(gnu.bytecode.Variable,short) -> a
    void emitFieldop(gnu.bytecode.Field,int) -> a
    void emitGetStatic(gnu.bytecode.Field) -> a
    void emitGetField(gnu.bytecode.Field) -> b
    void emitPutStatic(gnu.bytecode.Field) -> c
    void emitPutField(gnu.bytecode.Field) -> d
    int words(gnu.bytecode.Type[]) -> a
    void emitInvokeMethod(gnu.bytecode.Method,int) -> a
    void emitInvoke(gnu.bytecode.Method) -> a
    void emitInvokeVirtual(gnu.bytecode.Method) -> b
    void emitInvokeSpecial(gnu.bytecode.Method) -> c
    void emitInvokeStatic(gnu.bytecode.Method) -> d
    void emitInvokeInterface(gnu.bytecode.Method) -> e
    void emitTransfer(gnu.bytecode.Label,int) -> c
    void emitGoto(gnu.bytecode.Label) -> b
    void emitJsr(gnu.bytecode.Label) -> c
    gnu.bytecode.ExitableBlock startExitableBlock(gnu.bytecode.Type,boolean) -> a
    void endExitableBlock() -> A
    void emitGotoIfCompare1(gnu.bytecode.Label,int) -> a
    void emitGotoIfIntEqZero(gnu.bytecode.Label) -> d
    void emitGotoIfIntNeZero(gnu.bytecode.Label) -> e
    void emitGotoIfIntGeZero(gnu.bytecode.Label) -> f
    void emitGotoIfCompare2(gnu.bytecode.Label,int) -> b
    void emitGotoIfEq(gnu.bytecode.Label) -> g
    void emitGotoIfNE(gnu.bytecode.Label) -> h
    void emitIfCompare1(int) -> m
    void emitIfIntNotZero() -> B
    void emitIfIntEqZero() -> C
    void emitIfIntLEqZero() -> D
    void emitIfRefCompare1(int) -> n
    void emitIfNotNull() -> E
    void emitIfNull() -> F
    void emitIfIntLt() -> G
    void emitIfNEq() -> H
    void emitIfEq() -> I
    void emitIfThen() -> J
    void emitElse() -> K
    void emitFi() -> L
    void emitConvert(gnu.bytecode.Type,gnu.bytecode.Type) -> a
    void emitCheckcast(gnu.bytecode.Type,int) -> a
    boolean castNeeded(gnu.bytecode.Type,gnu.bytecode.Type) -> b
    void emitCheckcast(gnu.bytecode.Type) -> g
    void emitInstanceof(gnu.bytecode.Type) -> h
    void emitThrow() -> M
    void emitReturn() -> N
    void addHandler(gnu.bytecode.Label,gnu.bytecode.Label,gnu.bytecode.ClassType) -> a
    void emitWithCleanupStart() -> O
    void emitWithCleanupCatch(gnu.bytecode.Variable) -> d
    void emitWithCleanupDone() -> P
    void emitTryStart(boolean,gnu.bytecode.Type) -> a
    void emitTryEnd() -> Q
    void emitTryEnd(boolean) -> c
    void emitCatchStart(gnu.bytecode.Variable) -> e
    void emitCatchEnd() -> R
    void gotoFinallyOrEnd(boolean) -> d
    void emitFinallyStart() -> S
    void emitFinallyEnd() -> T
    void emitTryCatchEnd() -> U
    boolean isInTry() -> V
    gnu.bytecode.SwitchState startSwitch() -> W
    void emitTailCall(boolean,gnu.bytecode.Scope) -> a
    gnu.bytecode.Label mergeLabels(gnu.bytecode.Label,gnu.bytecode.Label) -> b
    void assignConstants(gnu.bytecode.ClassType) -> a
    int getLength() -> c
    void write(java.io.DataOutputStream) -> a
    int beginFragment(gnu.bytecode.Label) -> i
    void endFragment(int) -> j
gnu.bytecode.ConstantPool -> a.a.h:
    gnu.bytecode.CpoolEntry[] pool -> a
    int count -> b
    boolean locked -> c
    gnu.bytecode.CpoolEntry[] hashTab -> d
    void rehash() -> a
    gnu.bytecode.CpoolUtf8 addUtf8(java.lang.String) -> a
    gnu.bytecode.CpoolClass addClass(gnu.bytecode.ObjectType) -> a
    gnu.bytecode.CpoolValue1 addValue1(int,int) -> a
    gnu.bytecode.CpoolValue2 addValue2(int,long) -> a
    gnu.bytecode.CpoolValue1 addFloat(float) -> a
    gnu.bytecode.CpoolValue2 addDouble(double) -> a
    gnu.bytecode.CpoolString addString(java.lang.String) -> b
    gnu.bytecode.CpoolNameAndType addNameAndType(gnu.bytecode.Method) -> a
    gnu.bytecode.CpoolNameAndType addNameAndType(gnu.bytecode.CpoolUtf8,gnu.bytecode.CpoolUtf8) -> a
    gnu.bytecode.CpoolRef addRef(int,gnu.bytecode.CpoolClass,gnu.bytecode.CpoolNameAndType) -> a
    void write(java.io.DataOutputStream) -> a
gnu.bytecode.ConstantValueAttr -> a.a.i:
    int value_index -> d
    void assignConstants(gnu.bytecode.ClassType) -> a
    int getLength() -> c
    void write(java.io.DataOutputStream) -> a
gnu.bytecode.CpoolClass -> a.a.j:
    gnu.bytecode.CpoolUtf8 name -> a
    gnu.bytecode.ObjectType clas -> b
    int hashCode(gnu.bytecode.CpoolUtf8) -> a
    int hashCode() -> hashCode
    void write(java.io.DataOutputStream) -> a
gnu.bytecode.CpoolEntry -> a.a.k:
    int hash -> c
    int index -> d
    gnu.bytecode.CpoolEntry next -> e
    int hashCode() -> hashCode
    void write(java.io.DataOutputStream) -> a
    void add_hashed(gnu.bytecode.ConstantPool) -> a
gnu.bytecode.CpoolNameAndType -> a.a.l:
    gnu.bytecode.CpoolUtf8 name -> a
    gnu.bytecode.CpoolUtf8 type -> b
    int hashCode(gnu.bytecode.CpoolUtf8,gnu.bytecode.CpoolUtf8) -> a
    int hashCode() -> hashCode
    void write(java.io.DataOutputStream) -> a
gnu.bytecode.CpoolRef -> a.a.m:
    gnu.bytecode.CpoolClass clas -> a
    gnu.bytecode.CpoolNameAndType nameAndType -> b
    int tag -> f
    int hashCode(gnu.bytecode.CpoolClass,gnu.bytecode.CpoolNameAndType) -> a
    int hashCode() -> hashCode
    void write(java.io.DataOutputStream) -> a
gnu.bytecode.CpoolString -> a.a.n:
    gnu.bytecode.CpoolUtf8 str -> a
    int hashCode() -> hashCode
    void write(java.io.DataOutputStream) -> a
gnu.bytecode.CpoolUtf8 -> a.a.o:
    java.lang.String string -> a
    int hashCode() -> hashCode
    void write(java.io.DataOutputStream) -> a
gnu.bytecode.CpoolValue1 -> a.a.p:
    int tag -> a
    int value -> b
    int hashCode() -> hashCode
    void write(java.io.DataOutputStream) -> a
gnu.bytecode.CpoolValue2 -> a.a.q:
    int tag -> a
    long value -> b
    int hashCode() -> hashCode
    void write(java.io.DataOutputStream) -> a
gnu.bytecode.EnclosingMethodAttr -> a.a.r:
    int class_index -> e
    int method_index -> f
    gnu.bytecode.Method method -> d
    int getLength() -> c
    void assignConstants(gnu.bytecode.ClassType) -> a
    void write(java.io.DataOutputStream) -> a
gnu.bytecode.ExceptionsAttr -> a.a.s:
    gnu.bytecode.ClassType[] exceptions -> d
    short[] exception_table -> e
    void setExceptions(gnu.bytecode.ClassType[]) -> a
    void assignConstants(gnu.bytecode.ClassType) -> a
    int getLength() -> c
    void write(java.io.DataOutputStream) -> a
gnu.bytecode.ExitableBlock -> a.a.t:
    gnu.bytecode.Variable resultVariable -> a
    gnu.bytecode.CodeAttr code -> b
    gnu.bytecode.TryState initialTryState -> c
    gnu.bytecode.Label endLabel -> d
    gnu.bytecode.ExitableBlock outer -> e
    gnu.bytecode.TryState currentTryState -> f
    gnu.bytecode.ExitableBlock nextCase -> g
    int switchCase -> h
    void exit() -> a
    gnu.bytecode.Label exitIsGoto() -> b
    void exit(gnu.bytecode.TryState) -> a
gnu.bytecode.Field -> a.a.u:
    int flags -> a
    gnu.bytecode.Field next -> b
    gnu.bytecode.Attribute attributes -> h
    gnu.bytecode.ClassType owner -> c
    java.lang.reflect.Field rfield -> i
    gnu.bytecode.Attribute getAttributes() -> a
    void setAttributes(gnu.bytecode.Attribute) -> a
    gnu.bytecode.ClassType getDeclaringClass() -> k
    boolean getStaticFlag() -> i
    int getFlags() -> b
    int getModifiers() -> h
    void assign_constants(gnu.bytecode.ClassType) -> a
    java.lang.reflect.Field getReflectField() -> c
    gnu.bytecode.Field getNext() -> d
    void setConstantValue(java.lang.Object,gnu.bytecode.ClassType) -> a
    java.lang.String toString() -> toString
gnu.bytecode.Filter -> a.a.v:
    boolean select(java.lang.Object) -> a
gnu.bytecode.IfState -> a.a.w:
    gnu.bytecode.IfState previous -> a
    boolean doing_else -> b
    gnu.bytecode.Label end_label -> c
    int start_stack_size -> d
    int stack_growth -> e
    gnu.bytecode.Type[] then_stacked_types -> f
gnu.bytecode.InnerClassesAttr -> a.a.x:
    int count -> d
    short[] data -> e
    void assignConstants(gnu.bytecode.ClassType) -> a
    int getLength() -> c
    void write(java.io.DataOutputStream) -> a
gnu.bytecode.Label -> a.a.y:
    int first_fixup -> a
    int position -> b
    boolean needsStackMapEntry -> c
    gnu.bytecode.Type[] stackTypes -> d
    gnu.bytecode.Type[] localTypes -> e
    java.lang.Object[] typeChangeListeners -> f
    gnu.bytecode.Type mergeTypes(gnu.bytecode.Type,gnu.bytecode.Type) -> a
    void setTypes(gnu.bytecode.Type[],int,gnu.bytecode.Type[],int) -> a
    void setTypes(gnu.bytecode.CodeAttr) -> a
    void setTypes(gnu.bytecode.Label) -> a
    void mergeLocalType(int,gnu.bytecode.Type) -> a
    void defineRaw(gnu.bytecode.CodeAttr) -> b
    void define(gnu.bytecode.CodeAttr) -> c
gnu.bytecode.LineNumbersAttr -> a.a.z:
    short[] linenumber_table -> d
    int linenumber_count -> e
    int getLength() -> c
    void write(java.io.DataOutputStream) -> a
gnu.bytecode.LocalVarsAttr -> a.a.A:
    gnu.bytecode.Method method -> g
    gnu.bytecode.Variable[] used -> d
    gnu.bytecode.Scope current_scope -> e
    gnu.bytecode.Scope parameter_scope -> f
    gnu.bytecode.VarEnumerator allVars() -> d
    void enterScope(gnu.bytecode.Scope) -> a
    boolean isEmpty() -> a
    int getCount() -> e
    int getLength() -> c
    void assignConstants(gnu.bytecode.ClassType) -> a
    void write(java.io.DataOutputStream) -> a
gnu.bytecode.Location -> a.a.B:
    java.lang.String name -> d
    gnu.bytecode.Type type -> e
    int name_index -> f
    int signature_index -> g
    java.lang.String getName() -> e
    void setName(java.lang.String) -> a
    gnu.bytecode.Type getType() -> f
    void setType(gnu.bytecode.Type) -> a
    java.lang.String getSignature() -> g
gnu.bytecode.Member -> a.a.C:
    gnu.bytecode.ClassType getDeclaringClass() -> k
    java.lang.String getName() -> e
    int getModifiers() -> h
    boolean getStaticFlag() -> i
gnu.bytecode.Method -> a.a.D:
    java.lang.String name -> k
    gnu.bytecode.Type[] arg_types -> a
    gnu.bytecode.Type return_type -> b
    int access_flags -> c
    int name_index -> d
    int signature_index -> e
    gnu.bytecode.Method next -> f
    gnu.bytecode.ClassType classfile -> g
    gnu.bytecode.Attribute attributes -> h
    gnu.bytecode.CodeAttr code -> i
    java.lang.String signature -> j
    gnu.bytecode.Attribute getAttributes() -> a
    void setAttributes(gnu.bytecode.Attribute) -> a
    gnu.bytecode.CodeAttr getCode() -> b
    gnu.bytecode.Method makeCloneMethod(gnu.bytecode.Type) -> a
    boolean getStaticFlag() -> i
    boolean isAbstract() -> c
    int getModifiers() -> h
    boolean reachableHere() -> d
    void initCode() -> f
    gnu.bytecode.CodeAttr startCode() -> g
    java.lang.String getSignature() -> j
    void assignConstants() -> l
    gnu.bytecode.ClassType getDeclaringClass() -> k
    gnu.bytecode.Type getReturnType() -> m
    gnu.bytecode.Type[] getParameterTypes() -> n
    java.lang.String getName() -> e
    void setName(java.lang.String) -> a
    gnu.bytecode.Method getNext() -> o
    void listParameters(java.lang.StringBuffer) -> a
    java.lang.String toString() -> toString
gnu.bytecode.MiscAttr -> a.a.E:
    byte[] data -> d
    int offset -> e
    int dataLength -> f
    int getLength() -> c
    void put1(int) -> a
    void put2(int) -> b
    void write(java.io.DataOutputStream) -> a
gnu.bytecode.ObjectType -> a.a.F:
    int flags -> k
    boolean isExisting() -> w
    void setExisting(boolean) -> b
    java.lang.String getInternalName() -> d
    java.lang.Class getContextClass(java.lang.String) -> i
    java.lang.ClassLoader getContextClassLoader() -> x
    java.lang.Class getReflectClass() -> b_
    gnu.bytecode.Type getImplementationType() -> b
    gnu.bytecode.Type promote() -> y
    boolean isInstance(java.lang.Object) -> a
    gnu.bytecode.Field getField(java.lang.String,int) -> a
    gnu.bytecode.Method getMethod(java.lang.String,gnu.bytecode.Type[]) -> b
    int getMethods(gnu.bytecode.Filter,int,java.util.List) -> a
    int compare(gnu.bytecode.Type) -> b
    java.lang.Object coerceFromObject(java.lang.Object) -> b
    void emitCoerceFromObject(gnu.bytecode.CodeAttr) -> a
gnu.bytecode.PrimType -> a.a.G:
    java.lang.Object coerceFromObject(java.lang.Object) -> b
    char charValue(java.lang.Object) -> c
    boolean booleanValue(java.lang.Object) -> d
    gnu.bytecode.ClassType boxedType() -> c
    void emitCoerceToObject(gnu.bytecode.CodeAttr) -> b
    void emitIsInstance(gnu.bytecode.CodeAttr) -> c
    void emitCoerceFromObject(gnu.bytecode.CodeAttr) -> a
    gnu.bytecode.Type promotedType() -> d
    int compare(gnu.bytecode.Type) -> b
gnu.bytecode.Scope -> a.a.H:
    gnu.bytecode.Scope parent -> a
    gnu.bytecode.Scope nextSibling -> b
    gnu.bytecode.Scope firstChild -> c
    gnu.bytecode.Scope lastChild -> d
    gnu.bytecode.Label start -> e
    gnu.bytecode.Label end -> f
    gnu.bytecode.Variable vars -> g
    gnu.bytecode.Variable last_var -> h
    gnu.bytecode.Variable firstVar() -> a
    gnu.bytecode.Variable addVariable(gnu.bytecode.CodeAttr,gnu.bytecode.Type,java.lang.String) -> a
    void addVariable(gnu.bytecode.Variable) -> a
    void addVariableAfter(gnu.bytecode.Variable,gnu.bytecode.Variable) -> a
    void addVariable(gnu.bytecode.CodeAttr,gnu.bytecode.Variable) -> a
    gnu.bytecode.Variable getVariable(int) -> a
    void setStartPC(gnu.bytecode.CodeAttr) -> a
    void noteStartFunction(gnu.bytecode.CodeAttr) -> b
    gnu.bytecode.Variable lookup(java.lang.String) -> a
gnu.bytecode.SourceDebugExtAttr -> a.a.I:
    byte[] data -> e
    int dlength -> f
    java.lang.String outputFileName -> g
    java.lang.String defaultStratumId -> h
    int fileCount -> d
    int[] fileIDs -> i
    java.lang.String[] fileNames -> j
    int lineCount -> k
    int[] lines -> l
    int curLineIndex -> m
    int curFileIndex -> n
    int maxFileID -> o
    java.lang.String curFileName -> p
    int fixLine(int,int) -> a
    int fixLine(int) -> a
    void addFile(java.lang.String) -> a
    void addStratum(java.lang.String) -> b
    void nonAsteriskString(java.lang.String,java.lang.StringBuffer) -> a
    void assignConstants(gnu.bytecode.ClassType) -> a
    int getLength() -> c
    void write(java.io.DataOutputStream) -> a
gnu.bytecode.SourceFileAttr -> a.a.J:
    java.lang.String filename -> d
    int filename_index -> e
    java.lang.String fixSourceFile(java.lang.String) -> a
    void assignConstants(gnu.bytecode.ClassType) -> a
    int getLength() -> c
    void write(java.io.DataOutputStream) -> a
gnu.bytecode.StackMapTableAttr -> a.a.K:
    boolean compressStackMapTable -> j
    int numEntries -> e
    int prevPosition -> k
    int[] encodedLocals -> f
    int[] encodedStack -> g
    int countLocals -> h
    int countStack -> i
    void write(java.io.DataOutputStream) -> a
    void emitVerificationType(int) -> c
    int encodeVerificationType(gnu.bytecode.Type,gnu.bytecode.CodeAttr) -> a
    void emitStackMapEntry(gnu.bytecode.Label,gnu.bytecode.CodeAttr) -> a
gnu.bytecode.SwitchState -> a.a.L:
    int minValue -> c
    int maxValue -> d
    int numCases -> e
    int[] values -> f
    gnu.bytecode.Label[] labels -> g
    gnu.bytecode.Label defaultLabel -> h
    gnu.bytecode.Label switch_label -> a
    gnu.bytecode.Label cases_label -> b
    gnu.bytecode.Label after_label -> i
    boolean addCase(int,gnu.bytecode.CodeAttr) -> a
    void addDefault(gnu.bytecode.CodeAttr) -> a
    boolean insertCase$7f1dd234(int,gnu.bytecode.Label) -> a
    void finish(gnu.bytecode.CodeAttr) -> b
gnu.bytecode.TryState -> a.a.M:
    gnu.bytecode.TryState previous -> a
    gnu.bytecode.Label end_label -> b
    gnu.bytecode.Label finally_subr -> c
    gnu.bytecode.Variable finally_ret_addr -> d
    gnu.bytecode.Variable saved_result -> e
    gnu.bytecode.Variable[] savedStack -> f
    gnu.bytecode.Label start_try -> g
    gnu.bytecode.Label end_try -> h
    gnu.bytecode.ClassType try_type -> i
    gnu.bytecode.Type[] savedTypes -> j
    gnu.bytecode.ExitableBlock exitCases -> k
    gnu.bytecode.Variable exception -> l
    boolean tryClauseDone -> m
    gnu.bytecode.TryState outerHandler(gnu.bytecode.TryState,gnu.bytecode.TryState) -> a
gnu.bytecode.Type -> a.a.N:
    java.lang.String signature -> l
    java.lang.String this_name -> m
    int size -> n
    gnu.bytecode.ArrayType array_type -> o
    gnu.bytecode.Type$ClassToTypeMap mapClassToType -> a
    java.util.HashMap mapNameToType -> b
    gnu.bytecode.PrimType byteType -> p
    gnu.bytecode.PrimType shortType -> q
    gnu.bytecode.PrimType intType -> r
    gnu.bytecode.PrimType longType -> s
    gnu.bytecode.PrimType floatType -> t
    gnu.bytecode.PrimType doubleType -> u
    gnu.bytecode.PrimType booleanType -> v
    gnu.bytecode.PrimType charType -> w
    gnu.bytecode.PrimType voidType -> x
    gnu.bytecode.PrimType int_type -> y
    gnu.bytecode.PrimType long_type -> z
    gnu.bytecode.PrimType float_type -> A
    gnu.bytecode.PrimType double_type -> B
    gnu.bytecode.PrimType boolean_type -> C
    gnu.bytecode.PrimType void_type -> D
    gnu.bytecode.PrimType neverReturnsType -> E
    gnu.bytecode.ObjectType nullType -> F
    gnu.bytecode.ObjectType errorType -> G
    gnu.bytecode.ClassType javalangStringType -> H
    gnu.bytecode.ClassType toStringType -> I
    gnu.bytecode.ClassType javalangObjectType -> J
    gnu.bytecode.ClassType objectType -> K
    gnu.bytecode.ClassType javalangBooleanType -> L
    gnu.bytecode.ClassType javalangThrowableType -> M
    gnu.bytecode.Type[] typeArray0 -> N
    gnu.bytecode.Method toString_method -> O
    gnu.bytecode.ClassType javalangNumberType -> P
    gnu.bytecode.Method clone_method -> Q
    gnu.bytecode.Method intValue_method -> R
    gnu.bytecode.Method longValue_method -> S
    gnu.bytecode.Method floatValue_method -> T
    gnu.bytecode.Method doubleValue_method -> U
    gnu.bytecode.Method booleanValue_method -> V
    gnu.bytecode.ClassType javalangClassType -> W
    gnu.bytecode.ClassType pointer_type -> X
    gnu.bytecode.ClassType string_type -> Y
    gnu.bytecode.ClassType tostring_type -> Z
    gnu.bytecode.ClassType java_lang_Class_type -> aa
    java.lang.Class reflectClass -> ab
    gnu.bytecode.Type getImplementationType() -> b
    boolean isExisting() -> w
    gnu.bytecode.Type lookupType(java.lang.String) -> j
    gnu.bytecode.Type getType(java.lang.String) -> k
    void registerTypeForClass(java.lang.Class,gnu.bytecode.Type) -> a
    gnu.bytecode.Type make(java.lang.Class) -> a
    java.lang.String getSignature() -> c_
    void setSignature(java.lang.String) -> l
    gnu.bytecode.Type promote() -> y
    int getSizeInWords() -> z
    boolean isVoid() -> A
    gnu.bytecode.Type signatureToType(java.lang.String,int,int) -> a
    java.lang.String getName() -> e
    void setName(java.lang.String) -> b
    boolean isValidJavaTypeName(java.lang.String) -> m
    boolean isInstance(java.lang.Object) -> a
    boolean isSubtype(gnu.bytecode.Type) -> c
    gnu.bytecode.Type lowestCommonSuperType(gnu.bytecode.Type,gnu.bytecode.Type) -> a
    int compare(gnu.bytecode.Type) -> b
    int swappedCompareResult(int) -> d
    void emitIsInstance(gnu.bytecode.CodeAttr) -> c
    java.lang.Object coerceFromObject(java.lang.Object) -> b
    java.lang.Object coerceToObject(java.lang.Object) -> e
    void emitConvertFromPrimitive(gnu.bytecode.Type,gnu.bytecode.CodeAttr) -> a
    void emitCoerceToObject(gnu.bytecode.CodeAttr) -> b
    void emitCoerceFromObject(gnu.bytecode.CodeAttr) -> a
    java.lang.Class getReflectClass() -> b_
    void setReflectClass(java.lang.Class) -> b
    java.lang.String toString() -> toString
    int hashCode() -> hashCode
gnu.bytecode.Type$ClassToTypeMap -> a.a.O:
    java.lang.Object getKeyFromValue(java.lang.Object) -> a
gnu.bytecode.UninitializedType -> a.a.P:
    gnu.bytecode.ClassType ctype -> a
    gnu.bytecode.Label label -> b
    gnu.bytecode.UninitializedType uninitializedThis(gnu.bytecode.ClassType) -> a
    gnu.bytecode.Type getImplementationType() -> b
    java.lang.String toString() -> toString
gnu.bytecode.VarEnumerator -> a.a.Q:
    gnu.bytecode.Scope topScope -> a
    gnu.bytecode.Scope currentScope -> b
    gnu.bytecode.Variable next -> c
    void reset() -> a
    void fixup() -> c
    gnu.bytecode.Variable nextVar() -> b
    boolean hasMoreElements() -> hasMoreElements
    java.lang.Object nextElement() -> nextElement
gnu.bytecode.Variable -> a.a.R:
    gnu.bytecode.Variable next -> a
    int flags -> h
    int offset -> b
    gnu.bytecode.Scope scope -> c
    gnu.bytecode.Variable nextVar() -> a
    boolean hasMoreElements() -> hasMoreElements
    java.lang.Object nextElement() -> nextElement
    boolean isAssigned() -> b
    boolean dead() -> c
    void setFlag(boolean,int) -> a
    boolean isSimple() -> d
    void setSimple(boolean) -> a
    boolean isParameter() -> h
    void setParameter(boolean) -> b
    boolean reserveLocal(int,gnu.bytecode.CodeAttr) -> a
    void allocateLocal(gnu.bytecode.CodeAttr) -> a
    void freeLocal(gnu.bytecode.CodeAttr) -> b
    boolean shouldEmit() -> i
    java.lang.String toString() -> toString
gnu.bytecode.ZipLoader -> a.a.S:
    java.util.zip.ZipFile zar -> a
    java.lang.Class loadClass(java.lang.String,boolean) -> loadClass
    void close() -> a
gnu.expr.AccessExp -> a.b.a:
    java.lang.Object symbol -> a
    gnu.expr.Declaration binding -> b
    gnu.expr.Declaration context -> c
    java.lang.String getName() -> a
    java.lang.String getSimpleName() -> b
    java.lang.Object getSymbol() -> c
    gnu.expr.Declaration getBinding() -> d
    void setBinding(gnu.expr.Declaration) -> a
    gnu.expr.Declaration contextDecl() -> e
    void setContextDecl(gnu.expr.Declaration) -> b
gnu.expr.ApplyExp -> a.b.b:
    gnu.expr.Expression func -> a
    gnu.expr.Expression[] args -> b
    gnu.expr.LambdaExp context -> c
    gnu.expr.ApplyExp nextCall -> d
    gnu.bytecode.Type type -> e
    gnu.expr.Expression getFunction() -> b
    gnu.expr.Expression[] getArgs() -> d
    int getArgCount() -> e
    gnu.expr.Expression getArg(int) -> a
    boolean isTailCall() -> f
    void setTailCall(boolean) -> a
    boolean mustCompile() -> d_
    void apply(gnu.mapping.CallContext) -> a
    void compileToArray(gnu.expr.Expression[],gnu.expr.Compilation) -> a
    void compile(gnu.expr.Compilation,gnu.expr.Target) -> a
    void compile(gnu.expr.ApplyExp,gnu.expr.Compilation,gnu.expr.Target) -> a
    void compile(gnu.expr.ApplyExp,gnu.expr.Compilation,gnu.expr.Target,boolean) -> a
    gnu.expr.Expression deepCopy(gnu.kawa.util.IdentityHashTable) -> a
    java.lang.Object visit(gnu.expr.ExpVisitor,java.lang.Object) -> a
    void visitArgs(gnu.expr.InlineCalls) -> a
    void visitChildren(gnu.expr.ExpVisitor,java.lang.Object) -> b
    void print(gnu.mapping.OutPort) -> a
    void pushArgs(gnu.expr.LambdaExp,gnu.expr.Expression[],int[],gnu.expr.Compilation) -> a
    void popParams(gnu.bytecode.CodeAttr,gnu.expr.LambdaExp,int[],boolean) -> a
    void popParams(gnu.bytecode.CodeAttr,int,int,int[],gnu.expr.Declaration,gnu.bytecode.Variable) -> a
    void setType(gnu.bytecode.Type) -> a
    gnu.bytecode.Type getType() -> h
    gnu.expr.Inlineable asInlineable(gnu.mapping.Procedure) -> a
    gnu.expr.Expression inlineIfConstant(gnu.mapping.Procedure,gnu.expr.InlineCalls) -> a
    gnu.expr.Expression inlineIfConstant(gnu.mapping.Procedure,gnu.text.SourceMessages) -> a
    java.lang.String toString() -> toString
gnu.expr.BeginExp -> a.b.c:
    gnu.expr.Expression[] exps -> a
    int length -> b
    gnu.expr.Expression canonicalize(gnu.expr.Expression) -> c
    gnu.expr.Expression canonicalize(gnu.expr.Expression[]) -> a
    void add(gnu.expr.Expression) -> a
    gnu.expr.Expression[] getExpressions() -> b
    boolean mustCompile() -> d_
    void apply(gnu.mapping.CallContext) -> a
    void compile(gnu.expr.Compilation,gnu.expr.Target) -> a
    java.lang.Object visit(gnu.expr.ExpVisitor,java.lang.Object) -> a
    void visitChildren(gnu.expr.ExpVisitor,java.lang.Object) -> b
    void print(gnu.mapping.OutPort) -> a
    gnu.bytecode.Type getType() -> h
gnu.expr.BindingInitializer -> a.b.d:
    gnu.expr.Declaration decl -> c
    gnu.expr.Expression value -> d
    gnu.bytecode.ClassType typeThreadLocation -> e
    void create(gnu.expr.Declaration,gnu.expr.Expression,gnu.expr.Compilation) -> a
    void emit(gnu.expr.Compilation) -> a
    gnu.bytecode.Method makeLocationMethod(java.lang.Object) -> a
gnu.expr.BlockExitException -> a.b.e:
    gnu.expr.ExitExp exit -> a
gnu.expr.BlockExp -> a.b.f:
    gnu.expr.Expression body -> a
    gnu.expr.Expression exitBody -> b
    gnu.bytecode.ExitableBlock exitableBlock -> c
    gnu.expr.Target exitTarget -> d
    boolean mustCompile() -> d_
    void apply(gnu.mapping.CallContext) -> a
    void compile(gnu.expr.Compilation,gnu.expr.Target) -> a
    java.lang.Object visit(gnu.expr.ExpVisitor,java.lang.Object) -> a
    void visitChildren(gnu.expr.ExpVisitor,java.lang.Object) -> b
    void print(gnu.mapping.OutPort) -> a
gnu.expr.BuiltinEnvironment -> a.b.g:
    gnu.expr.BuiltinEnvironment instance -> b
    gnu.expr.BuiltinEnvironment getInstance() -> b
    gnu.mapping.Environment getLangEnvironment() -> l
    gnu.mapping.NamedLocation lookup(gnu.mapping.Symbol,java.lang.Object,int) -> a
    gnu.mapping.NamedLocation getLocation(gnu.mapping.Symbol,java.lang.Object,int,boolean) -> a
    void define(gnu.mapping.Symbol,java.lang.Object,java.lang.Object) -> a
    gnu.mapping.LocationEnumeration enumerateLocations() -> d
    gnu.mapping.LocationEnumeration enumerateAllLocations() -> e
    gnu.mapping.NamedLocation addLocation(gnu.mapping.Symbol,java.lang.Object,gnu.mapping.Location) -> a
gnu.expr.ChainLambdas -> a.b.h:
    gnu.expr.Expression visitScopeExp(gnu.expr.ScopeExp,gnu.expr.ScopeExp) -> a
    java.lang.Object visitClassExp(gnu.expr.ClassExp,java.lang.Object) -> a
    java.lang.Object visitLambdaExp(gnu.expr.LambdaExp,java.lang.Object) -> a
    java.lang.Object visitScopeExp(gnu.expr.ScopeExp,java.lang.Object) -> a
gnu.expr.CheckedTarget -> a.b.i:
    gnu.expr.LambdaExp proc -> b
    java.lang.String procname -> c
    int argno -> f
    gnu.bytecode.ClassType typeClassCastException -> g
    gnu.bytecode.ClassType typeWrongType -> h
    gnu.bytecode.Method initWrongTypeStringMethod -> i
    gnu.bytecode.Method initWrongTypeProcMethod -> j
    gnu.expr.Target getInstance(gnu.bytecode.Type,java.lang.String,int) -> a
    gnu.expr.Target getInstance(gnu.bytecode.Type,gnu.expr.LambdaExp,int) -> a
    gnu.expr.Target getInstance(gnu.bytecode.Type) -> a
    gnu.expr.Target getInstance(gnu.expr.Declaration) -> a
    void compileFromStack(gnu.expr.Compilation,gnu.bytecode.Type) -> a
    void emitCheckedCoerce(gnu.expr.Compilation,gnu.expr.LambdaExp,int,gnu.bytecode.Type) -> a
    void emitCheckedCoerce(gnu.expr.Compilation,gnu.expr.LambdaExp,int,gnu.bytecode.Type,gnu.bytecode.Variable) -> a
    void emitCheckedCoerce(gnu.expr.Compilation,gnu.expr.LambdaExp,java.lang.String,int,gnu.bytecode.Type,gnu.bytecode.Variable) -> a
gnu.expr.ClassExp -> a.b.j:
    boolean simple -> M
    boolean explicitInit -> a
    gnu.bytecode.ClassType instanceType -> b
    java.lang.String classNameSpecifier -> c
    gnu.expr.Expression[] supers -> d
    int superClassIndex -> N
    gnu.expr.LambdaExp initMethod -> e
    gnu.expr.LambdaExp clinitMethod -> f
    boolean partsDeclared -> O
    boolean isSimple() -> b
    boolean isAbstract() -> d
    boolean isMakingClassPair() -> e
    gnu.bytecode.Type getType() -> h
    gnu.bytecode.ClassType getClassType() -> f
    boolean mustCompile() -> d_
    void compile(gnu.expr.Compilation,gnu.expr.Target) -> a
    void compilePushClass(gnu.expr.Compilation,gnu.expr.Target) -> b
    gnu.bytecode.ClassType getCompiledClassType$1e140ce() -> i
    void setTypes(gnu.expr.Compilation) -> a
    void declareParts(gnu.expr.Compilation) -> b
    void getImplMethods(gnu.bytecode.ClassType,java.lang.String,gnu.bytecode.Type[],java.util.Vector) -> a
    void usedSuperClasses(gnu.bytecode.ClassType,gnu.expr.Compilation) -> a
    gnu.bytecode.ClassType compileMembers(gnu.expr.Compilation) -> c
    java.lang.Object visit(gnu.expr.ExpVisitor,java.lang.Object) -> a
    void visitChildren(gnu.expr.ExpVisitor,java.lang.Object) -> b
    void loadSuperStaticLink(gnu.expr.Expression,gnu.bytecode.ClassType,gnu.expr.Compilation) -> a
    void invokeDefaultSuperConstructor(gnu.bytecode.ClassType,gnu.expr.Compilation,gnu.expr.LambdaExp) -> a
    void print(gnu.mapping.OutPort) -> a
    gnu.bytecode.Field compileSetField(gnu.expr.Compilation) -> d
    java.lang.String slotToMethodName(java.lang.String,java.lang.String) -> a
    gnu.expr.Declaration addMethod(gnu.expr.LambdaExp,java.lang.Object) -> a
gnu.expr.ClassInitializer -> a.b.k:
    gnu.expr.ClassExp cexp -> c
    void emit(gnu.expr.Compilation) -> a
gnu.expr.Closure -> a.b.l:
    java.lang.Object[][] evalFrames -> a
    gnu.expr.LambdaExp lambda -> b
    int numArgs() -> e_
    int match0(gnu.mapping.CallContext) -> b
    int match1(java.lang.Object,gnu.mapping.CallContext) -> a
    int match2(java.lang.Object,java.lang.Object,gnu.mapping.CallContext) -> a
    int match3(java.lang.Object,java.lang.Object,java.lang.Object,gnu.mapping.CallContext) -> a
    int match4(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,gnu.mapping.CallContext) -> a
    int matchN(java.lang.Object[],gnu.mapping.CallContext) -> a
    void apply(gnu.mapping.CallContext) -> a
    java.lang.Object getProperty(java.lang.Object,java.lang.Object) -> a
gnu.expr.Compilation -> a.b.m:
    boolean mustCompile -> a
    int maxSelectorValue -> b
    gnu.bytecode.ClassType curClass -> c
    gnu.bytecode.ClassType mainClass -> d
    gnu.bytecode.ClassType moduleClass -> e
    gnu.expr.LambdaExp curLambda -> f
    gnu.expr.ModuleExp mainLambda -> g
    gnu.bytecode.Variable thisDecl -> ah
    gnu.bytecode.Variable moduleInstanceVar -> h
    int state -> ai
    gnu.expr.ModuleInfo minfo -> i
    gnu.text.Lexer lexer -> j
    gnu.bytecode.Field moduleInstanceMainField -> k
    java.util.Stack pendingImports -> l
    boolean debugPrintExpr -> aj
    gnu.text.Options options -> ak
    gnu.text.Options$OptionInfo warnUndefinedVariable -> al
    gnu.text.Options$OptionInfo warnUnknownMember -> am
    gnu.text.Options$OptionInfo warnAsError -> an
    gnu.text.Options currentOptions -> m
    int defaultClassFileVersion -> ao
    int moduleStatic -> n
    gnu.bytecode.ClassType[] classes -> o
    int numClasses -> p
    gnu.bytecode.ArrayClassLoader loader -> q
    boolean immediate -> r
    boolean explicit -> s
    gnu.bytecode.Method method -> t
    gnu.bytecode.Method clinitMethod -> ap
    int method_counter -> u
    gnu.bytecode.ClassType typeObject -> v
    gnu.bytecode.ClassType scmBooleanType -> w
    gnu.bytecode.ClassType typeString -> aq
    gnu.bytecode.ClassType javaStringType -> x
    gnu.bytecode.ClassType scmKeywordType -> y
    gnu.bytecode.ClassType scmSequenceType -> z
    gnu.bytecode.ClassType scmListType -> A
    gnu.bytecode.ClassType typePair -> B
    gnu.bytecode.ArrayType objArrayType -> C
    gnu.bytecode.ClassType typeRunnable -> D
    gnu.bytecode.ClassType typeType -> E
    gnu.bytecode.ClassType typeClass -> F
    gnu.bytecode.ClassType typeClassType -> G
    gnu.bytecode.ClassType typeProcedure -> H
    gnu.bytecode.ClassType typeLanguage -> ar
    gnu.bytecode.ClassType typeEnvironment -> as
    gnu.bytecode.ClassType typeLocation -> I
    gnu.bytecode.ClassType typeSymbol -> J
    gnu.bytecode.Method getLocationMethod -> K
    gnu.bytecode.Field trueConstant -> L
    gnu.bytecode.Field falseConstant -> M
    gnu.bytecode.Method makeListMethod -> N
    gnu.bytecode.Type[] string1Arg -> at
    gnu.bytecode.Type[] apply0args -> au
    gnu.bytecode.Type[] apply1args -> O
    gnu.bytecode.Type[] apply2args -> av
    gnu.bytecode.Type[] applyNargs -> aw
    gnu.bytecode.Method apply0method -> ax
    gnu.bytecode.Method apply1method -> ay
    gnu.bytecode.Method apply2method -> az
    gnu.bytecode.Method apply3method -> aA
    gnu.bytecode.Method apply4method -> aB
    gnu.bytecode.Method applyNmethod -> P
    gnu.bytecode.Method[] applymethods -> Q
    gnu.bytecode.ClassType typeProcedure0 -> aC
    gnu.bytecode.ClassType typeProcedure1 -> aD
    gnu.bytecode.ClassType typeProcedure2 -> aE
    gnu.bytecode.ClassType typeProcedure3 -> aF
    gnu.bytecode.ClassType typeProcedure4 -> aG
    gnu.bytecode.ClassType typeModuleBody -> R
    gnu.bytecode.ClassType typeModuleWithContext -> aH
    gnu.bytecode.ClassType typeApplet -> aI
    gnu.bytecode.ClassType typeServlet -> aJ
    gnu.bytecode.ClassType typeCallContext -> S
    gnu.bytecode.ClassType typeConsumer -> T
    gnu.bytecode.Method getCallContextInstanceMethod -> aK
    gnu.bytecode.ClassType typeValues -> U
    gnu.bytecode.Field noArgsField -> V
    gnu.bytecode.Field pcCallContextField -> aL
    gnu.bytecode.ClassType typeModuleMethod -> W
    gnu.bytecode.Field procCallContextField -> aM
    gnu.bytecode.Type[] applyCpsArgs -> aN
    gnu.expr.Initializer clinitChain -> X
    boolean generateMainDefault -> aO
    boolean generateMain -> Y
    gnu.expr.LitTable litTable -> Z
    int langOptions -> aa
    boolean inlineOk -> aP
    java.lang.String classPrefixDefault -> aQ
    java.lang.String classPrefix -> ab
    boolean emitSourceDebugExtAttr -> aR
    int localFieldIndex -> ac
    gnu.bytecode.Variable callContextVar -> ad
    gnu.bytecode.Variable callContextVarForInit -> aS
    gnu.expr.Language language -> ae
    gnu.bytecode.Method forNameHelper -> aT
    int keyUninitialized -> aU
    gnu.expr.Compilation chainUninitialized -> aV
    gnu.expr.Compilation nextUninitialized -> aW
    gnu.expr.NameLookup lexical -> af
    gnu.expr.ScopeExp current_scope -> ag
    gnu.text.SourceMessages messages -> aX
    java.lang.ThreadLocal current -> aY
    int getState() -> a
    void setState(int) -> a
    void pushPendingImport(gnu.expr.ModuleInfo,gnu.expr.ScopeExp,int) -> a
    boolean warnUndefinedVariable() -> b
    boolean warnUnknownMember() -> c
    boolean warnAsError() -> d
    boolean usingCPStyle() -> e
    gnu.bytecode.CodeAttr getCode() -> f
    boolean generatingApplet() -> v
    boolean generatingServlet() -> w
    boolean sharedModuleDefs() -> g
    gnu.bytecode.ClassType getModuleType() -> h
    void compileConstant(java.lang.Object) -> a
    boolean inlineOk(gnu.expr.Expression) -> a
    boolean inlineOk(gnu.mapping.Procedure) -> a
    void compileConstant(java.lang.Object,gnu.expr.Target) -> a
    void dumpInitializers(gnu.expr.Initializer) -> a
    gnu.bytecode.ClassType findNamedClass(java.lang.String) -> a
    void putURLWords(java.lang.String,java.lang.StringBuffer) -> a
    java.lang.String mangleURI(java.lang.String) -> b
    java.lang.String mangleName(java.lang.String) -> c
    java.lang.String mangleNameIfNeeded(java.lang.String) -> d
    boolean isValidJavaName(java.lang.String) -> e
    java.lang.String mangleName(java.lang.String,boolean) -> a
    java.lang.String mangleName(java.lang.String,int) -> a
    java.lang.String demangleName(java.lang.String,boolean) -> b
    java.lang.String generateClassName(java.lang.String) -> f
    void outputClass(java.lang.String) -> h
    void cleanupAfterCompilation() -> i
    void registerClass(gnu.bytecode.ClassType) -> b
    void addClass(gnu.bytecode.ClassType) -> a
    boolean makeRunnable() -> j
    gnu.bytecode.Method getConstructor(gnu.bytecode.ClassType,gnu.expr.LambdaExp) -> a
    void generateConstructor(gnu.expr.LambdaExp) -> a
    void generateConstructor(gnu.bytecode.ClassType,gnu.expr.LambdaExp) -> b
    void callInitMethods(gnu.bytecode.ClassType,java.util.Vector) -> a
    void generateMatchMethods(gnu.expr.LambdaExp) -> b
    void generateApplyMethodsWithoutContext(gnu.expr.LambdaExp) -> c
    void varArgsToArray(gnu.expr.LambdaExp,int,gnu.bytecode.Variable,gnu.bytecode.Type,gnu.bytecode.Variable) -> a
    void process(int) -> b
    void loadCallContext() -> k
    gnu.expr.Language getLanguage() -> l
    gnu.expr.ModuleExp getModule() -> m
    boolean isStatic() -> n
    void mustCompileHere() -> o
    gnu.expr.ScopeExp currentScope() -> p
    void setCurrentScope(gnu.expr.ScopeExp) -> a
    void pushChain(gnu.expr.ScopeExp,gnu.expr.ScopeExp) -> a
    gnu.expr.ModuleExp pushNewModule(gnu.text.Lexer) -> a
    void push(gnu.expr.ScopeExp) -> b
    void pushScope(gnu.expr.ScopeExp) -> c
    void pop(gnu.expr.ScopeExp) -> d
    void push(gnu.expr.Declaration) -> a
    void usedClass(gnu.bytecode.Type) -> a
    gnu.text.SourceMessages getMessages() -> q
    void error(char,java.lang.String,gnu.text.SourceLocator) -> a
    void error(char,java.lang.String) -> a
    void error(char,gnu.expr.Declaration,java.lang.String,java.lang.String) -> a
    gnu.expr.Expression syntaxError(java.lang.String) -> g
    int getLineNumber() -> getLineNumber
    int getColumnNumber() -> getColumnNumber
    java.lang.String getFileName() -> r
    java.lang.String getPublicId() -> getPublicId
    java.lang.String getSystemId() -> getSystemId
    void setLine(gnu.expr.Expression) -> b
    void setLine(java.lang.Object) -> b
    void setLocation(gnu.text.SourceLocator) -> a
    void setLine(java.lang.String,int,int) -> a
    void letStart() -> s
    gnu.expr.Declaration letVariable(java.lang.Object,gnu.bytecode.Type,gnu.expr.Expression) -> a
    void letEnter() -> t
    gnu.expr.LetExp letDone(gnu.expr.Expression) -> c
    gnu.expr.ApplyExp makeCoercion(gnu.expr.Expression,gnu.expr.Expression) -> a
    gnu.expr.Expression makeCoercion(gnu.expr.Expression,gnu.bytecode.Type) -> a
    void loadClassRef(gnu.bytecode.ObjectType) -> a
    java.lang.Object resolve(java.lang.Object,boolean) -> a
    int registerForImmediateLiterals(gnu.expr.Compilation) -> c
    gnu.expr.Compilation getCurrent() -> u
    gnu.expr.Compilation setSaveCurrent(gnu.expr.Compilation) -> a
    void restoreCurrent(gnu.expr.Compilation) -> b
    java.lang.String toString() -> toString
gnu.expr.ConditionalTarget -> a.b.n:
    gnu.bytecode.Label ifTrue -> a
    gnu.bytecode.Label ifFalse -> b
    gnu.expr.Language language -> f
    boolean trueBranchComesFirst -> c
    gnu.bytecode.Type getType() -> a
    void compileFromStack(gnu.expr.Compilation,gnu.bytecode.Type) -> a
    void emitGotoFirstBranch(gnu.bytecode.CodeAttr) -> a
gnu.expr.ConsumerTarget -> a.b.o:
    gnu.bytecode.Variable consumer -> a
    boolean isContextTarget -> b
    gnu.bytecode.Variable getConsumerVariable() -> b
    boolean isContextTarget() -> c
    gnu.expr.Target makeContextTarget(gnu.expr.Compilation) -> a
    void compileUsingConsumer(gnu.expr.Expression,gnu.expr.Compilation,gnu.expr.Target) -> a
    void compileUsingConsumer(gnu.expr.Expression,gnu.expr.Compilation,gnu.expr.Target,gnu.bytecode.Method,gnu.bytecode.Method) -> a
    void compileFromStack(gnu.expr.Compilation,gnu.bytecode.Type) -> a
    void compileFromStack(gnu.expr.Compilation,gnu.bytecode.Type,int) -> a
    boolean compileWrite(gnu.expr.Expression,gnu.expr.Compilation) -> a
    gnu.bytecode.Type getType() -> a
gnu.expr.Declaration -> a.b.p:
    int counter -> n
    int id -> o
    java.lang.Object symbol -> a
    gnu.expr.ScopeExp context -> b
    gnu.bytecode.Type type -> c
    gnu.expr.Expression typeExp -> d
    gnu.expr.Declaration next -> e
    int evalIndex -> f
    gnu.bytecode.Variable var -> g
    gnu.expr.Declaration nextCapturedVar -> h
    gnu.expr.Declaration base -> i
    gnu.bytecode.Field field -> j
    gnu.expr.Expression value -> k
    long flags -> l
    gnu.expr.ApplyExp firstCall -> m
    gnu.bytecode.Method makeLocationMethod -> p
    java.lang.String filename -> q
    int position -> r
    gnu.expr.Expression getTypeExp() -> a
    gnu.bytecode.Type getType() -> b
    void setType(gnu.bytecode.Type) -> a
    void setTypeExp(gnu.expr.Expression) -> a
    java.lang.String getName() -> c
    java.lang.Object getSymbol() -> d
    void setSymbol(java.lang.Object) -> a
    gnu.expr.Declaration nextDecl() -> e
    gnu.bytecode.Variable getVariable() -> f
    boolean isSimple() -> g
    void setSimple(boolean) -> a
    void setSyntax() -> h
    void loadOwningObject(gnu.expr.Declaration,gnu.expr.Compilation) -> a
    void load(gnu.expr.AccessExp,int,gnu.expr.Compilation,gnu.expr.Target) -> a
    void compileStore(gnu.expr.Compilation) -> a
    gnu.expr.Expression getValue() -> i
    void setValue(gnu.expr.Expression) -> b
    java.lang.Object getConstantValue() -> j
    boolean hasConstantValue() -> k
    boolean shouldEarlyInit() -> l
    boolean isCompiletimeConstant() -> G
    boolean needsExternalAccess() -> m
    boolean needsContext() -> n
    boolean getFlag(long) -> a
    void setFlag(boolean,long) -> a
    void setFlag(long) -> b
    boolean isPublic() -> o
    boolean isPrivate() -> p
    void setPrivate(boolean) -> b
    short getAccessFlags(short) -> a
    boolean isAlias() -> q
    void setAlias(boolean) -> c
    boolean isFluid() -> s
    boolean isProcedureDecl() -> t
    void setProcedureDecl(boolean) -> d
    boolean isNamespaceDecl() -> u
    boolean isIndirectBinding() -> v
    void setIndirectBinding(boolean) -> e
    boolean getCanRead() -> w
    void setCanRead(boolean) -> f
    void setCanRead() -> x
    boolean getCanCall() -> y
    void setCanCall() -> z
    boolean getCanWrite() -> A
    void setCanWrite(boolean) -> g
    boolean isThisParameter() -> B
    boolean ignorable() -> C
    boolean needsInit() -> D
    boolean isStatic() -> E
    boolean isUnknown(gnu.expr.Declaration) -> a
    void noteValue(gnu.expr.Expression) -> c
    void pushIndirectBinding(gnu.expr.Compilation) -> b
    gnu.bytecode.Variable allocateVariable(gnu.bytecode.CodeAttr) -> a
    void setLocation(gnu.text.SourceLocator) -> a
    java.lang.String getFileName() -> r
    java.lang.String getPublicId() -> getPublicId
    java.lang.String getSystemId() -> getSystemId
    int getLineNumber() -> getLineNumber
    int getColumnNumber() -> getColumnNumber
    void printInfo(gnu.mapping.OutPort) -> a
    java.lang.String toString() -> toString
    gnu.expr.Declaration followAliases(gnu.expr.Declaration) -> b
    void makeField(gnu.expr.Compilation,gnu.expr.Expression) -> a
    void makeField(gnu.bytecode.ClassType,gnu.expr.Compilation,gnu.expr.Expression) -> a
    gnu.mapping.Location makeIndirectLocationFor() -> F
    gnu.expr.Declaration getDeclarationFromStatic(java.lang.String,java.lang.String) -> a
gnu.expr.ErrorExp -> a.b.q:
    java.lang.String message -> a
    boolean mustCompile() -> d_
    void print(gnu.mapping.OutPort) -> a
    void compile(gnu.expr.Compilation,gnu.expr.Target) -> a
gnu.expr.ExitExp -> a.b.r:
    gnu.expr.BlockExp block -> a
    gnu.expr.Expression result -> b
    boolean mustCompile() -> d_
    void apply(gnu.mapping.CallContext) -> a
    void compile(gnu.expr.Compilation,gnu.expr.Target) -> a
    gnu.expr.Expression deepCopy(gnu.kawa.util.IdentityHashTable) -> a
    java.lang.Object visit(gnu.expr.ExpVisitor,java.lang.Object) -> a
    void visitChildren(gnu.expr.ExpVisitor,java.lang.Object) -> b
    void print(gnu.mapping.OutPort) -> a
    gnu.bytecode.Type getType() -> h
gnu.expr.ExpExpVisitor -> a.b.s:
    gnu.expr.Expression update(gnu.expr.Expression,java.lang.Object) -> a
    java.lang.Object defaultValue(gnu.expr.Expression,java.lang.Object) -> b
gnu.expr.ExpVisitor -> a.b.t:
    gnu.text.SourceMessages messages -> a
    gnu.expr.Compilation comp -> b
    gnu.expr.LambdaExp currentLambda -> c
    java.lang.Object exitValue -> d
    gnu.text.SourceMessages getMessages() -> a
    java.lang.Object defaultValue(gnu.expr.Expression,java.lang.Object) -> b
    java.lang.Object visitExpression(gnu.expr.Expression,java.lang.Object) -> c
    void setContext(gnu.expr.Compilation) -> a
    java.lang.Object visit(gnu.expr.Expression,java.lang.Object) -> d
    gnu.expr.Expression update(gnu.expr.Expression,java.lang.Object) -> a
    java.lang.Object visitApplyExp(gnu.expr.ApplyExp,java.lang.Object) -> a
    java.lang.Object visitIfExp(gnu.expr.IfExp,java.lang.Object) -> a
    void visitDeclarationTypes(gnu.expr.ScopeExp) -> a
    java.lang.Object visitScopeExp(gnu.expr.ScopeExp,java.lang.Object) -> a
    java.lang.Object visitLetExp(gnu.expr.LetExp,java.lang.Object) -> a
    java.lang.Object visitLambdaExp(gnu.expr.LambdaExp,java.lang.Object) -> a
    java.lang.Object visitClassExp(gnu.expr.ClassExp,java.lang.Object) -> a
    java.lang.Object visitObjectExp(gnu.expr.ObjectExp,java.lang.Object) -> a
    java.lang.Object visitModuleExp(gnu.expr.ModuleExp,java.lang.Object) -> a
    gnu.expr.Expression visitSetExpValue(gnu.expr.Expression,java.lang.Object,gnu.expr.Declaration) -> a
    java.lang.Object visitSetExp(gnu.expr.SetExp,java.lang.Object) -> a
    java.lang.Object visitBeginExp(gnu.expr.BeginExp,java.lang.Object) -> a
    java.lang.Object visitQuoteExp(gnu.expr.QuoteExp,java.lang.Object) -> a
    java.lang.Object visitReferenceExp(gnu.expr.ReferenceExp,java.lang.Object) -> a
    java.lang.Object visitThisExp(gnu.expr.ThisExp,java.lang.Object) -> a
    java.lang.Object visitBlockExp(gnu.expr.BlockExp,java.lang.Object) -> a
    java.lang.Object visitExitExp(gnu.expr.ExitExp,java.lang.Object) -> a
    java.lang.Object visitFluidLetExp(gnu.expr.FluidLetExp,java.lang.Object) -> a
    java.lang.Object visitLangExp(gnu.expr.LangExp,java.lang.Object) -> a
    gnu.expr.LambdaExp getCurrentLambda() -> b
    gnu.expr.Expression visitAndUpdate(gnu.expr.Expression,java.lang.Object) -> e
    gnu.expr.Expression[] visitExps(gnu.expr.Expression[],java.lang.Object) -> a
    gnu.expr.Expression[] visitExps(gnu.expr.Expression[],int,java.lang.Object) -> a
    void visitDefaultArgs(gnu.expr.LambdaExp,java.lang.Object) -> b
    void error(char,java.lang.String) -> a
    gnu.expr.Expression noteError(java.lang.String) -> a
    java.lang.String getFileName() -> r
    int getLineNumber() -> getLineNumber
    int getColumnNumber() -> getColumnNumber
    java.lang.String getPublicId() -> getPublicId
    java.lang.String getSystemId() -> getSystemId
gnu.expr.Expression -> a.b.u:
    java.lang.String filename -> g
    int position -> a
    int flags -> h
    java.lang.Object eval(gnu.mapping.CallContext) -> c
    java.lang.Object eval(gnu.mapping.Environment) -> a
    boolean mustCompile() -> d_
    int match0(gnu.mapping.CallContext) -> b
    java.lang.Object apply0() -> j
    void apply(gnu.mapping.CallContext) -> a
    void print(gnu.lists.Consumer) -> a_
    void print(gnu.mapping.OutPort) -> a
    void printLineColumn(gnu.mapping.OutPort) -> b
    void compile(gnu.expr.Compilation,gnu.expr.Target) -> a
    void compileWithPosition(gnu.expr.Compilation,gnu.expr.Target) -> c
    void compileWithPosition(gnu.expr.Compilation,gnu.expr.Target,gnu.expr.Expression) -> a
    void compileNotePosition(gnu.expr.Compilation,gnu.expr.Target,gnu.expr.Expression) -> b
    void compile(gnu.expr.Compilation,gnu.bytecode.Type) -> a
    void compile(gnu.expr.Compilation,gnu.expr.Declaration) -> a
    void compileButFirst(gnu.expr.Expression,gnu.expr.Compilation) -> a
    gnu.expr.Expression deepCopy(gnu.expr.Expression,gnu.kawa.util.IdentityHashTable) -> a
    gnu.expr.Expression[] deepCopy(gnu.expr.Expression[],gnu.kawa.util.IdentityHashTable) -> a
    gnu.expr.Expression deepCopy(gnu.expr.Expression) -> b
    gnu.expr.Expression deepCopy(gnu.kawa.util.IdentityHashTable) -> a
    java.lang.Object visit(gnu.expr.ExpVisitor,java.lang.Object) -> a
    void visitChildren(gnu.expr.ExpVisitor,java.lang.Object) -> b
    gnu.expr.Expression validateApply(gnu.expr.ApplyExp,gnu.expr.InlineCalls,gnu.bytecode.Type,gnu.expr.Declaration) -> a
    void setLocation(gnu.text.SourceLocator) -> a
    void setFile(java.lang.String) -> a
    void setLine(int,int) -> a
    java.lang.String getFileName() -> r
    void setLine(gnu.expr.Compilation) -> e
    java.lang.String getPublicId() -> getPublicId
    java.lang.String getSystemId() -> getSystemId
    int getLineNumber() -> getLineNumber
    int getColumnNumber() -> getColumnNumber
    gnu.bytecode.Type getType() -> h
    java.lang.Object valueIfConstant() -> k
    void setFlag(boolean,int) -> a
    void setFlag(int) -> b
    int getFlags() -> l
    boolean getFlag(int) -> c
    java.lang.String toString() -> toString
gnu.expr.FindCapturedVars -> a.b.v:
    int backJumpPossible -> e
    java.util.Hashtable unknownDecls -> f
    gnu.expr.ModuleExp currentModule -> g
    void findCapturedVars(gnu.expr.Expression,gnu.expr.Compilation) -> a
    gnu.expr.Expression visitModuleExp(gnu.expr.ModuleExp,java.lang.Void) -> a
    void maybeWarnNoDeclarationSeen(java.lang.Object,gnu.expr.Compilation,gnu.text.SourceLocator) -> a
    gnu.expr.Expression checkInlineable(gnu.expr.LambdaExp,java.util.Set) -> a
    gnu.expr.Expression visitLambdaExp(gnu.expr.LambdaExp,java.lang.Void) -> a
    void capture(gnu.expr.Declaration) -> a
    gnu.expr.Declaration allocUnboundDecl(java.lang.Object,boolean) -> a
    gnu.expr.Expression visitReferenceExp$41f6daa8(gnu.expr.ReferenceExp) -> a
    void capture(gnu.expr.Declaration,gnu.expr.Declaration) -> a
    void visitDefaultArgs(gnu.expr.LambdaExp,java.lang.Object) -> b
    java.lang.Object visitFluidLetExp(gnu.expr.FluidLetExp,java.lang.Object) -> a
    java.lang.Object visitThisExp(gnu.expr.ThisExp,java.lang.Object) -> a
    java.lang.Object visitReferenceExp(gnu.expr.ReferenceExp,java.lang.Object) -> a
    java.lang.Object visitSetExp(gnu.expr.SetExp,java.lang.Object) -> a
    java.lang.Object visitModuleExp(gnu.expr.ModuleExp,java.lang.Object) -> a
    java.lang.Object visitClassExp(gnu.expr.ClassExp,java.lang.Object) -> a
    java.lang.Object visitLambdaExp(gnu.expr.LambdaExp,java.lang.Object) -> a
    java.lang.Object visitLetExp(gnu.expr.LetExp,java.lang.Object) -> a
    java.lang.Object visitApplyExp(gnu.expr.ApplyExp,java.lang.Object) -> a
gnu.expr.FindTailCalls -> a.b.w:
    gnu.expr.Expression visitExpression$61dac695(gnu.expr.Expression) -> a
    gnu.expr.Expression[] visitExps(gnu.expr.Expression[]) -> a
    gnu.expr.Expression visitApplyExp(gnu.expr.ApplyExp,gnu.expr.Expression) -> a
    void visitLetDecls(gnu.expr.LetExp) -> a
    void postVisitDecls(gnu.expr.ScopeExp) -> b
    gnu.expr.Expression visitLambdaExp$14b97dc9(gnu.expr.LambdaExp) -> a
    void visitLambdaExp(gnu.expr.LambdaExp,boolean) -> a
    gnu.expr.Expression visitClassExp$3e7f8342(gnu.expr.ClassExp) -> a
    gnu.expr.Expression visitSetExp(gnu.expr.Declaration,gnu.expr.Expression) -> a
    java.lang.Object visitFluidLetExp(gnu.expr.FluidLetExp,java.lang.Object) -> a
    java.lang.Object visitBlockExp(gnu.expr.BlockExp,java.lang.Object) -> a
    java.lang.Object visitReferenceExp(gnu.expr.ReferenceExp,java.lang.Object) -> a
    java.lang.Object visitBeginExp(gnu.expr.BeginExp,java.lang.Object) -> a
    java.lang.Object visitSetExp(gnu.expr.SetExp,java.lang.Object) -> a
    java.lang.Object visitClassExp(gnu.expr.ClassExp,java.lang.Object) -> a
    java.lang.Object visitLambdaExp(gnu.expr.LambdaExp,java.lang.Object) -> a
    java.lang.Object visitLetExp(gnu.expr.LetExp,java.lang.Object) -> a
    java.lang.Object visitIfExp(gnu.expr.IfExp,java.lang.Object) -> a
    java.lang.Object visitApplyExp(gnu.expr.ApplyExp,java.lang.Object) -> a
    java.lang.Object visitExpression(gnu.expr.Expression,java.lang.Object) -> c
gnu.expr.FluidLetExp -> a.b.x:
    boolean mustCompile() -> d_
    void compile(gnu.expr.Compilation,gnu.expr.Target) -> a
    void doInits(gnu.expr.Declaration,int,gnu.bytecode.Variable[],gnu.expr.Compilation,gnu.bytecode.Variable) -> a
    java.lang.Object visit(gnu.expr.ExpVisitor,java.lang.Object) -> a
    void print(gnu.mapping.OutPort) -> a
gnu.expr.GenericProc -> a.b.y:
    gnu.mapping.MethodProc[] methods -> a
    int count -> b
    int minArgs -> d
    int maxArgs -> f
    int numArgs() -> e_
    void addAtEnd(gnu.mapping.MethodProc) -> b
    void add(gnu.mapping.MethodProc) -> a
    java.lang.Object applyN(java.lang.Object[]) -> a
    int isApplicable(gnu.bytecode.Type[]) -> a
    int match0(gnu.mapping.CallContext) -> b
    int match1(java.lang.Object,gnu.mapping.CallContext) -> a
    int match2(java.lang.Object,java.lang.Object,gnu.mapping.CallContext) -> a
    int match3(java.lang.Object,java.lang.Object,java.lang.Object,gnu.mapping.CallContext) -> a
    int match4(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,gnu.mapping.CallContext) -> a
    int matchN(java.lang.Object[],gnu.mapping.CallContext) -> a
gnu.expr.IfExp -> a.b.z:
    gnu.expr.Expression test -> a
    gnu.expr.Expression then_clause -> b
    gnu.expr.Expression else_clause -> c
    boolean mustCompile() -> d_
    void apply(gnu.mapping.CallContext) -> a
    gnu.expr.Expression select(boolean) -> a
    void compile(gnu.expr.Compilation,gnu.expr.Target) -> a
    void compile(gnu.expr.Expression,gnu.expr.Expression,gnu.expr.Expression,gnu.expr.Compilation,gnu.expr.Target) -> a
    java.lang.Object visit(gnu.expr.ExpVisitor,java.lang.Object) -> a
    void visitChildren(gnu.expr.ExpVisitor,java.lang.Object) -> b
    gnu.bytecode.Type getType() -> h
    void print(gnu.mapping.OutPort) -> a
gnu.expr.IgnoreTarget -> a.b.A:
    gnu.bytecode.Type getType() -> a
    void compileFromStack(gnu.expr.Compilation,gnu.bytecode.Type) -> a
gnu.expr.Initializer -> a.b.B:
    gnu.expr.Initializer next -> a
    gnu.bytecode.Field field -> b
    void emit(gnu.expr.Compilation) -> a
    void reportError(java.lang.String,gnu.expr.Compilation) -> a
gnu.expr.InlineCalls -> a.b.C:
    java.lang.Class[] inlinerMethodArgTypes -> e
    gnu.expr.Expression inlineCalls(gnu.expr.Expression,gnu.expr.Compilation) -> a
    gnu.expr.Expression visit(gnu.expr.Expression,gnu.bytecode.Type) -> a
    java.lang.Integer checkIntValue(gnu.expr.Expression) -> a
    java.lang.Long checkLongValue(gnu.expr.Expression) -> b
    gnu.expr.Expression visitQuoteExp(gnu.expr.QuoteExp,gnu.bytecode.Type) -> a
    gnu.expr.Expression visitReferenceExp(gnu.expr.ReferenceExp,gnu.bytecode.Type) -> a
    gnu.expr.Expression visitScopeExp$563ad984(gnu.expr.ScopeExp) -> b
    java.lang.Class[] getInlinerMethodArgTypes() -> c
    gnu.expr.Expression maybeInline(gnu.expr.ApplyExp,gnu.bytecode.Type,gnu.mapping.Procedure) -> a
    gnu.expr.Expression inlineCall(gnu.expr.LambdaExp,gnu.expr.Expression[],boolean) -> a
    java.lang.Object visitReferenceExp(gnu.expr.ReferenceExp,java.lang.Object) -> a
    java.lang.Object visitQuoteExp(gnu.expr.QuoteExp,java.lang.Object) -> a
    java.lang.Object visitBeginExp(gnu.expr.BeginExp,java.lang.Object) -> a
    java.lang.Object visitSetExp(gnu.expr.SetExp,java.lang.Object) -> a
    gnu.expr.Expression visitSetExpValue(gnu.expr.Expression,java.lang.Object,gnu.expr.Declaration) -> a
    java.lang.Object visitLambdaExp(gnu.expr.LambdaExp,java.lang.Object) -> a
    java.lang.Object visitLetExp(gnu.expr.LetExp,java.lang.Object) -> a
    java.lang.Object visitScopeExp(gnu.expr.ScopeExp,java.lang.Object) -> a
    java.lang.Object visitIfExp(gnu.expr.IfExp,java.lang.Object) -> a
    java.lang.Object visitApplyExp(gnu.expr.ApplyExp,java.lang.Object) -> a
    java.lang.Object visit(gnu.expr.Expression,java.lang.Object) -> d
gnu.expr.Inlineable -> a.b.D:
    void compile(gnu.expr.ApplyExp,gnu.expr.Compilation,gnu.expr.Target) -> a
gnu.expr.KawaConvert -> a.b.E:
    gnu.lists.Convert instance -> a
    gnu.lists.Convert getInstance() -> a
    java.lang.Object charToObject(char) -> a
    char objectToChar(java.lang.Object) -> a
    java.lang.Object byteToObject(byte) -> a
    java.lang.Object shortToObject(short) -> a
    java.lang.Object intToObject(int) -> a
    java.lang.Object longToObject(long) -> a
    java.lang.Object byteToObjectUnsigned(byte) -> b
    java.lang.Object shortToObjectUnsigned(short) -> b
    java.lang.Object intToObjectUnsigned(int) -> b
    java.lang.Object longToObjectUnsigned(long) -> b
    java.lang.Object floatToObject(float) -> a
    java.lang.Object doubleToObject(double) -> a
gnu.expr.Keyword -> a.b.F:
    gnu.mapping.Namespace keywordNamespace -> a
    gnu.mapping.Symbol asSymbol() -> a
    gnu.expr.Keyword make(java.lang.String) -> a
    java.lang.String toString() -> toString
    void print(gnu.lists.Consumer) -> a_
    java.lang.Object searchForKeyword(java.lang.Object[],int,java.lang.Object) -> a
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.expr.LambdaExp -> a.b.G:
    gnu.expr.Expression body -> i
    int min_args -> j
    int max_args -> k
    java.util.Vector applyMethods -> l
    gnu.bytecode.Variable argsArray -> a
    gnu.expr.Declaration firstArgsArrayArg -> b
    gnu.expr.Keyword[] keywords -> m
    gnu.expr.Expression[] defaultArgs -> n
    gnu.expr.Declaration capturedVars -> c
    gnu.bytecode.Variable heapFrame -> o
    gnu.expr.LambdaExp firstChild -> p
    gnu.expr.LambdaExp nextSibling -> q
    gnu.expr.ApplyExp unknownContinuation -> r
    gnu.expr.Expression returnContinuation -> s
    java.util.Set tailCallers -> t
    gnu.expr.LambdaExp inlineHome -> u
    gnu.expr.Expression[] throwsSpecification -> d
    gnu.expr.Declaration nameDecl -> v
    gnu.bytecode.Field closureEnvField -> w
    gnu.bytecode.Field staticLinkField -> x
    gnu.bytecode.Variable closureEnv -> y
    gnu.bytecode.ClassType type -> z
    int selectorValue -> e
    gnu.bytecode.Method[] primMethods -> A
    gnu.bytecode.Method[] primBodyMethods -> f
    gnu.bytecode.Variable thisVariable -> B
    gnu.bytecode.Method searchForKeywordMethod3 -> M
    gnu.bytecode.Method searchForKeywordMethod4 -> N
    gnu.expr.Initializer initChain -> C
    java.lang.Object[] properties -> D
    gnu.bytecode.Type returnType -> E
    void capture(gnu.expr.Declaration) -> a
    void setExceptions(gnu.expr.Expression[]) -> a
    boolean getInlineOnly() -> m
    void setInlineOnly(boolean) -> a
    boolean getNeedsClosureEnv() -> n
    void setNeedsStaticLink(boolean) -> b
    void setImportsLexVars() -> o
    void setNeedsStaticLink() -> p
    void setCallersNeedStaticLink() -> e
    boolean getCanRead() -> q
    void setCanRead(boolean) -> c
    void setCanCall(boolean) -> d
    boolean isClassMethod() -> s
    void setClassMethod(boolean) -> e
    boolean isClassGenerated() -> t
    boolean isAbstract() -> d
    int getCallConvention() -> u
    boolean isHandlingTailCalls() -> v
    gnu.bytecode.ClassType getCompiledClassType$1e140ce() -> i
    gnu.bytecode.Type getType() -> h
    gnu.bytecode.ClassType getClassType() -> f
    int getSelectorValue(gnu.expr.Compilation) -> f
    gnu.bytecode.Method getMethod(int) -> a
    gnu.bytecode.Method getMainMethod() -> w
    gnu.expr.LambdaExp outerLambda() -> x
    boolean inlinedIn(gnu.expr.LambdaExp) -> a
    gnu.expr.LambdaExp getCaller() -> y
    gnu.bytecode.Variable declareThis(gnu.bytecode.ClassType) -> a
    gnu.bytecode.Variable declareClosureEnv() -> z
    void loadHeapFrame(gnu.expr.Compilation) -> g
    void compileEnd(gnu.expr.Compilation) -> h
    void generateApplyMethods(gnu.expr.Compilation) -> i
    gnu.bytecode.Field allocFieldFor(gnu.expr.Compilation) -> j
    void addApplyMethod(gnu.expr.Compilation,gnu.bytecode.Field) -> a
    gnu.bytecode.Field compileSetField(gnu.expr.Compilation) -> d
    void compile(gnu.expr.Compilation,gnu.expr.Target) -> a
    gnu.bytecode.ClassType getHeapFrameType() -> A
    gnu.expr.LambdaExp getOwningLambda() -> B
    void addMethodFor(gnu.bytecode.ClassType,gnu.expr.Compilation,gnu.bytecode.ObjectType) -> a
    void allocChildClasses(gnu.expr.Compilation) -> k
    void allocMethod(gnu.expr.LambdaExp,gnu.expr.Compilation) -> a
    void allocChildMethods(gnu.expr.Compilation) -> l
    void allocFrame(gnu.expr.Compilation) -> m
    void allocParameters(gnu.expr.Compilation) -> n
    void enterFunction(gnu.expr.Compilation) -> o
    void compileAsMethod(gnu.expr.Compilation) -> a
    void compileBody(gnu.expr.Compilation) -> p
    java.lang.Object visit(gnu.expr.ExpVisitor,java.lang.Object) -> a
    void visitChildren(gnu.expr.ExpVisitor,java.lang.Object) -> b
    void visitChildrenOnly(gnu.expr.ExpVisitor,java.lang.Object) -> c
    void visitProperties(gnu.expr.ExpVisitor,java.lang.Object) -> d
    boolean mustCompile() -> d_
    void apply(gnu.mapping.CallContext) -> a
    java.lang.Object evalDefaultArg(int,gnu.mapping.CallContext) -> a
    gnu.expr.Expression validateApply(gnu.expr.ApplyExp,gnu.expr.InlineCalls,gnu.bytecode.Type,gnu.expr.Declaration) -> a
    void print(gnu.mapping.OutPort) -> a
    java.lang.String getExpClassName() -> C
    java.lang.String toString() -> toString
    java.lang.Object getProperty(java.lang.Object,java.lang.Object) -> a
    void setProperty(java.lang.Object,java.lang.Object) -> b
    gnu.bytecode.Type getReturnType() -> D
    void setReturnType(gnu.bytecode.Type) -> a
    void setCoercedReturnType(gnu.bytecode.Type) -> b
    void setCoercedReturnValue(gnu.expr.Expression,gnu.expr.Language) -> a
gnu.expr.LambdaExp$1 -> a.b.H:
    java.lang.String val$mangled -> a
    gnu.expr.LambdaExp this$0 -> b
    boolean select(java.lang.Object) -> a
gnu.expr.LangExp -> a.b.I:
    java.lang.Object hook -> a
    java.lang.Object getLangValue() -> d
    boolean mustCompile() -> d_
    void print(gnu.mapping.OutPort) -> a
    java.lang.Object visit(gnu.expr.ExpVisitor,java.lang.Object) -> a
    void compile(gnu.expr.Compilation,gnu.expr.Target) -> a
gnu.expr.Language -> a.b.J:
    java.lang.InheritableThreadLocal current -> c
    java.lang.String[][] languages -> d
    gnu.mapping.Environment environ -> a
    gnu.mapping.Environment userEnv -> b
    int envCounter -> e
    gnu.expr.Language getDefaultLanguage() -> a
    gnu.expr.Language setSaveCurrent(gnu.expr.Language) -> a
    void restoreCurrent(gnu.expr.Language) -> b
    gnu.expr.Language getInstance(java.lang.String) -> a
    gnu.expr.Language getInstance(java.lang.String,java.lang.Class) -> a
    boolean isTrue(java.lang.Object) -> a
    java.lang.Object booleanObject(boolean) -> a
    boolean hasSeparateFunctionNamespace() -> b
    gnu.mapping.Environment getEnvironment() -> h
    gnu.mapping.Environment getNewEnvironment() -> c
    gnu.mapping.Environment getLangEnvironment() -> d
    gnu.mapping.NamedLocation lookupBuiltin(gnu.mapping.Symbol,java.lang.Object,int) -> a
    void define(java.lang.String,java.lang.Object) -> a
    void defAliasStFld(java.lang.String,java.lang.String,java.lang.String) -> a
    void defProcStFld(java.lang.String,java.lang.String,java.lang.String) -> b
    void defProcStFld(java.lang.String,java.lang.String) -> a
    java.lang.Object getEnvPropertyFor$1e572ce2(java.lang.reflect.Field) -> a
    java.lang.Object getEnvPropertyFor(gnu.expr.Declaration) -> a
    gnu.mapping.Symbol getSymbol(java.lang.String) -> e
    gnu.lists.AbstractFormat getFormat(boolean) -> b
    gnu.lists.Consumer getOutputConsumer(java.io.Writer) -> a
    java.lang.String getName() -> e
    gnu.text.Lexer getLexer(gnu.mapping.InPort,gnu.text.SourceMessages) -> a
    gnu.expr.Compilation getCompilation$4020da18(gnu.text.SourceMessages,gnu.expr.NameLookup) -> a
    gnu.expr.Compilation parse(gnu.mapping.InPort,gnu.text.SourceMessages,int,gnu.expr.ModuleInfo) -> a
    gnu.expr.Compilation parse(gnu.text.Lexer,int,gnu.expr.ModuleInfo) -> a
    boolean parse(gnu.expr.Compilation,int) -> a
    void resolve(gnu.expr.Compilation) -> a
    gnu.bytecode.Type getTypeFor(java.lang.Class) -> a
    gnu.bytecode.Type getLangTypeFor(gnu.bytecode.Type) -> a
    java.lang.String formatType(gnu.bytecode.Type) -> b
    gnu.bytecode.Type string2Type(java.lang.String) -> b
    gnu.bytecode.Type getTypeFor(java.lang.String) -> c
    gnu.bytecode.Type getTypeFor(java.lang.Object,boolean) -> a
    gnu.bytecode.Type asType(java.lang.Object) -> b
    gnu.bytecode.Type getTypeFor(gnu.expr.Expression) -> a
    gnu.bytecode.Type getTypeFor(gnu.expr.Expression,boolean) -> a
    gnu.bytecode.Type unionType(gnu.bytecode.Type,gnu.bytecode.Type) -> a
    gnu.expr.Declaration declFromField(gnu.expr.ModuleExp,java.lang.Object,gnu.bytecode.Field) -> a
    int getNamespaceOf$746c69b6() -> f
    boolean hasNamespace(gnu.expr.Declaration,int) -> a
    void emitPushBoolean(boolean,gnu.bytecode.CodeAttr) -> a
    void emitCoerceToBoolean(gnu.bytecode.CodeAttr) -> a
    java.lang.Object coerceFromObject(java.lang.Class,java.lang.Object) -> a
    java.lang.Object coerceToObject(java.lang.Class,java.lang.Object) -> b
    gnu.mapping.Procedure getPrompter() -> g
    java.lang.Object eval(java.lang.String) -> d
    java.lang.Object eval(gnu.mapping.InPort) -> a
gnu.expr.LetExp -> a.b.K:
    gnu.expr.Expression[] inits -> a
    gnu.expr.Expression body -> b
    boolean mustCompile() -> d_
    void apply(gnu.mapping.CallContext) -> a
    void store_rest(gnu.expr.Compilation,int,gnu.expr.Declaration) -> a
    void compile(gnu.expr.Compilation,gnu.expr.Target) -> a
    gnu.bytecode.Type getType() -> h
    java.lang.Object visit(gnu.expr.ExpVisitor,java.lang.Object) -> a
    void visitChildren(gnu.expr.ExpVisitor,java.lang.Object) -> b
    void print(gnu.mapping.OutPort) -> a
    void print(gnu.mapping.OutPort,java.lang.String,java.lang.String) -> a
gnu.expr.LitTable -> a.b.L:
    gnu.expr.Compilation comp -> a
    gnu.bytecode.ClassType mainClass -> b
    java.util.IdentityHashMap literalTable -> c
    gnu.mapping.Table2D staticTable -> f
    int literalsCount -> d
    gnu.expr.Literal literalsChain -> e
    java.lang.Object[] valueStack -> g
    gnu.bytecode.Type[] typeStack -> h
    int stackPointer -> i
    void emit() -> a
    void push(java.lang.Object,gnu.bytecode.Type) -> a
    void error(java.lang.String) -> a
    void flush() -> flush
    void close() -> close
    void write(int) -> write
    void writeBytes(java.lang.String) -> writeBytes
    void write(byte[]) -> write
    void write(byte[],int,int) -> write
    void writeBoolean(boolean) -> writeBoolean
    void writeChar(int) -> writeChar
    void writeByte(int) -> writeByte
    void writeShort(int) -> writeShort
    void writeInt(int) -> writeInt
    void writeLong(long) -> writeLong
    void writeFloat(float) -> writeFloat
    void writeDouble(double) -> writeDouble
    void writeUTF(java.lang.String) -> writeUTF
    void writeChars(java.lang.String) -> writeChars
    void writeObject(java.lang.Object) -> writeObject
    gnu.expr.Literal findLiteral(java.lang.Object) -> a
    gnu.bytecode.Method getMethod(gnu.bytecode.ClassType,java.lang.String,gnu.expr.Literal,boolean) -> a
    void putArgs$6062cadc(gnu.expr.Literal) -> a
    void store(gnu.expr.Literal,boolean,gnu.bytecode.CodeAttr) -> a
    void emit(gnu.expr.Literal,boolean) -> a
gnu.expr.Literal -> a.b.M:
    gnu.expr.Literal next -> a
    gnu.bytecode.Field field -> b
    java.lang.Object value -> c
    int index -> i
    gnu.bytecode.Type type -> d
    int flags -> e
    java.lang.Object[] argValues -> f
    gnu.bytecode.Type[] argTypes -> g
    gnu.expr.Literal nullLiteral -> h
    void assign(gnu.expr.LitTable) -> a
    void assign(java.lang.String,gnu.expr.LitTable) -> a
    void assign(gnu.bytecode.Field,gnu.expr.LitTable) -> a
gnu.expr.ModuleBody -> a.b.N:
    boolean runDone -> a
    void run$8f795e3() -> d
    void run() -> e
    void runCleanup(gnu.mapping.CallContext,java.lang.Throwable,gnu.lists.Consumer) -> a
    java.lang.Object apply0(gnu.expr.ModuleMethod) -> a
    java.lang.Object apply1(gnu.expr.ModuleMethod,java.lang.Object) -> a
    java.lang.Object apply2(gnu.expr.ModuleMethod,java.lang.Object,java.lang.Object) -> a
    java.lang.Object apply3(gnu.expr.ModuleMethod,java.lang.Object,java.lang.Object,java.lang.Object) -> a
    java.lang.Object apply4(gnu.expr.ModuleMethod,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> a
    java.lang.Object applyN(gnu.expr.ModuleMethod,java.lang.Object[]) -> a
    int match0(gnu.expr.ModuleMethod,gnu.mapping.CallContext) -> a
    int match1(gnu.expr.ModuleMethod,java.lang.Object,gnu.mapping.CallContext) -> a
    int match2(gnu.expr.ModuleMethod,java.lang.Object,java.lang.Object,gnu.mapping.CallContext) -> a
    int match3(gnu.expr.ModuleMethod,java.lang.Object,java.lang.Object,java.lang.Object,gnu.mapping.CallContext) -> a
    int match4(gnu.expr.ModuleMethod,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,gnu.mapping.CallContext) -> a
    int matchN(gnu.expr.ModuleMethod,java.lang.Object[],gnu.mapping.CallContext) -> a
gnu.expr.ModuleContext -> a.b.O:
    gnu.expr.ModuleContext global -> a
    gnu.expr.ModuleContext$ClassToInstanceMap table -> b
    gnu.expr.ModuleContext getContext() -> a
    java.lang.Object findInstance(gnu.expr.ModuleInfo) -> a
    java.lang.Object searchInstance(java.lang.Class) -> a
    java.lang.Object findInstance(java.lang.Class) -> b
    void setInstance(java.lang.Object) -> a
gnu.expr.ModuleContext$ClassToInstanceMap -> a.b.P:
    java.lang.Object getKeyFromValue(java.lang.Object) -> a
gnu.expr.ModuleExp -> a.b.Q:
    int interactiveCounter -> a
    boolean compilerAvailable -> b
    boolean alwaysCompile -> c
    boolean neverCompile -> e
    gnu.expr.ModuleInfo info -> d
    java.lang.Class evalToClass(gnu.expr.Compilation,java.net.URL) -> a
    void mustNeverCompile() -> e
    boolean evalModule(gnu.mapping.Environment,gnu.mapping.CallContext,gnu.expr.Compilation,java.net.URL,gnu.mapping.OutPort) -> a
    java.lang.Object evalModule1(gnu.mapping.Environment,gnu.expr.Compilation,java.net.URL,gnu.mapping.OutPort) -> a
    java.lang.String getNamespaceUri() -> E
    gnu.bytecode.ClassType getSuperType() -> F
    gnu.bytecode.ClassType[] getInterfaces() -> G
    boolean isStatic() -> H
    boolean staticInitRun() -> I
    void allocChildClasses(gnu.expr.Compilation) -> k
    void allocFields(gnu.expr.Compilation) -> a
    java.lang.Object visit(gnu.expr.ExpVisitor,java.lang.Object) -> a
    void print(gnu.mapping.OutPort) -> a
    gnu.expr.Declaration firstDecl() -> J
    gnu.bytecode.ClassType classFor(gnu.expr.Compilation) -> b
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.expr.ModuleInfo -> a.b.R:
    java.lang.String className -> j
    java.lang.Class moduleClass -> a
    gnu.expr.ModuleInfo$ClassToInfoMap mapClassToInfo -> b
    gnu.expr.ModuleExp exp -> c
    gnu.expr.Compilation comp -> d
    gnu.expr.ModuleInfo[] dependencies -> e
    int numDependencies -> f
    java.lang.String sourcePath -> g
    gnu.text.Path sourceAbsPath -> h
    java.lang.String sourceAbsPathname -> i
    long lastCheckedTime -> k
    long lastModifiedTime -> l
    java.lang.String getNamespaceUri() -> a
    gnu.expr.Compilation getCompilation() -> b
    void setCompilation(gnu.expr.Compilation) -> a
    void cleanupAfterCompilation() -> c
    gnu.text.Path absPath(java.lang.String) -> a
    gnu.text.Path getSourceAbsPath() -> d
    java.lang.String getSourceAbsPathname() -> e
    void addDependency(gnu.expr.ModuleInfo) -> a
    gnu.bytecode.ClassType getClassType() -> f
    java.lang.String getClassName() -> g
    void setClassName(java.lang.String) -> b
    gnu.expr.ModuleExp getModuleExp() -> h
    gnu.expr.ModuleExp setupModuleExp() -> i
    java.lang.Class getModuleClass() -> j
    java.lang.Class getModuleClassRaw() -> k
    void setModuleClass(java.lang.Class) -> a
    gnu.expr.ModuleInfo find(gnu.bytecode.ClassType) -> a
    int getState() -> l
    void loadByStages(int) -> a
    boolean loadEager(int) -> b
    void clearClass() -> m
    boolean checkCurrent(gnu.expr.ModuleManager,long) -> a
    java.lang.String toString() -> toString
gnu.expr.ModuleInfo$ClassToInfoMap -> a.b.S:
    java.lang.Object getKeyFromValue(java.lang.Object) -> a
gnu.expr.ModuleManager -> a.b.T:
    java.lang.String compilationDirectory -> e
    gnu.expr.ModuleManager instance -> a
    long lastModifiedCacheTime -> b
    gnu.expr.ModuleInfo[] modules -> c
    int numModules -> d
    gnu.expr.ModuleSet packageInfoChain -> f
    java.lang.String getCompilationDirectory() -> a
    gnu.expr.ModuleManager getInstance() -> b
    void add(gnu.expr.ModuleInfo) -> a
    gnu.expr.ModuleInfo searchWithClassName(java.lang.String) -> d
    gnu.expr.ModuleInfo findWithClass(java.lang.Class) -> a
    gnu.expr.ModuleInfo findWithClassName(java.lang.String) -> a
    gnu.expr.ModuleInfo searchWithAbsSourcePath(java.lang.String) -> e
    gnu.expr.ModuleInfo findWithSourcePath(gnu.text.Path,java.lang.String) -> a
    gnu.expr.ModuleInfo findWithSourcePath(java.lang.String) -> b
    void loadPackageInfo(java.lang.String) -> c
gnu.expr.ModuleMethod -> a.b.U:
    void resolveParameterTypes() -> d
    int numArgs() -> e_
    int match0(gnu.mapping.CallContext) -> b
    int match1(java.lang.Object,gnu.mapping.CallContext) -> a
    int match2(java.lang.Object,java.lang.Object,gnu.mapping.CallContext) -> a
    int match3(java.lang.Object,java.lang.Object,java.lang.Object,gnu.mapping.CallContext) -> a
    int match4(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,gnu.mapping.CallContext) -> a
    int matchN(java.lang.Object[],gnu.mapping.CallContext) -> a
    void apply(gnu.mapping.CallContext) -> a
    java.lang.Object apply0() -> j
    java.lang.Object apply1(java.lang.Object) -> a
    java.lang.Object apply2(java.lang.Object,java.lang.Object) -> c
    java.lang.Object apply3(java.lang.Object,java.lang.Object,java.lang.Object) -> a
    java.lang.Object apply4(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> a
    java.lang.Object applyN(java.lang.Object[]) -> a
gnu.expr.ModuleSet -> a.b.V:
    gnu.expr.ModuleSet next -> a
gnu.expr.NameLookup -> a.b.W:
    gnu.expr.Language language -> c
    gnu.mapping.Symbol KEY -> d
    gnu.expr.NameLookup getInstance(gnu.mapping.Environment,gnu.expr.Language) -> a
    void push(gnu.expr.Declaration) -> a
    void push(gnu.expr.ScopeExp) -> a
    void pop(gnu.expr.ScopeExp) -> b
    gnu.expr.Declaration lookup(java.lang.Object,int) -> a
    gnu.expr.Declaration lookup(java.lang.Object,boolean) -> a
gnu.expr.ObjectExp -> a.b.X:
    gnu.bytecode.Type getType() -> h
    java.lang.Object visit(gnu.expr.ExpVisitor,java.lang.Object) -> a
    void compile(gnu.expr.Compilation,gnu.expr.Target) -> a
gnu.expr.PairClassType -> a.b.Y:
    gnu.bytecode.ClassType instanceType -> ac
gnu.expr.PrimProcedure -> a.b.Z:
    gnu.bytecode.Type retType -> b
    gnu.bytecode.Type[] argTypes -> d
    gnu.bytecode.Method method -> a
    int op_code -> f
    char mode -> g
    gnu.expr.LambdaExp source -> h
    java.lang.reflect.Member member -> i
    java.lang.ClassLoader systemClassLoader -> j
    boolean isSpecial() -> e
    gnu.bytecode.Type getReturnType(gnu.expr.Expression[]) -> a_
    gnu.bytecode.Method getMethod() -> f
    boolean isSideEffectFree() -> g
    boolean takesVarArgs() -> i
    boolean takesContext() -> k
    boolean takesContext(gnu.bytecode.Method) -> a
    int isApplicable(gnu.bytecode.Type[]) -> a
    boolean isConstructor() -> l
    boolean takesTarget() -> m
    int numArgs() -> e_
    int match0(gnu.mapping.CallContext) -> b
    int match1(java.lang.Object,gnu.mapping.CallContext) -> a
    int match2(java.lang.Object,java.lang.Object,gnu.mapping.CallContext) -> a
    int match3(java.lang.Object,java.lang.Object,java.lang.Object,gnu.mapping.CallContext) -> a
    int match4(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,gnu.mapping.CallContext) -> a
    int matchN(java.lang.Object[],gnu.mapping.CallContext) -> a
    void apply(gnu.mapping.CallContext) -> a
    void init(gnu.bytecode.Method) -> b
    boolean getStaticFlag() -> h
    void compile(gnu.expr.ApplyExp,gnu.expr.Compilation,gnu.expr.Target) -> a
    void compile(gnu.bytecode.Type,gnu.expr.ApplyExp,gnu.expr.Compilation,gnu.expr.Target) -> a
    gnu.bytecode.Type getParameterType(int) -> a
    gnu.expr.PrimProcedure getMethodFor(gnu.mapping.Procedure,gnu.expr.Declaration,gnu.expr.Expression[],gnu.expr.Language) -> a
    java.lang.Class getProcedureClass(java.lang.Object) -> b
    gnu.expr.PrimProcedure getMethodFor(gnu.bytecode.ClassType,java.lang.String,gnu.expr.Declaration,gnu.bytecode.Type[],gnu.expr.Language) -> a
    java.lang.String getName() -> a
    java.lang.String getVerboseName() -> n
    java.lang.String toString() -> toString
gnu.expr.ProcInitializer -> a.b.aa:
    gnu.expr.LambdaExp proc -> c
    void emitLoadModuleMethod(gnu.expr.LambdaExp,gnu.expr.Compilation) -> a
    void emit(gnu.expr.Compilation) -> a
    void reportError(java.lang.String,gnu.expr.Compilation) -> a
gnu.expr.PushApply -> a.b.ab:
    java.lang.Object visitApplyExp(gnu.expr.ApplyExp,java.lang.Object) -> a
    gnu.expr.Expression update(gnu.expr.Expression,java.lang.Object) -> a
    java.lang.Object defaultValue(gnu.expr.Expression,java.lang.Object) -> b
gnu.expr.QuoteExp -> a.b.ac:
    java.lang.Object value -> k
    gnu.bytecode.Type type -> a
    gnu.expr.QuoteExp undefined_exp -> b
    gnu.expr.QuoteExp abstractExp -> c
    gnu.expr.QuoteExp voidExp -> d
    gnu.expr.QuoteExp trueExp -> e
    gnu.expr.QuoteExp falseExp -> f
    gnu.expr.QuoteExp nullExp -> i
    gnu.expr.QuoteExp classObjectExp -> j
    java.lang.Object getValue() -> d
    java.lang.Object valueIfConstant() -> k
    gnu.bytecode.Type getRawType() -> e
    gnu.bytecode.Type getType() -> h
    boolean isExplicitlyTyped() -> f
    boolean isSharedConstant() -> i
    gnu.expr.QuoteExp getInstance(java.lang.Object) -> b
    gnu.expr.QuoteExp getInstance(java.lang.Object,gnu.text.SourceLocator) -> a
    gnu.expr.QuoteExp makeShared(java.lang.Object) -> c
    gnu.expr.QuoteExp makeShared(java.lang.Object,gnu.bytecode.Type) -> a
    boolean mustCompile() -> d_
    void apply(gnu.mapping.CallContext) -> a
    void compile(gnu.expr.Compilation,gnu.expr.Target) -> a
    gnu.expr.Expression deepCopy(gnu.kawa.util.IdentityHashTable) -> a
    java.lang.Object visit(gnu.expr.ExpVisitor,java.lang.Object) -> a
    gnu.expr.Expression validateApply(gnu.expr.ApplyExp,gnu.expr.InlineCalls,gnu.bytecode.Type,gnu.expr.Declaration) -> a
    java.lang.String toString() -> toString
    void print(gnu.mapping.OutPort) -> a
gnu.expr.ReferenceExp -> a.b.ad:
    int counter -> c
    int id -> d
    boolean getDontDereference() -> f
    void setDontDereference(boolean) -> a
    boolean isUnknown() -> i
    boolean isProcedureName() -> m
    void setProcedureName(boolean) -> b
    boolean mustCompile() -> d_
    java.lang.Object valueIfConstant() -> k
    void apply(gnu.mapping.CallContext) -> a
    void compile(gnu.expr.Compilation,gnu.expr.Target) -> a
    gnu.expr.Expression deepCopy(gnu.kawa.util.IdentityHashTable) -> a
    java.lang.Object visit(gnu.expr.ExpVisitor,java.lang.Object) -> a
    gnu.expr.Expression validateApply(gnu.expr.ApplyExp,gnu.expr.InlineCalls,gnu.bytecode.Type,gnu.expr.Declaration) -> a
    void print(gnu.mapping.OutPort) -> a
    gnu.bytecode.Type getType() -> h
    java.lang.String toString() -> toString
gnu.expr.ScopeExp -> a.b.ae:
    gnu.expr.Declaration decls -> F
    gnu.expr.Declaration last -> a
    gnu.bytecode.Scope scope -> b
    gnu.expr.ScopeExp outer -> G
    int frameSize -> H
    int counter -> c
    int id -> I
    gnu.expr.Declaration firstDecl() -> J
    gnu.bytecode.Scope getVarScope() -> K
    void popScope(gnu.bytecode.CodeAttr) -> a
    void add(gnu.expr.Declaration) -> a
    void add(gnu.expr.Declaration,gnu.expr.Declaration) -> a
    void replaceFollowing(gnu.expr.Declaration,gnu.expr.Declaration) -> b
    void remove(gnu.expr.Declaration) -> b
    void remove(gnu.expr.Declaration,gnu.expr.Declaration) -> c
    gnu.expr.LambdaExp currentLambda() -> L
    gnu.expr.ScopeExp topLevel() -> M
    gnu.expr.Declaration lookup(java.lang.Object) -> b
    gnu.expr.Declaration lookup(java.lang.Object,gnu.expr.Language,int) -> a
    void duplicateDeclarationError(gnu.expr.Declaration,gnu.expr.Declaration,gnu.expr.Compilation) -> a
    gnu.expr.Declaration addDeclaration(java.lang.Object) -> c
    gnu.expr.Declaration addDeclaration(java.lang.Object,gnu.bytecode.Type) -> a
    void addDeclaration(gnu.expr.Declaration) -> c
    int countDecls() -> N
    int countNonDynamicDecls() -> O
    int nesting(gnu.expr.ScopeExp) -> a
    boolean nestedIn(gnu.expr.ScopeExp) -> b
    void setIndexes() -> P
    java.lang.Object visit(gnu.expr.ExpVisitor,java.lang.Object) -> a
    java.lang.String toString() -> toString
gnu.expr.SetExp -> a.b.af:
    gnu.expr.Expression new_value -> c
    boolean isDefining() -> f
    void setDefining(boolean) -> a
    boolean getHasValue() -> m
    boolean isFuncDef() -> i
    boolean isSetIfUnbound() -> n
    boolean mustCompile() -> d_
    void apply(gnu.mapping.CallContext) -> a
    void compile(gnu.expr.Compilation,gnu.expr.Target) -> a
    int canUseInc(gnu.expr.Expression,gnu.expr.Declaration) -> a
    gnu.bytecode.Type getType() -> h
    java.lang.Object visit(gnu.expr.ExpVisitor,java.lang.Object) -> a
    void visitChildren(gnu.expr.ExpVisitor,java.lang.Object) -> b
    void print(gnu.mapping.OutPort) -> a
    java.lang.String toString() -> toString
gnu.expr.SimplePrompter -> a.b.ag:
    java.lang.String prefix -> a
    java.lang.String suffix -> b
    java.lang.Object apply1(java.lang.Object) -> a
gnu.expr.Special -> a.b.ah:
    java.lang.String name -> h
    gnu.expr.Special undefined -> a
    gnu.expr.Special optional -> b
    gnu.expr.Special rest -> c
    gnu.expr.Special key -> d
    gnu.expr.Special dfault -> e
    gnu.expr.Special abstractSpecial -> f
    java.lang.Object eof -> g
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    void print(gnu.lists.Consumer) -> a_
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.expr.StackTarget -> a.b.ai:
    gnu.bytecode.Type type -> a
    gnu.bytecode.Type getType() -> a
    gnu.expr.Target getInstance(gnu.bytecode.Type) -> b
    boolean compileFromStack0(gnu.expr.Compilation,gnu.bytecode.Type) -> b
    void emitCoerceFromObject(gnu.bytecode.Type,gnu.expr.Compilation) -> a
    void compileFromStack(gnu.expr.Compilation,gnu.bytecode.Type) -> a
gnu.expr.Target -> a.b.aj:
    gnu.expr.Target Ignore -> d
    gnu.expr.Target pushObject -> e
    gnu.bytecode.Type getType() -> a
    void compileFromStack(gnu.expr.Compilation,gnu.bytecode.Type) -> a
    gnu.expr.Target pushValue(gnu.bytecode.Type) -> c
gnu.expr.ThisExp -> a.b.ak:
    java.lang.String THIS_NAME -> c
    int EVAL_TO_CONTEXT -> d
    boolean isForContext() -> n
    void apply(gnu.mapping.CallContext) -> a
    void compile(gnu.expr.Compilation,gnu.expr.Target) -> a
    java.lang.Object visit(gnu.expr.ExpVisitor,java.lang.Object) -> a
    gnu.bytecode.Type getType() -> h
gnu.expr.TypeValue -> a.b.al:
    gnu.bytecode.Type getImplementationType() -> b
    void emitTestIf(gnu.bytecode.Variable,gnu.expr.Declaration,gnu.expr.Compilation) -> a
    void emitIsInstance(gnu.bytecode.Variable,gnu.expr.Compilation,gnu.expr.Target) -> a
    gnu.mapping.Procedure getConstructor() -> a
    gnu.expr.Expression convertValue(gnu.expr.Expression) -> a
gnu.kawa.functions.AddOp -> a.c.a.a:
    int plusOrMinus -> c
    gnu.kawa.functions.AddOp $Pl -> a
    gnu.kawa.functions.AddOp $Mn -> b
    java.lang.Object applyN(java.lang.Object[]) -> a
gnu.kawa.functions.AppendValues -> a.c.a.b:
    gnu.kawa.functions.AppendValues appendValues -> a
    void apply(gnu.mapping.CallContext) -> a
    void compile(gnu.expr.ApplyExp,gnu.expr.Compilation,gnu.expr.Target) -> a
    gnu.bytecode.Type getReturnType(gnu.expr.Expression[]) -> a_
gnu.kawa.functions.Apply -> a.c.a.c:
    gnu.kawa.functions.ApplyToArgs applyToArgs -> a
    java.lang.Object[] getArguments(java.lang.Object[],int,gnu.mapping.Procedure) -> a
    java.lang.Object applyN(java.lang.Object[]) -> a
    void apply(gnu.mapping.CallContext) -> a
gnu.kawa.functions.ApplyToArgs -> a.c.a.d:
    int match1(java.lang.Object,gnu.mapping.CallContext) -> a
    int match2(java.lang.Object,java.lang.Object,gnu.mapping.CallContext) -> a
    int match3(java.lang.Object,java.lang.Object,java.lang.Object,gnu.mapping.CallContext) -> a
    int match4(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,gnu.mapping.CallContext) -> a
    int matchN(java.lang.Object[],gnu.mapping.CallContext) -> a
    void checkN(java.lang.Object[],gnu.mapping.CallContext) -> b
    java.lang.Object applyN(java.lang.Object[]) -> a
gnu.kawa.functions.ArithOp -> a.c.a.e:
    boolean isSideEffectFree() -> g
gnu.kawa.functions.Arithmetic -> a.c.a.f:
    gnu.kawa.lispexpr.LangObjType typeDFloNum -> b
    gnu.kawa.lispexpr.LangObjType typeRatNum -> c
    gnu.kawa.lispexpr.LangObjType typeRealNum -> d
    gnu.bytecode.ClassType typeNumeric -> e
    gnu.kawa.lispexpr.LangObjType typeIntNum -> a
    int classifyValue(java.lang.Object) -> a
    int classifyType(gnu.bytecode.Type) -> a
    int asInt(java.lang.Object) -> b
    long asLong(java.lang.Object) -> c
    float asFloat(java.lang.Object) -> d
    double asDouble(java.lang.Object) -> e
    java.math.BigInteger asBigInteger(java.lang.Object) -> f
    gnu.math.IntNum asIntNum(java.lang.Object) -> g
    java.math.BigDecimal asBigDecimal(java.lang.Object) -> h
    gnu.math.RatNum asRatNum(java.lang.Object) -> i
    gnu.math.Numeric asNumeric(java.lang.Object) -> j
    boolean isExact(java.lang.Number) -> a
gnu.kawa.functions.CompileNamedPart -> a.c.a.g:
    gnu.expr.Expression makeExp(gnu.expr.Expression,gnu.expr.Expression) -> a
    java.lang.String combineName(gnu.expr.Expression,gnu.expr.Expression) -> b
gnu.kawa.functions.Convert -> a.c.a.h:
    gnu.kawa.functions.Convert as -> a
    gnu.kawa.functions.Convert getInstance() -> d
    java.lang.Object apply2(java.lang.Object,java.lang.Object) -> c
gnu.kawa.functions.DisplayFormat -> a.c.a.i:
    gnu.mapping.ThreadLocation outBase -> a
    gnu.mapping.ThreadLocation outRadix -> b
    boolean readable -> c
    char language -> d
    java.util.regex.Pattern r5rsIdentifierMinusInteriorColons -> e
    void writeBoolean(boolean,gnu.lists.Consumer) -> a
    void write(int,gnu.lists.Consumer) -> a
    void writeObject(java.lang.Object,gnu.lists.Consumer) -> a
    int write(gnu.lists.Array,int,int,gnu.lists.Consumer) -> a
    void writeSymbol(java.lang.String,gnu.lists.Consumer,boolean) -> a
gnu.kawa.functions.GetNamedExp -> a.c.a.j:
    java.lang.String combinedName -> e
    gnu.expr.Declaration makeDecl -> f
    gnu.expr.Declaration invokeDecl -> i
    gnu.expr.Declaration invokeStaticDecl -> j
    gnu.expr.Declaration instanceOfDecl -> k
    gnu.expr.Declaration castDecl -> l
    void apply(gnu.mapping.CallContext) -> a
    gnu.expr.Expression validateApply(gnu.expr.ApplyExp,gnu.expr.InlineCalls,gnu.bytecode.Type,gnu.expr.Declaration) -> a
gnu.kawa.functions.GetNamedPart -> a.c.a.k:
    gnu.kawa.functions.GetNamedPart getNamedPart -> a
    java.lang.Object apply2(java.lang.Object,java.lang.Object) -> c
    java.lang.Object getTypePart(gnu.bytecode.Type,java.lang.String) -> a
    java.lang.Object getNamedPart(java.lang.Object,gnu.mapping.Symbol) -> a
    java.lang.Object getMemberPart(java.lang.Object,java.lang.String) -> a
gnu.kawa.functions.IsEq -> a.c.a.l:
    gnu.expr.Language language -> a
    java.lang.Object apply2(java.lang.Object,java.lang.Object) -> c
    void compile(gnu.expr.ApplyExp,gnu.expr.Compilation,gnu.expr.Target) -> a
    gnu.bytecode.Type getReturnType(gnu.expr.Expression[]) -> a_
gnu.kawa.functions.IsEqual -> a.c.a.m:
    gnu.expr.Language language -> a
    boolean numberEquals(java.lang.Number,java.lang.Number) -> a
    boolean apply(java.lang.Object,java.lang.Object) -> d
    java.lang.Object apply2(java.lang.Object,java.lang.Object) -> c
gnu.kawa.functions.IsEqv -> a.c.a.n:
    gnu.expr.Language language -> a
    java.lang.Object apply2(java.lang.Object,java.lang.Object) -> c
gnu.kawa.functions.MakeList -> a.c.a.o:
    gnu.kawa.functions.MakeList list -> a
    java.lang.Object applyN(java.lang.Object[]) -> a
    void compile(gnu.expr.ApplyExp,gnu.expr.Compilation,gnu.expr.Target) -> a
    void compile(gnu.expr.Expression[],int,gnu.expr.Compilation) -> a
    gnu.bytecode.Type getReturnType(gnu.expr.Expression[]) -> a_
gnu.kawa.functions.Map -> a.c.a.p:
    boolean collect -> a
    gnu.kawa.functions.ApplyToArgs applyToArgs -> b
    java.lang.Object map1(gnu.mapping.Procedure,java.lang.Object) -> a
    void forEach1(gnu.mapping.Procedure,java.lang.Object) -> b
    java.lang.Object apply2(java.lang.Object,java.lang.Object) -> c
    java.lang.Object applyN(java.lang.Object[]) -> a
gnu.kawa.functions.MultiplyOp -> a.c.a.q:
    gnu.kawa.functions.MultiplyOp $St -> a
    java.lang.Object applyN(java.lang.Object[]) -> a
gnu.kawa.functions.NamedPart -> a.c.a.r:
    java.lang.Object container -> a
    java.lang.Object member -> b
    char kind -> c
    gnu.mapping.MethodProc methods -> d
    int numArgs() -> e_
    void apply(gnu.mapping.CallContext) -> a
    java.lang.Object applyN(java.lang.Object[]) -> a
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.kawa.functions.Not -> a.c.a.s:
    gnu.expr.Language language -> a
    java.lang.Object apply1(java.lang.Object) -> a
gnu.kawa.functions.NumberCompare -> a.c.a.t:
    gnu.expr.Language language -> a
    int flags -> b
    int numArgs() -> e_
    boolean $Eq(java.lang.Object,java.lang.Object) -> d
    gnu.kawa.functions.NumberCompare make(gnu.expr.Language,java.lang.String,int) -> a
    java.lang.Object apply2(java.lang.Object,java.lang.Object) -> c
    boolean apply2(int,java.lang.Object,java.lang.Object) -> a
    java.lang.Object applyN(java.lang.Object[]) -> a
    void compile(gnu.expr.ApplyExp,gnu.expr.Compilation,gnu.expr.Target) -> a
    int classify(gnu.expr.Expression) -> a
    gnu.bytecode.Type getReturnType(gnu.expr.Expression[]) -> a_
gnu.kawa.functions.NumberPredicate -> a.c.a.u:
    int op -> a
    gnu.expr.Language language -> b
    java.lang.Object apply1(java.lang.Object) -> a
    int numArgs() -> e_
    void compile(gnu.expr.ApplyExp,gnu.expr.Compilation,gnu.expr.Target) -> a
gnu.kawa.lispexpr.ClassNamespace -> a.c.b.a:
    gnu.bytecode.ClassType ctype -> a
    gnu.bytecode.ClassType getClassType() -> a
    java.lang.Object get(java.lang.String) -> a
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.kawa.lispexpr.LangObjType -> a.c.b.b:
    int typeCode -> ag
    gnu.kawa.lispexpr.LangObjType pathType -> a
    gnu.kawa.lispexpr.LangObjType filepathType -> b
    gnu.kawa.lispexpr.LangObjType URIType -> c
    gnu.kawa.lispexpr.LangObjType typeClass -> d
    gnu.kawa.lispexpr.LangObjType typeType -> e
    gnu.kawa.lispexpr.LangObjType typeClassType -> f
    gnu.kawa.lispexpr.LangObjType numericType -> g
    gnu.kawa.lispexpr.LangObjType realType -> h
    gnu.kawa.lispexpr.LangObjType rationalType -> i
    gnu.kawa.lispexpr.LangObjType integerType -> j
    gnu.kawa.lispexpr.LangObjType dflonumType -> ac
    gnu.kawa.lispexpr.LangObjType vectorType -> ad
    gnu.kawa.lispexpr.LangObjType stringType -> ae
    gnu.kawa.lispexpr.LangObjType listType -> af
    gnu.bytecode.ClassType implementationType -> ah
    gnu.expr.PrimProcedure makePathProc -> ai
    gnu.expr.PrimProcedure makeFilepathProc -> aj
    gnu.expr.PrimProcedure makeURIProc -> ak
    gnu.bytecode.ClassType typeLangObjType -> al
    int compare(gnu.bytecode.Type) -> b
    gnu.bytecode.Field getField(java.lang.String,int) -> a
    gnu.bytecode.Method getMethod(java.lang.String,gnu.bytecode.Type[]) -> b
    int getMethods(gnu.bytecode.Filter,int,java.util.List) -> a
    java.lang.Class getReflectClass() -> b_
    gnu.bytecode.Type getImplementationType() -> b
    void emitIsInstance(gnu.bytecode.Variable,gnu.expr.Compilation,gnu.expr.Target) -> a
    gnu.math.IntNum coerceIntNum(java.lang.Object) -> c
    gnu.bytecode.Method coercionMethod() -> c
    void emitTestIf(gnu.bytecode.Variable,gnu.expr.Declaration,gnu.expr.Compilation) -> a
    java.lang.Object coerceFromObject(java.lang.Object) -> b
    void emitConvertFromPrimitive(gnu.bytecode.Type,gnu.bytecode.CodeAttr) -> a
    gnu.expr.Expression convertValue(gnu.expr.Expression) -> a
    void emitCoerceFromObject(gnu.bytecode.CodeAttr) -> a
    gnu.mapping.Procedure getConstructor() -> a
gnu.kawa.lispexpr.LangPrimType -> a.c.b.c:
    gnu.expr.Language language -> i
    gnu.bytecode.PrimType implementationType -> j
    gnu.bytecode.PrimType byteType -> a
    gnu.bytecode.PrimType shortType -> b
    gnu.bytecode.PrimType intType -> c
    gnu.bytecode.PrimType longType -> d
    gnu.bytecode.PrimType floatType -> e
    gnu.bytecode.PrimType doubleType -> f
    gnu.kawa.lispexpr.LangPrimType charType -> g
    gnu.kawa.lispexpr.LangPrimType voidType -> h
    gnu.bytecode.Type getImplementationType() -> b
    java.lang.Object coerceFromObject(java.lang.Object) -> b
    char charValue(java.lang.Object) -> c
    void emitIsInstance(gnu.bytecode.CodeAttr) -> c
    void emitCoerceFromObject(gnu.bytecode.CodeAttr) -> a
    java.lang.Object coerceToObject(java.lang.Object) -> e
    void emitCoerceToObject(gnu.bytecode.CodeAttr) -> b
    int compare(gnu.bytecode.Type) -> b
    void emitTestIf(gnu.bytecode.Variable,gnu.expr.Declaration,gnu.expr.Compilation) -> a
    gnu.expr.Expression convertValue(gnu.expr.Expression) -> a
    void emitIsInstance(gnu.bytecode.Variable,gnu.expr.Compilation,gnu.expr.Target) -> a
    gnu.mapping.Procedure getConstructor() -> a
gnu.kawa.lispexpr.LispLanguage -> a.c.b.d:
    gnu.mapping.Symbol lookup_sym -> c
    gnu.kawa.reflect.StaticFieldLocation getNamedPartLocation -> d
    gnu.kawa.lispexpr.ReadTable defaultReadTable -> e
    gnu.kawa.lispexpr.ReadTable createReadTable() -> h
    gnu.text.Lexer getLexer(gnu.mapping.InPort,gnu.text.SourceMessages) -> a
    gnu.expr.Compilation getCompilation$4020da18(gnu.text.SourceMessages,gnu.expr.NameLookup) -> a
    boolean parse(gnu.expr.Compilation,int) -> a
    void resolve(gnu.expr.Compilation) -> a
    gnu.expr.Declaration declFromField(gnu.expr.ModuleExp,java.lang.Object,gnu.bytecode.Field) -> a
    void defSntxStFld(java.lang.String,java.lang.String,java.lang.String) -> c
    void defSntxStFld(java.lang.String,java.lang.String) -> b
    gnu.expr.Expression makeBody(gnu.expr.Expression[]) -> a
    gnu.expr.Expression makeApply(gnu.expr.Expression,gnu.expr.Expression[]) -> a
    boolean selfEvaluatingSymbol(java.lang.Object) -> c
    gnu.expr.Expression checkDefaultBinding(gnu.mapping.Symbol,kawa.lang.Translator) -> a
gnu.kawa.lispexpr.LispReader -> a.c.b.e:
    gnu.kawa.util.GeneralHashTable sharedStructureTable -> a
    boolean seenEscapes -> f
    void readNestedComment(char,char) -> a
    char getReadCase() -> o
    java.lang.Object readValues(int,gnu.kawa.lispexpr.ReadTable) -> a
    java.lang.Object readValues(int,gnu.kawa.lispexpr.ReadTableEntry,gnu.kawa.lispexpr.ReadTable) -> a
    java.lang.Object readAndHandleToken(int,int,gnu.kawa.lispexpr.ReadTable) -> a
    void readToken$2649b06c(int,gnu.kawa.lispexpr.ReadTable) -> b
    java.lang.Object readObject() -> a
    boolean validPostfixLookupStart(int,gnu.kawa.lispexpr.ReadTable) -> c
    java.lang.Object handlePostfix(java.lang.Object,gnu.kawa.lispexpr.ReadTable,int,int) -> a
    java.lang.Object parseNumber(char[],int,int,char,int,int) -> a
    gnu.math.IntNum valueOf(char[],int,int,int,boolean,long) -> a
    int readEscape() -> b
    int readEscape(int) -> a
    int readHexEscape() -> p
    java.lang.Object readCommand() -> c
    java.lang.Object makeNil() -> d
    gnu.lists.Pair makePair(java.lang.Object,int,int) -> a
    void setCdr(java.lang.Object,java.lang.Object) -> a
    java.lang.Object readNumberWithRadix(int,gnu.kawa.lispexpr.LispReader,int) -> a
    java.lang.Object readCharacter(gnu.kawa.lispexpr.LispReader) -> a
    java.lang.Object readSpecial(gnu.kawa.lispexpr.LispReader) -> b
    gnu.lists.SimpleVector readSimpleVector(gnu.kawa.lispexpr.LispReader,char) -> a
gnu.kawa.lispexpr.MakeXmlElement -> a.c.b.f:
    gnu.kawa.lispexpr.MakeXmlElement makeXml -> a
    gnu.bytecode.ClassType typeNamespace -> c
    gnu.expr.Expression rewriteForm(gnu.lists.Pair,kawa.lang.Translator) -> a
gnu.kawa.lispexpr.ReadTable -> a.c.b.g:
    int defaultBracketMode -> d
    char postfixLookupOperator -> a
    boolean finalColonIsKeyword -> b
    boolean hexEscapeAfterBackslash -> c
    gnu.mapping.ThreadLocation current -> e
    gnu.mapping.Environment ctorTable -> f
    void setFinalColonIsKeyword(boolean) -> a
    gnu.kawa.lispexpr.ReadTable createInitial() -> a
    void initCtorTable() -> c
    void putReaderCtor(java.lang.String,gnu.bytecode.Type) -> a
    void putReaderCtorFld(java.lang.String,java.lang.String,java.lang.String) -> a
    java.lang.Object getReaderCtor(java.lang.String) -> a
    gnu.kawa.lispexpr.ReadTable getCurrent() -> b
    gnu.kawa.lispexpr.ReadTableEntry lookup(int) -> a
    java.lang.Object makeSymbol(java.lang.String) -> b
gnu.kawa.lispexpr.ReadTableEntry -> a.c.b.h:
    gnu.kawa.lispexpr.ReadTableEntry illegal -> c
    gnu.kawa.lispexpr.ReadTableEntry whitespace -> d
    gnu.kawa.lispexpr.ReadTableEntry singleEscape -> e
    gnu.kawa.lispexpr.ReadTableEntry multipleEscape -> f
    gnu.kawa.lispexpr.ReadTableEntry constituent -> a
    gnu.kawa.lispexpr.ReadTableEntry brace -> b
    gnu.kawa.lispexpr.ReadTableEntry getIllegalInstance() -> a
    gnu.kawa.lispexpr.ReadTableEntry getWhitespaceInstance() -> b
    gnu.kawa.lispexpr.ReadTableEntry getSingleEscapeInstance() -> c
    gnu.kawa.lispexpr.ReadTableEntry getMultipleEscapeInstance() -> d
    gnu.kawa.lispexpr.ReadTableEntry getDigitInstance() -> e
    gnu.kawa.lispexpr.ReadTableEntry getConstituentInstance() -> f
    int getKind() -> g
    java.lang.Object read(gnu.text.Lexer,int,int) -> a
gnu.kawa.lispexpr.ReaderColon -> a.c.b.i:
    int getKind() -> g
    java.lang.Object read(gnu.text.Lexer,int,int) -> a
gnu.kawa.lispexpr.ReaderDispatch -> a.c.b.j:
    gnu.kawa.util.RangeTable table -> c
    int kind -> d
    int getKind() -> g
    void set(int,java.lang.Object) -> a
    gnu.kawa.lispexpr.ReaderDispatch create(gnu.kawa.lispexpr.ReadTable) -> a
    java.lang.Object read(gnu.text.Lexer,int,int) -> a
gnu.kawa.lispexpr.ReaderDispatchMisc -> a.c.b.k:
    int code -> c
    gnu.kawa.lispexpr.ReaderDispatchMisc instance -> d
    gnu.kawa.lispexpr.ReaderDispatchMisc getInstance() -> h
    java.lang.Object read(gnu.text.Lexer,int,int) -> a
    java.util.regex.Pattern readRegex$589dcd62(gnu.text.Lexer,int) -> a
gnu.kawa.lispexpr.ReaderIgnoreRestOfLine -> a.c.b.l:
    gnu.kawa.lispexpr.ReaderIgnoreRestOfLine instance -> c
    gnu.kawa.lispexpr.ReaderIgnoreRestOfLine getInstance() -> h
    java.lang.Object read(gnu.text.Lexer,int,int) -> a
gnu.kawa.lispexpr.ReaderMisc -> a.c.b.m:
    int kind -> c
    int getKind() -> g
gnu.kawa.lispexpr.ReaderParens -> a.c.b.n:
    char close -> c
    int kind -> d
    java.lang.Object command -> e
    gnu.kawa.lispexpr.ReaderParens instance -> f
    int getKind() -> g
    gnu.kawa.lispexpr.ReaderParens getInstance(char,char) -> a
    java.lang.Object read(gnu.text.Lexer,int,int) -> a
    java.lang.Object readList$81a1e04(gnu.kawa.lispexpr.LispReader,int) -> a
gnu.kawa.lispexpr.ReaderQuote -> a.c.b.o:
    java.lang.Object magicSymbol -> c
    char next -> d
    java.lang.Object magicSymbol2 -> e
    java.lang.Object read(gnu.text.Lexer,int,int) -> a
gnu.kawa.lispexpr.ReaderString -> a.c.b.p:
    java.lang.Object read(gnu.text.Lexer,int,int) -> a
    java.lang.String readString$54e7f927(gnu.text.Lexer,int) -> a
gnu.kawa.lispexpr.ReaderTypespec -> a.c.b.q:
    int getKind() -> g
    java.lang.Object read(gnu.text.Lexer,int,int) -> a
gnu.kawa.lispexpr.ReaderVector -> a.c.b.r:
    char close -> c
    java.lang.Object read(gnu.text.Lexer,int,int) -> a
    gnu.lists.FVector readVector$7a3a294e(gnu.kawa.lispexpr.LispReader,gnu.text.LineBufferedReader,char) -> a
gnu.kawa.lispexpr.ReaderXmlElement -> a.c.b.s:
    java.lang.Object read(gnu.text.Lexer,int,int) -> a
    java.lang.Object readQNameExpression(gnu.kawa.lispexpr.LispReader,int,boolean) -> a
    java.lang.Object readEscapedExpression(gnu.kawa.lispexpr.LispReader,int) -> a
    java.lang.Object readXMLConstructor$f29e294(gnu.kawa.lispexpr.LispReader,int) -> b
    gnu.lists.Pair readContent(gnu.kawa.lispexpr.LispReader,char,gnu.lists.Pair) -> a
    java.lang.Object readEntity(gnu.kawa.lispexpr.LispReader,int) -> c
    int skipSpace(gnu.kawa.lispexpr.LispReader,int) -> d
gnu.kawa.lispexpr.ResolveNamespace -> a.c.b.t:
    gnu.kawa.lispexpr.ResolveNamespace resolveNamespace -> c
    gnu.kawa.lispexpr.ResolveNamespace resolveQName -> a
    boolean resolvingQName -> d
    gnu.expr.Expression rewriteForm(gnu.lists.Pair,kawa.lang.Translator) -> a
gnu.kawa.reflect.ClassMemberLocation -> a.c.c.a:
    java.lang.Object instance -> a
    gnu.bytecode.ClassType type -> b
    java.lang.String mname -> c
    java.lang.reflect.Field rfield -> d
    java.lang.Object getInstance() -> a
    java.lang.String getMemberName() -> f_
    gnu.bytecode.ClassType getDeclaringClass() -> c
    void setup() -> g_
    java.lang.reflect.Field getRField() -> h
    java.lang.Class getRClass() -> h_
    java.lang.Object get(java.lang.Object) -> a
    boolean isConstant() -> f
    boolean isBound() -> g
    void set(java.lang.Object) -> b
    void defineAll(java.lang.Object,gnu.expr.Language,gnu.mapping.Environment) -> a
gnu.kawa.reflect.ClassMethods -> a.c.c.b:
    gnu.kawa.reflect.ClassMethods classMethods -> a
    java.lang.Object apply2(java.lang.Object,java.lang.Object) -> c
    gnu.mapping.MethodProc apply(gnu.mapping.Procedure,java.lang.Object,java.lang.Object) -> a
    int removeRedundantMethods(java.util.Vector) -> a
    gnu.expr.PrimProcedure[] getMethods(gnu.bytecode.ObjectType,java.lang.String,char,gnu.bytecode.ClassType,gnu.expr.Language) -> a
    long selectApplicable(gnu.expr.PrimProcedure[],gnu.bytecode.Type[]) -> a
    gnu.mapping.MethodProc apply(gnu.bytecode.ObjectType,java.lang.String,char,gnu.expr.Language) -> a
    java.lang.String checkName(gnu.expr.Expression,boolean) -> a
    java.lang.String checkName(gnu.expr.Expression) -> a
gnu.kawa.reflect.CompileInvoke -> a.c.c.c:
    java.lang.String name -> a
    int nlen -> b
    int modifiers -> c
    int modmask -> d
    gnu.bytecode.ClassType caller -> e
    gnu.bytecode.ObjectType receiver -> f
    gnu.expr.PrimProcedure getStaticMethod(gnu.bytecode.ClassType,java.lang.String,gnu.expr.Expression[]) -> a
    boolean select(java.lang.Object) -> a
gnu.kawa.reflect.FieldLocation -> a.c.c.d:
    gnu.expr.Declaration decl -> e
    java.lang.Object value -> g
    int flags -> h
    void setProcedure() -> h
    void setSyntax() -> i
    void setKindFlags() -> l
    void setDeclaration(gnu.expr.Declaration) -> a
    gnu.expr.Declaration getDeclaration() -> j
    void setup() -> g_
    java.lang.Object get(java.lang.Object) -> a
    java.lang.Object getFieldValue() -> m
    void set(java.lang.Object) -> b
    boolean isConstant() -> f
    boolean isBound() -> g
    java.lang.String toString() -> toString
gnu.kawa.reflect.InstanceOf -> a.c.c.e:
    gnu.expr.Language language -> a
    gnu.bytecode.ClassType typeType -> b
    gnu.bytecode.Method instanceMethod -> c
    java.lang.Object apply2(java.lang.Object,java.lang.Object) -> c
    void compile(gnu.expr.ApplyExp,gnu.expr.Compilation,gnu.expr.Target) -> a
    gnu.bytecode.Type getReturnType(gnu.expr.Expression[]) -> a_
    void emitIsInstance$44e58eb4(gnu.expr.TypeValue,gnu.expr.Compilation,gnu.expr.Target) -> a
gnu.kawa.reflect.Invoke -> a.c.c.f:
    char kind -> a
    gnu.expr.Language language -> b
    gnu.kawa.reflect.Invoke invokeStatic -> c
    gnu.kawa.reflect.Invoke make -> d
    gnu.bytecode.ObjectType typeFrom(java.lang.Object,gnu.kawa.reflect.Invoke) -> a
    void apply(gnu.mapping.CallContext) -> a
    java.lang.Object applyN(java.lang.Object[]) -> a
    int numArgs() -> e_
    gnu.mapping.MethodProc lookupMethods(gnu.bytecode.ObjectType,java.lang.Object) -> a
    gnu.expr.ApplyExp makeInvokeStatic(gnu.bytecode.ClassType,java.lang.String,gnu.expr.Expression[]) -> a
    gnu.expr.PrimProcedure getStaticMethod(gnu.bytecode.ClassType,java.lang.String,gnu.expr.Expression[]) -> b
gnu.kawa.reflect.OccurrenceType -> a.c.c.g:
    gnu.bytecode.Type base -> a
    int minOccurs -> b
    int maxOccurs -> c
    gnu.bytecode.ClassType typeOccurrenceType -> d
    gnu.bytecode.Method isInstanceMethod -> e
    gnu.bytecode.Type getImplementationType() -> b
    int compare(gnu.bytecode.Type) -> b
    java.lang.Object coerceFromObject(java.lang.Object) -> b
    boolean isInstance(java.lang.Object) -> a
    void emitTestIf(gnu.bytecode.Variable,gnu.expr.Declaration,gnu.expr.Compilation) -> a
    void emitIsInstance(gnu.bytecode.Variable,gnu.expr.Compilation,gnu.expr.Target) -> a
    gnu.expr.Expression convertValue(gnu.expr.Expression) -> a
    gnu.mapping.Procedure getConstructor() -> a
    int itemCountRange(gnu.bytecode.Type) -> a
    boolean itemCountIsOne(gnu.bytecode.Type) -> d
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    java.lang.String toString() -> toString
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.kawa.reflect.SingletonType -> a.c.c.h:
    gnu.kawa.reflect.SingletonType instance -> a
    java.lang.Class getReflectClass() -> b_
    gnu.bytecode.Type getImplementationType() -> b
    int compare(gnu.bytecode.Type) -> b
    java.lang.Object coerceFromObject(java.lang.Object) -> b
    void emitCoerceFromObject(gnu.bytecode.CodeAttr) -> a
    boolean isInstance(java.lang.Object) -> a
gnu.kawa.reflect.SlotGet -> a.c.c.i:
    java.lang.Class[] noClasses -> a
    boolean isStatic -> c
    gnu.kawa.reflect.SlotGet field -> d
    gnu.kawa.reflect.SlotGet staticField -> b
    java.lang.Object field(java.lang.Object,java.lang.String) -> a
    java.lang.Object staticField(java.lang.Object,java.lang.String) -> b
    java.lang.Object apply2(java.lang.Object,java.lang.Object) -> c
    java.lang.Object getSlotValue(boolean,java.lang.Object,java.lang.String,java.lang.String,java.lang.String,java.lang.String,gnu.expr.Language) -> a
    java.lang.Class coerceToClass(java.lang.Object) -> b
    gnu.bytecode.Member lookupMember(gnu.bytecode.ObjectType,java.lang.String,gnu.bytecode.ClassType) -> a
    void compile(gnu.expr.ApplyExp,gnu.expr.Compilation,gnu.expr.Target) -> a
    gnu.bytecode.Type getReturnType(gnu.expr.Expression[]) -> a_
gnu.kawa.reflect.SlotSet -> a.c.c.j:
    boolean isStatic -> c
    boolean returnSelf -> d
    gnu.kawa.reflect.SlotSet set$Mnfield$Ex -> a
    gnu.kawa.reflect.SlotSet set$Mnstatic$Mnfield$Ex -> b
    gnu.kawa.reflect.SlotSet setFieldReturnObject -> e
    gnu.bytecode.Type[] type1Array -> f
    void apply(boolean,java.lang.Object,java.lang.Object,java.lang.Object) -> a
    java.lang.Object apply3(java.lang.Object,java.lang.Object,java.lang.Object) -> a
    void compile(gnu.expr.ApplyExp,gnu.expr.Compilation,gnu.expr.Target) -> a
gnu.kawa.reflect.StaticFieldLocation -> a.c.c.k:
    java.lang.Object get(java.lang.Object) -> a
    gnu.kawa.reflect.StaticFieldLocation define(gnu.mapping.Environment,gnu.mapping.Symbol,java.lang.Object,java.lang.String,java.lang.String) -> a
    gnu.kawa.reflect.StaticFieldLocation make(gnu.expr.Declaration) -> b
gnu.kawa.sax.ContentConsumer -> a.c.d.a:
    int nesting -> a
    java.lang.String[] names -> b
    java.lang.String attrQName -> c
    java.lang.String attrURI -> d
    java.lang.String attrLocalName -> e
    org.xml.sax.helpers.AttributesImpl attributes -> f
    char[] chBuffer -> g
    java.lang.StringBuilder strBuffer -> h
    int inStartTag -> i
    void error(java.lang.String,org.xml.sax.SAXException) -> a
    void endStartTag() -> a
    void startElement(java.lang.Object) -> a
    void startAttribute(java.lang.Object) -> b
    void endAttribute() -> b
    void startDocument() -> startDocument
    void endDocument() -> endDocument
    void endElement() -> c
    void flushStrBuffer() -> e
    void write(char[],int,int) -> write
    void write(int) -> write
    void write(java.lang.String) -> write
    void write(java.lang.CharSequence,int,int) -> a
    gnu.kawa.sax.ContentConsumer append(char) -> a
    gnu.kawa.sax.ContentConsumer append(java.lang.CharSequence) -> a
    gnu.kawa.sax.ContentConsumer append(java.lang.CharSequence,int,int) -> b
    void writeObject(java.lang.Object) -> c
    void writeBoolean(boolean) -> a
    void writeLong(long) -> a
    void writeInt(int) -> a
    void writeFloat(float) -> a
    void writeDouble(double) -> a
    void finalize() -> finalize
    boolean ignoring() -> d
    java.lang.Appendable append(char) -> append
    java.lang.Appendable append(java.lang.CharSequence,int,int) -> append
    java.lang.Appendable append(java.lang.CharSequence) -> append
gnu.kawa.util.AbstractHashTable -> a.c.e.a:
    java.util.Map$Entry[] table -> a
    int mask -> c
    int num_bindings -> b
    int getEntryHashCode(java.util.Map$Entry) -> a
    java.util.Map$Entry getEntryNext(java.util.Map$Entry) -> b
    void setEntryNext(java.util.Map$Entry,java.util.Map$Entry) -> a
    java.util.Map$Entry[] allocEntries(int) -> a
    java.util.Map$Entry makeEntry(java.lang.Object,int,java.lang.Object) -> a
    int hash(java.lang.Object) -> b
    int hashToIndex(int) -> b
    boolean matches(java.lang.Object,int,java.util.Map$Entry) -> a
    boolean matches(java.lang.Object,java.lang.Object) -> a
    java.lang.Object get(java.lang.Object) -> get
    java.util.Map$Entry getNode(java.lang.Object) -> c
    java.lang.Object get(java.lang.Object,java.lang.Object) -> b
    void rehash() -> a
    java.lang.Object put(java.lang.Object,java.lang.Object) -> put
    java.lang.Object remove(java.lang.Object) -> remove
    void clear() -> clear
    int size() -> size
    java.util.Set entrySet() -> entrySet
gnu.kawa.util.AbstractHashTable$AbstractEntrySet -> a.c.e.b:
    gnu.kawa.util.AbstractHashTable htable -> a
    int size() -> size
    java.util.Iterator iterator() -> iterator
gnu.kawa.util.AbstractHashTable$AbstractEntrySet$1 -> a.c.e.c:
    int nextIndex -> a
    java.util.Map$Entry previousEntry -> b
    java.util.Map$Entry currentEntry -> c
    java.util.Map$Entry nextEntry -> d
    int curIndex -> e
    gnu.kawa.util.AbstractHashTable$AbstractEntrySet this$0 -> f
    boolean hasNext() -> hasNext
    void advance() -> a
    void remove() -> remove
    java.lang.Object next() -> next
gnu.kawa.util.AbstractWeakHashTable -> a.c.e.d:
    java.lang.ref.ReferenceQueue rqueue -> c
    java.lang.Object getKeyFromValue(java.lang.Object) -> a
    java.lang.Object get(java.lang.Object,java.lang.Object) -> b
    int hash(java.lang.Object) -> b
    gnu.kawa.util.AbstractWeakHashTable$WEntry makeEntry$70c2eac1(int,java.lang.Object) -> a
    java.lang.Object put(java.lang.Object,java.lang.Object) -> put
    void cleanup() -> b
    java.util.Map$Entry makeEntry(java.lang.Object,int,java.lang.Object) -> a
    java.util.Map$Entry[] allocEntries(int) -> a
    void setEntryNext(java.util.Map$Entry,java.util.Map$Entry) -> a
    java.util.Map$Entry getEntryNext(java.util.Map$Entry) -> b
    int getEntryHashCode(java.util.Map$Entry) -> a
gnu.kawa.util.AbstractWeakHashTable$WEntry -> a.c.e.e:
    gnu.kawa.util.AbstractWeakHashTable$WEntry next -> a
    int hash -> b
    gnu.kawa.util.AbstractWeakHashTable htable -> c
    java.lang.Object getKey() -> getKey
    java.lang.Object getValue() -> getValue
    java.lang.Object setValue(java.lang.Object) -> setValue
gnu.kawa.util.GeneralHashTable -> a.c.e.f:
    gnu.kawa.util.HashNode makeEntry(java.lang.Object,int,java.lang.Object) -> b
    java.util.Map$Entry getNode(java.lang.Object) -> c
    java.util.Map$Entry makeEntry(java.lang.Object,int,java.lang.Object) -> a
    java.util.Map$Entry[] allocEntries(int) -> a
    void setEntryNext(java.util.Map$Entry,java.util.Map$Entry) -> a
    java.util.Map$Entry getEntryNext(java.util.Map$Entry) -> b
    int getEntryHashCode(java.util.Map$Entry) -> a
gnu.kawa.util.HashNode -> a.c.e.g:
    gnu.kawa.util.HashNode next -> a
    int hash -> b
    java.lang.Object key -> c
    java.lang.Object value -> d
    java.lang.Object getKey() -> getKey
    java.lang.Object getValue() -> getValue
    java.lang.Object setValue(java.lang.Object) -> setValue
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
gnu.kawa.util.IdentityHashTable -> a.c.e.h:
    int hash(java.lang.Object) -> b
    boolean matches(java.lang.Object,java.lang.Object) -> a
gnu.kawa.util.RangeTable -> a.c.e.i:
    java.lang.Object[] index -> a
    java.util.Hashtable hash -> b
    java.lang.Object lookup$6ae075e8(int) -> b
    void set(int,int,java.lang.Object) -> a
    void set(int,java.lang.Object) -> a
    void remove(int,int) -> a
    java.lang.Object clone() -> clone
gnu.kawa.xml.CommentConstructor -> a.c.f.a:
    gnu.kawa.xml.CommentConstructor commentConstructor -> a
    int numArgs() -> e_
    void apply(gnu.mapping.CallContext) -> a
gnu.kawa.xml.ElementType -> a.c.f.b:
    gnu.mapping.Symbol MATCH_ANY_QNAME -> a
    gnu.mapping.Symbol qname -> b
    gnu.xml.NamespaceBinding namespaceNodes -> c
    gnu.bytecode.ClassType typeElementType -> d
    gnu.bytecode.Method coerceMethod -> e
    gnu.bytecode.Method coerceOrNullMethod -> f
    gnu.kawa.xml.ElementType make(gnu.mapping.Symbol) -> a
    gnu.bytecode.Type getImplementationType() -> b
    void emitCoerceFromObject(gnu.bytecode.CodeAttr) -> a
    java.lang.Object coerceFromObject(java.lang.Object) -> b
    boolean isInstancePos(gnu.lists.AbstractSequence,int) -> a
    boolean isInstance(java.lang.Object) -> a
    gnu.kawa.xml.KElement coerceOrNull(java.lang.Object,java.lang.String,java.lang.String) -> a
    void emitCoerceOrNullMethod(gnu.bytecode.Variable,gnu.expr.Compilation) -> a
    void setNamespaceNodes(gnu.xml.NamespaceBinding) -> a
    gnu.mapping.Procedure getConstructor() -> a
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
    java.lang.String toString() -> toString
gnu.kawa.xml.KAttr -> a.c.f.c:
    java.lang.String getName() -> getName
    short getNodeType() -> getNodeType
    java.lang.String getValue() -> getValue
    void setValue(java.lang.String) -> setValue
    org.w3c.dom.Node getParentNode() -> getParentNode
    org.w3c.dom.Element getOwnerElement() -> getOwnerElement
    boolean getSpecified() -> getSpecified
    org.w3c.dom.TypeInfo getSchemaTypeInfo() -> getSchemaTypeInfo
    boolean isId() -> isId
gnu.kawa.xml.KCDATASection -> a.c.f.d:
    short getNodeType() -> getNodeType
    java.lang.String getNodeName() -> getNodeName
    java.lang.String getData() -> getData
    int getLength() -> getLength
gnu.kawa.xml.KCharacterData -> a.c.f.e:
    int getLength() -> getLength
    java.lang.String getData() -> getData
    void setData(java.lang.String) -> setData
    java.lang.String substringData(int,int) -> substringData
    void appendData(java.lang.String) -> appendData
    void insertData(int,java.lang.String) -> insertData
    void deleteData(int,int) -> deleteData
    void replaceData(int,int,java.lang.String) -> replaceData
gnu.kawa.xml.KComment -> a.c.f.f:
    short getNodeType() -> getNodeType
    java.lang.String getNodeName() -> getNodeName
gnu.kawa.xml.KDocument -> a.c.f.g:
    java.lang.String getNodeName() -> getNodeName
    org.w3c.dom.DOMImplementation getImplementation() -> getImplementation
    org.w3c.dom.DocumentType getDoctype() -> getDoctype
    org.w3c.dom.Node getParentNode() -> getParentNode
    short getNodeType() -> getNodeType
    java.lang.String getNodeValue() -> getNodeValue
    java.lang.String getTextContent() -> getTextContent
    void getTextContent(java.lang.StringBuffer) -> a
    org.w3c.dom.Element createElement(java.lang.String) -> createElement
    org.w3c.dom.DocumentFragment createDocumentFragment() -> createDocumentFragment
    org.w3c.dom.Text createTextNode(java.lang.String) -> createTextNode
    org.w3c.dom.Comment createComment(java.lang.String) -> createComment
    org.w3c.dom.CDATASection createCDATASection(java.lang.String) -> createCDATASection
    org.w3c.dom.ProcessingInstruction createProcessingInstruction(java.lang.String,java.lang.String) -> createProcessingInstruction
    org.w3c.dom.Attr createAttribute(java.lang.String) -> createAttribute
    org.w3c.dom.EntityReference createEntityReference(java.lang.String) -> createEntityReference
    org.w3c.dom.Node importNode(org.w3c.dom.Node,boolean) -> importNode
    org.w3c.dom.Element createElementNS(java.lang.String,java.lang.String) -> createElementNS
    org.w3c.dom.Attr createAttributeNS(java.lang.String,java.lang.String) -> createAttributeNS
    org.w3c.dom.NodeList getElementsByTagNameNS(java.lang.String,java.lang.String) -> getElementsByTagNameNS
    org.w3c.dom.Element getElementById(java.lang.String) -> getElementById
    boolean hasAttributes() -> hasAttributes
    java.lang.String getInputEncoding() -> getInputEncoding
    java.lang.String getXmlEncoding() -> getXmlEncoding
    boolean getXmlStandalone() -> getXmlStandalone
    void setXmlStandalone(boolean) -> setXmlStandalone
    java.lang.String getXmlVersion() -> getXmlVersion
    void setXmlVersion(java.lang.String) -> setXmlVersion
    boolean getStrictErrorChecking() -> getStrictErrorChecking
    void setStrictErrorChecking(boolean) -> setStrictErrorChecking
    java.lang.String getDocumentURI() -> getDocumentURI
    void setDocumentURI(java.lang.String) -> setDocumentURI
    org.w3c.dom.Node renameNode(org.w3c.dom.Node,java.lang.String,java.lang.String) -> renameNode
    org.w3c.dom.Node adoptNode(org.w3c.dom.Node) -> adoptNode
    void normalizeDocument() -> normalizeDocument
    org.w3c.dom.DOMConfiguration getDomConfig() -> getDomConfig
    org.w3c.dom.Element getDocumentElement() -> getDocumentElement
gnu.kawa.xml.KElement -> a.c.f.h:
    short getNodeType() -> getNodeType
    java.lang.String getTagName() -> getTagName
    java.lang.String getNodeValue() -> getNodeValue
    boolean hasAttributes() -> hasAttributes
    java.lang.String getAttribute(java.lang.String) -> getAttribute
    void setAttribute(java.lang.String,java.lang.String) -> setAttribute
    void setIdAttribute(java.lang.String,boolean) -> setIdAttribute
    void setIdAttributeNS(java.lang.String,java.lang.String,boolean) -> setIdAttributeNS
    void setIdAttributeNode(org.w3c.dom.Attr,boolean) -> setIdAttributeNode
    void removeAttribute(java.lang.String) -> removeAttribute
    org.w3c.dom.Attr setAttributeNode(org.w3c.dom.Attr) -> setAttributeNode
    org.w3c.dom.Attr removeAttributeNode(org.w3c.dom.Attr) -> removeAttributeNode
    java.lang.String getAttributeNS(java.lang.String,java.lang.String) -> getAttributeNS
    void setAttributeNS(java.lang.String,java.lang.String,java.lang.String) -> setAttributeNS
    void removeAttributeNS(java.lang.String,java.lang.String) -> removeAttributeNS
    org.w3c.dom.Attr setAttributeNodeNS(org.w3c.dom.Attr) -> setAttributeNodeNS
    org.w3c.dom.NodeList getElementsByTagNameNS(java.lang.String,java.lang.String) -> getElementsByTagNameNS
    boolean hasAttribute(java.lang.String) -> hasAttribute
    boolean hasAttributeNS(java.lang.String,java.lang.String) -> hasAttributeNS
    org.w3c.dom.TypeInfo getSchemaTypeInfo() -> getSchemaTypeInfo
    org.w3c.dom.Attr getAttributeNodeNS(java.lang.String,java.lang.String) -> getAttributeNodeNS
    org.w3c.dom.Attr getAttributeNode(java.lang.String) -> getAttributeNode
gnu.kawa.xml.KNode -> a.c.f.i:
    java.lang.Object atomicValue(java.lang.Object) -> a
    gnu.kawa.xml.KNode make(gnu.xml.NodeTree,int) -> a
    gnu.kawa.xml.KNode make(gnu.xml.NodeTree) -> a
    boolean isSupported(java.lang.String,java.lang.String) -> isSupported
    java.lang.String getNodeName() -> getNodeName
    java.lang.String getNamespaceURI() -> getNamespaceURI
    java.lang.String getPrefix() -> getPrefix
    java.lang.String getLocalName() -> getLocalName
    java.lang.String getNodeValue(gnu.xml.NodeTree,int) -> b
    void getNodeValue(gnu.xml.NodeTree,int,java.lang.StringBuffer) -> a
    java.lang.String getNodeValue() -> getNodeValue
    void getNodeValue(java.lang.StringBuffer) -> b
    boolean hasChildNodes() -> hasChildNodes
    java.lang.String getTextContent() -> getTextContent
    void getTextContent(java.lang.StringBuffer) -> a
    org.w3c.dom.Node getParentNode() -> getParentNode
    org.w3c.dom.Node getPreviousSibling() -> getPreviousSibling
    org.w3c.dom.Node getNextSibling() -> getNextSibling
    org.w3c.dom.Node getFirstChild() -> getFirstChild
    org.w3c.dom.Node getLastChild() -> getLastChild
    org.w3c.dom.NodeList getChildNodes() -> getChildNodes
    org.w3c.dom.NodeList getElementsByTagName(java.lang.String) -> getElementsByTagName
    void setNodeValue(java.lang.String) -> setNodeValue
    void setPrefix(java.lang.String) -> setPrefix
    org.w3c.dom.Node insertBefore(org.w3c.dom.Node,org.w3c.dom.Node) -> insertBefore
    org.w3c.dom.Node replaceChild(org.w3c.dom.Node,org.w3c.dom.Node) -> replaceChild
    org.w3c.dom.Node removeChild(org.w3c.dom.Node) -> removeChild
    org.w3c.dom.Node appendChild(org.w3c.dom.Node) -> appendChild
    void setTextContent(java.lang.String) -> setTextContent
    org.w3c.dom.Node cloneNode(boolean) -> cloneNode
    org.w3c.dom.Document getOwnerDocument() -> getOwnerDocument
    org.w3c.dom.NamedNodeMap getAttributes() -> getAttributes
    void normalize() -> normalize
    boolean hasAttributes() -> hasAttributes
    boolean isDefaultNamespace(java.lang.String) -> isDefaultNamespace
    java.lang.String lookupNamespaceURI(java.lang.String) -> lookupNamespaceURI
    java.lang.String lookupPrefix(java.lang.String) -> lookupPrefix
    java.lang.String getBaseURI() -> getBaseURI
    short compareDocumentPosition(org.w3c.dom.Node) -> compareDocumentPosition
    boolean isSameNode(org.w3c.dom.Node) -> isSameNode
    boolean isEqualNode(org.w3c.dom.Node) -> isEqualNode
    java.lang.String toString() -> toString
    java.lang.Object getFeature(java.lang.String,java.lang.String) -> getFeature
    void consume(gnu.lists.Consumer) -> a
    java.lang.Object setUserData(java.lang.String,java.lang.Object,org.w3c.dom.UserDataHandler) -> setUserData
    java.lang.Object getUserData(java.lang.String) -> getUserData
    gnu.lists.SeqPosition copy() -> a
gnu.kawa.xml.KProcessingInstruction -> a.c.f.j:
    short getNodeType() -> getNodeType
    java.lang.String getNodeName() -> getNodeName
    java.lang.String getData() -> getData
    void setData(java.lang.String) -> setData
    java.lang.String getTarget() -> getTarget
gnu.kawa.xml.KText -> a.c.f.k:
    short getNodeType() -> getNodeType
    java.lang.String getNodeName() -> getNodeName
    org.w3c.dom.Text splitText(int) -> splitText
    java.lang.String getWholeText() -> getWholeText
    org.w3c.dom.Text replaceWholeText(java.lang.String) -> replaceWholeText
    boolean hasAttributes() -> hasAttributes
    boolean isElementContentWhitespace() -> isElementContentWhitespace
gnu.kawa.xml.MakeAttribute -> a.c.f.l:
    gnu.kawa.xml.MakeAttribute makeAttribute -> a
    gnu.bytecode.ClassType typeMakeAttribute -> d
    gnu.bytecode.Method startAttributeMethod -> f
    gnu.bytecode.Method endAttributeMethod -> b
    int numArgs() -> e_
    void apply(gnu.mapping.CallContext) -> a
    void compileToNode(gnu.expr.ApplyExp,gnu.expr.Compilation,gnu.expr.ConsumerTarget) -> a
    gnu.bytecode.Type getReturnType(gnu.expr.Expression[]) -> a_
gnu.kawa.xml.MakeCDATA -> a.c.f.m:
    gnu.kawa.xml.MakeCDATA makeCDATA -> a
    void apply(gnu.mapping.CallContext) -> a
gnu.kawa.xml.MakeElement -> a.c.f.n:
    gnu.mapping.Symbol tag -> a
    int copyNamespacesMode -> b
    boolean handlingKeywordParameters -> d
    gnu.xml.NamespaceBinding namespaceNodes -> f
    gnu.bytecode.ClassType typeMakeElement -> g
    gnu.bytecode.Method startElementMethod3 -> h
    gnu.bytecode.Method startElementMethod4 -> i
    gnu.bytecode.Method endElementMethod -> j
    int numArgs() -> e_
    java.lang.String toString() -> toString
    void setHandlingKeywordParameters(boolean) -> a
    void setNamespaceNodes(gnu.xml.NamespaceBinding) -> a
    void apply(gnu.mapping.CallContext) -> a
    void compileToNode(gnu.expr.ApplyExp,gnu.expr.Compilation,gnu.expr.ConsumerTarget) -> a
    gnu.bytecode.Type getReturnType(gnu.expr.Expression[]) -> a_
gnu.kawa.xml.MakeProcInst -> a.c.f.o:
    gnu.kawa.xml.MakeProcInst makeProcInst -> a
    int numArgs() -> e_
    void apply(gnu.mapping.CallContext) -> a
    void compileToNode(gnu.expr.ApplyExp,gnu.expr.Compilation,gnu.expr.ConsumerTarget) -> a
gnu.kawa.xml.MakeText -> a.c.f.p:
    gnu.kawa.xml.MakeText makeText -> a
    int numArgs() -> e_
    java.lang.Object apply1(java.lang.Object) -> a
    void apply(gnu.mapping.CallContext) -> a
    void compile(gnu.expr.ApplyExp,gnu.expr.Compilation,gnu.expr.Target) -> a
    void compileToNode(gnu.expr.ApplyExp,gnu.expr.Compilation,gnu.expr.ConsumerTarget) -> a
gnu.kawa.xml.NodeConstructor -> a.c.f.q:
    gnu.bytecode.ClassType typeXMLFilter -> a
    gnu.bytecode.ClassType typeNodeConstructor -> b
    gnu.bytecode.Method pushNodeContextMethod -> d
    gnu.bytecode.Method popNodeContextMethod -> f
    gnu.bytecode.Method pushNodeConsumerMethod -> g
    gnu.bytecode.Method popNodeConsumerMethod -> h
    void compileToNode(gnu.expr.ApplyExp,gnu.expr.Compilation,gnu.expr.ConsumerTarget) -> a
    gnu.xml.XMLFilter pushNodeContext(gnu.mapping.CallContext) -> c
    void popNodeContext(gnu.lists.Consumer,gnu.mapping.CallContext) -> a
    void compileChild(gnu.expr.Expression,gnu.expr.Compilation,gnu.expr.ConsumerTarget) -> a
    void compile(gnu.expr.ApplyExp,gnu.expr.Compilation,gnu.expr.Target) -> a
    gnu.bytecode.Type getReturnType(gnu.expr.Expression[]) -> a_
gnu.kawa.xml.NodeType -> a.c.f.r:
    int kinds -> a
    gnu.bytecode.ClassType typeKNode -> b
    gnu.bytecode.ClassType typeNodeType -> c
    gnu.bytecode.Method coerceMethod -> d
    gnu.bytecode.Method coerceOrNullMethod -> e
    void emitCoerceFromObject(gnu.bytecode.CodeAttr) -> a
    gnu.expr.Expression convertValue(gnu.expr.Expression) -> a
    java.lang.Object coerceFromObject(java.lang.Object) -> b
    gnu.bytecode.Type getImplementationType() -> b
    int compare(gnu.bytecode.Type) -> b
    boolean isInstance(java.lang.Object) -> a
    boolean isInstancePos(gnu.lists.AbstractSequence,int) -> a
    boolean isInstance(gnu.lists.AbstractSequence,int,int) -> a
    gnu.kawa.xml.KNode coerceOrNull(java.lang.Object,int) -> a
    void emitCoerceOrNullMethod(gnu.bytecode.Variable,gnu.expr.Compilation) -> a
    void emitTestIf(gnu.bytecode.Variable,gnu.expr.Declaration,gnu.expr.Compilation) -> a
    void emitIsInstance(gnu.bytecode.Variable,gnu.expr.Compilation,gnu.expr.Target) -> a
    gnu.mapping.Procedure getConstructor() -> a
    java.lang.String toString() -> toString
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.kawa.xml.Nodes -> a.c.f.s:
    int count -> a
    int nesting -> i
    boolean inAttribute -> j
    gnu.xml.NodeTree curNode -> k
    gnu.xml.XMLFilter curFragment -> l
    void writePosition(gnu.lists.AbstractSequence,int) -> a
    int find(java.lang.Object) -> d
    void writeObject(java.lang.Object) -> c
    void maybeStartTextNode() -> j
    void handleNonNode() -> k
    void writeFloat(float) -> a
    void writeDouble(double) -> a
    void writeLong(long) -> a
    void writeInt(int) -> a
    void writeBoolean(boolean) -> a
    void write(int) -> write
    gnu.lists.Consumer append(java.lang.CharSequence,int,int) -> b
    void write(char[],int,int) -> write
    void write(java.lang.CharSequence,int,int) -> a
    void write(java.lang.String) -> write
    void maybeStartNonTextNode() -> l
    void maybeEndNonTextNode() -> m
    void startElement(java.lang.Object) -> a
    void endElement() -> c
    void startAttribute(java.lang.Object) -> b
    void endAttribute() -> b
    void writeComment(char[],int,int) -> a
    void writeCDATA(char[],int,int) -> b
    void writeProcessingInstruction(java.lang.String,char[],int,int) -> a
    void startDocument() -> startDocument
    void endDocument() -> endDocument
    void beginEntity(java.lang.Object) -> e
    void endEntity() -> a
    void finishFragment() -> n
    int size() -> size
    int getLength() -> getLength
    java.lang.Object get(int) -> get
    org.w3c.dom.Node item(int) -> item
    java.lang.Object getPosNext(int) -> a_
    java.lang.Appendable append(java.lang.CharSequence,int,int) -> append
gnu.kawa.xml.SortedNodes -> a.c.f.t:
    int compareIndex(int,gnu.lists.AbstractSequence,int) -> a
    int find(int,int,gnu.lists.AbstractSequence,int) -> a
    void writePosition(gnu.lists.AbstractSequence,int) -> a
gnu.kawa.xml.UntypedAtomic -> a.c.f.u:
    java.lang.String text -> a
    java.lang.String toString() -> toString
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
gnu.kawa.xml.XmlNamespace -> a.c.f.v:
    gnu.kawa.xml.XmlNamespace HTML -> a
    gnu.xml.NamespaceBinding HTML_BINDINGS -> f
    gnu.kawa.xml.XmlNamespace getInstance(java.lang.String,java.lang.String) -> a
    java.lang.Object get(java.lang.String) -> a
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.lists.AbstractFormat -> a.d.a:
    void write(int,gnu.lists.Consumer) -> a
    void writeBoolean(boolean,gnu.lists.Consumer) -> a
    void startElement(java.lang.Object,gnu.lists.Consumer) -> b
    void endElement(gnu.lists.Consumer) -> a
    void startAttribute(java.lang.Object,gnu.lists.Consumer) -> c
    void endAttribute(gnu.lists.Consumer) -> b
    void writeObject(java.lang.Object,gnu.lists.Consumer) -> a
    void writeObject(java.lang.Object,gnu.lists.PrintConsumer) -> a
    java.lang.StringBuffer format(java.lang.Object,java.lang.StringBuffer,java.text.FieldPosition) -> format
    java.lang.Object parseObject(java.lang.String,java.text.ParsePosition) -> parseObject
gnu.lists.AbstractSequence -> a.d.b:
    int size() -> size
    boolean isEmpty() -> isEmpty
    java.lang.Object get(int) -> get
    int getSize(int) -> c
    java.lang.RuntimeException unsupported(java.lang.String) -> a
    java.lang.Object set(int,java.lang.Object) -> set
    int indexOf(java.lang.Object) -> indexOf
    int lastIndexOf(java.lang.Object) -> lastIndexOf
    boolean contains(java.lang.Object) -> contains
    boolean containsAll(java.util.Collection) -> containsAll
    gnu.lists.SeqPosition getIterator(int) -> d
    gnu.lists.SeqPosition getIteratorAtPos(int) -> e
    java.util.Iterator iterator() -> iterator
    java.util.ListIterator listIterator() -> listIterator
    java.util.ListIterator listIterator(int) -> listIterator
    int addPos(int,java.lang.Object) -> a
    boolean add(java.lang.Object) -> add
    void add(int,java.lang.Object) -> add
    boolean addAll(java.util.Collection) -> addAll
    boolean addAll(int,java.util.Collection) -> addAll
    void removePos(int,int) -> a
    void removePosRange(int,int) -> b
    java.lang.Object remove(int) -> remove
    boolean remove(java.lang.Object) -> remove
    boolean removeAll(java.util.Collection) -> removeAll
    boolean retainAll(java.util.Collection) -> retainAll
    void clear() -> clear
    boolean isAfterPos(int) -> f
    int createPos(int,boolean) -> a
    int createRelativePos(int,int,boolean) -> a
    int startPos() -> e
    int endPos() -> f
    void releasePos(int) -> g
    int copyPos(int) -> h
    int getIndexDifference(int,int) -> c
    int nextIndex(int) -> i
    boolean hasNext(int) -> j
    int getNextKind(int) -> k
    java.lang.String getNextTypeName(int) -> l
    java.lang.Object getNextTypeObject(int) -> m
    boolean hasPrevious(int) -> n
    int nextPos(int) -> o
    int previousPos(int) -> p
    int firstChildPos(int) -> q
    int firstAttributePos(int) -> r
    int parentPos(int) -> s
    java.lang.Object getPosNext(int) -> a_
    java.lang.Object getPosPrevious(int) -> t
    void setPosNext(int,java.lang.Object) -> b
    void setPosPrevious(int,java.lang.Object) -> c
    boolean equals(int,int) -> d
    int compare(int,int) -> e
    java.lang.Object[] toArray() -> toArray
    java.lang.Object[] toArray(java.lang.Object[]) -> toArray
    int stableCompare(gnu.lists.AbstractSequence) -> a
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    gnu.lists.Sequence subSequencePos(int,int) -> f
    java.util.List subList(int,int) -> subList
    boolean consumeNext(int,gnu.lists.Consumer) -> a
    void consumePosRange(int,int,gnu.lists.Consumer) -> a
    void consume(gnu.lists.Consumer) -> a
    void toString(java.lang.String,java.lang.StringBuffer) -> a
    java.lang.String toString() -> toString
gnu.lists.Array -> a.d.c:
    java.lang.Object getRowMajor(int) -> a
    int getSize(int) -> c
gnu.lists.ByteVector -> a.d.d:
    byte[] data -> a
    byte[] empty -> b
    int getBufferLength() -> a
    void setBufferLength(int) -> u
    java.lang.Object getBuffer() -> b
    boolean consumeNext(int,gnu.lists.Consumer) -> a
    void consumePosRange(int,int,gnu.lists.Consumer) -> a
    void clearBuffer(int,int) -> g
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.lists.CharSeq -> a.d.e:
    void getChars(int,int,char[],int) -> a
    void consume(int,int,gnu.lists.Consumer) -> b
gnu.lists.Consumable -> a.d.f:
    void consume(gnu.lists.Consumer) -> a
gnu.lists.Consumer -> a.d.g:
    void writeBoolean(boolean) -> a
    void writeFloat(float) -> a
    void writeDouble(double) -> a
    void writeInt(int) -> a
    void writeLong(long) -> a
    void startDocument() -> startDocument
    void endDocument() -> endDocument
    void startElement(java.lang.Object) -> a
    void endElement() -> c
    void startAttribute(java.lang.Object) -> b
    void endAttribute() -> b
    void writeObject(java.lang.Object) -> c
    boolean ignoring() -> d
    void write(int) -> write
    void write(java.lang.String) -> write
    void write(java.lang.CharSequence,int,int) -> a
    void write(char[],int,int) -> write
gnu.lists.ConsumerWriter -> a.d.h:
    gnu.lists.Consumer out -> a
    void write(char[],int,int) -> write
    void flush() -> flush
    void close() -> close
    void finalize() -> finalize
gnu.lists.Convert -> a.d.i:
    gnu.lists.Convert instance -> a
    void setInstance(gnu.lists.Convert) -> a
    java.lang.Object toObject(boolean) -> a
    java.lang.Object charToObject(char) -> a
    char objectToChar(java.lang.Object) -> a
    java.lang.Object toObject(char) -> b
    char toChar(java.lang.Object) -> b
    java.lang.Object byteToObject(byte) -> a
    java.lang.Object toObject(byte) -> c
    byte toByte(java.lang.Object) -> c
    java.lang.Object byteToObjectUnsigned(byte) -> b
    java.lang.Object toObjectUnsigned(byte) -> d
    byte toByteUnsigned(java.lang.Object) -> d
    java.lang.Object shortToObject(short) -> a
    java.lang.Object toObject(short) -> c
    short toShort(java.lang.Object) -> e
    java.lang.Object shortToObjectUnsigned(short) -> b
    java.lang.Object toObjectUnsigned(short) -> d
    short toShortUnsigned(java.lang.Object) -> f
    java.lang.Object intToObject(int) -> a
    java.lang.Object toObject(int) -> c
    int toInt(java.lang.Object) -> g
    java.lang.Object intToObjectUnsigned(int) -> b
    java.lang.Object toObjectUnsigned(int) -> d
    int toIntUnsigned(java.lang.Object) -> h
    java.lang.Object longToObject(long) -> a
    java.lang.Object toObject(long) -> c
    long toLong(java.lang.Object) -> i
    java.lang.Object longToObjectUnsigned(long) -> b
    java.lang.Object toObjectUnsigned(long) -> d
    long toLongUnsigned(java.lang.Object) -> j
    java.lang.Object floatToObject(float) -> a
    java.lang.Object toObject(float) -> b
    float toFloat(java.lang.Object) -> k
    java.lang.Object doubleToObject(double) -> a
    java.lang.Object toObject(double) -> b
    double toDouble(java.lang.Object) -> l
    double parseDouble(java.lang.String) -> a
gnu.lists.ElementPredicate -> a.d.j:
gnu.lists.EofClass -> a.d.k:
    gnu.lists.EofClass eofValue -> a
    java.lang.String toString() -> toString
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.lists.ExtPosition -> a.d.l:
    int position -> a
    int getPos() -> b
    boolean isAfter() -> c
    void release() -> d
gnu.lists.ExtSequence -> a.d.m:
    int copyPos(int) -> h
    void releasePos(int) -> g
    boolean isAfterPos(int) -> f
    int nextIndex(int) -> i
gnu.lists.F32Vector -> a.d.n:
    float[] data -> a
    float[] empty -> b
    int getBufferLength() -> a
    void setBufferLength(int) -> u
    java.lang.Object getBuffer() -> b
    int intAtBuffer(int) -> v
    java.lang.Object get(int) -> get
    java.lang.Object getBuffer(int) -> w
    java.lang.Object setBuffer(int,java.lang.Object) -> d
    void clearBuffer(int,int) -> g
    int getElementKind() -> c
    java.lang.String getTag() -> d
    boolean consumeNext(int,gnu.lists.Consumer) -> a
    void consumePosRange(int,int,gnu.lists.Consumer) -> a
    int compareTo(java.lang.Object) -> compareTo
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.lists.F64Vector -> a.d.o:
    double[] data -> a
    double[] empty -> b
    int getBufferLength() -> a
    void setBufferLength(int) -> u
    java.lang.Object getBuffer() -> b
    java.lang.Object get(int) -> get
    java.lang.Object getBuffer(int) -> w
    int intAtBuffer(int) -> v
    java.lang.Object setBuffer(int,java.lang.Object) -> d
    void clearBuffer(int,int) -> g
    int getElementKind() -> c
    java.lang.String getTag() -> d
    boolean consumeNext(int,gnu.lists.Consumer) -> a
    void consumePosRange(int,int,gnu.lists.Consumer) -> a
    int compareTo(java.lang.Object) -> compareTo
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.lists.FString -> a.d.p:
    char[] data -> a
    char[] empty -> b
    int length() -> length
    int getBufferLength() -> a
    void setBufferLength(int) -> u
    void ensureBufferLength(int) -> y
    java.lang.Object getBuffer() -> b
    java.lang.Object getBuffer(int) -> w
    java.lang.Object setBuffer(int,java.lang.Object) -> d
    java.lang.Object get(int) -> get
    char charAt(int) -> charAt
    void getChars(int,int,char[],int) -> a
    void shift(int,int,int) -> a
    java.lang.String toString() -> toString
    java.lang.CharSequence subSequence(int,int) -> subSequence
    void clearBuffer(int,int) -> g
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    int compareTo(java.lang.Object) -> compareTo
    int getElementKind() -> c
    void consume(gnu.lists.Consumer) -> a
    boolean consumeNext(int,gnu.lists.Consumer) -> a
    void consumePosRange(int,int,gnu.lists.Consumer) -> a
    gnu.lists.FString append(java.lang.CharSequence,int,int) -> a
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
    java.lang.Appendable append(char) -> append
    java.lang.Appendable append(java.lang.CharSequence,int,int) -> append
    java.lang.Appendable append(java.lang.CharSequence) -> append
gnu.lists.FVector -> a.d.q:
    java.lang.Object[] data -> a
    java.lang.Object[] empty -> b
    int getBufferLength() -> a
    void setBufferLength(int) -> u
    java.lang.Object getBuffer() -> b
    void shift(int,int,int) -> a
    java.lang.Object getBuffer(int) -> w
    java.lang.Object get(int) -> get
    java.lang.Object setBuffer(int,java.lang.Object) -> d
    void clearBuffer(int,int) -> g
    boolean equals(java.lang.Object) -> equals
    int compareTo(java.lang.Object) -> compareTo
    boolean consumeNext(int,gnu.lists.Consumer) -> a
    void consumePosRange(int,int,gnu.lists.Consumer) -> a
    void consume(gnu.lists.Consumer) -> a
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.lists.FilterConsumer -> a.d.r:
    gnu.lists.Consumer base -> b
    boolean skipping -> a
    void write(int) -> write
    void writeBoolean(boolean) -> a
    void writeFloat(float) -> a
    void writeDouble(double) -> a
    void writeInt(int) -> a
    void writeLong(long) -> a
    void startDocument() -> startDocument
    void endDocument() -> endDocument
    void startElement(java.lang.Object) -> a
    void endElement() -> c
    void startAttribute(java.lang.Object) -> b
    void endAttribute() -> b
    void writeComment(char[],int,int) -> a
    void writeProcessingInstruction(java.lang.String,char[],int,int) -> a
    void writeCDATA(char[],int,int) -> b
    void beginEntity(java.lang.Object) -> e
    void endEntity() -> a
    void writeObject(java.lang.Object) -> c
    boolean ignoring() -> d
    void write(char[],int,int) -> write
    void write(java.lang.String) -> write
    void write(java.lang.CharSequence,int,int) -> a
    gnu.lists.Consumer append(java.lang.CharSequence) -> a
    gnu.lists.Consumer append(java.lang.CharSequence,int,int) -> b
    java.lang.Appendable append(char) -> append
    java.lang.Appendable append(java.lang.CharSequence,int,int) -> append
    java.lang.Appendable append(java.lang.CharSequence) -> append
gnu.lists.ImmutablePair -> a.d.s:
    void setCdr(java.lang.Object) -> a
gnu.lists.ItemPredicate -> a.d.t:
    boolean isInstancePos(gnu.lists.AbstractSequence,int) -> a
gnu.lists.LList -> a.d.u:
    gnu.lists.LList Empty -> a
    int listLength(java.lang.Object,boolean) -> a
    boolean equals(java.lang.Object) -> equals
    int compareTo(java.lang.Object) -> compareTo
    int size() -> size
    boolean isEmpty() -> isEmpty
    gnu.lists.SeqPosition getIterator(int) -> d
    int createPos(int,boolean) -> a
    int createRelativePos(int,int,boolean) -> a
    boolean hasNext(int) -> j
    int nextPos(int) -> o
    java.lang.Object getPosNext(int) -> a_
    java.lang.Object getPosPrevious(int) -> t
    void setPosNext(int,java.lang.Object) -> b
    void setPosPrevious(int,java.lang.Object) -> c
    java.lang.Object get(int) -> get
    gnu.lists.LList makeList(java.util.List) -> b
    gnu.lists.LList makeList(java.lang.Object[],int) -> a
    void consume(gnu.lists.Consumer) -> a
    void readExternal(java.io.ObjectInput) -> readExternal
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    gnu.lists.Pair list2(java.lang.Object,java.lang.Object) -> a
    gnu.lists.Pair list3(java.lang.Object,java.lang.Object,java.lang.Object) -> a
    gnu.lists.LList reverseInPlace(java.lang.Object) -> b
    java.lang.String toString() -> toString
    java.lang.Object checkNonList(java.lang.Object) -> c
gnu.lists.LListPosition -> a.d.v:
    java.lang.Object xpos -> b
    gnu.lists.SeqPosition copy() -> a
    void set(gnu.lists.LList,int,boolean) -> a
    boolean hasNext() -> hasNext
    boolean hasPrevious() -> hasPrevious
    gnu.lists.Pair getNextPair() -> j
    java.lang.Object getNext() -> e
    void setNext(java.lang.Object) -> a_
    gnu.lists.Pair getPreviousPair() -> k
    java.lang.Object getPrevious() -> f
    void setPrevious(java.lang.Object) -> b
    int nextIndex() -> nextIndex
    boolean gotoNext() -> g
    boolean gotoPrevious() -> h
    java.lang.String toString() -> toString
gnu.lists.Pair -> a.d.w:
    java.lang.Object car -> b
    java.lang.Object cdr -> c
    java.lang.Object getCar() -> b
    java.lang.Object getCdr() -> c
    void setCdr(java.lang.Object) -> a
    void setCdrBackdoor(java.lang.Object) -> d
    int size() -> size
    boolean isEmpty() -> isEmpty
    boolean hasNext(int) -> j
    int nextPos(int) -> o
    java.lang.Object getPosNext(int) -> a_
    java.lang.Object getPosPrevious(int) -> t
    gnu.lists.Pair lastPair() -> j_
    int hashCode() -> hashCode
    int compareTo(java.lang.Object) -> compareTo
    java.lang.Object get(int) -> get
    boolean equals(java.lang.Object) -> equals
    gnu.lists.Pair make(java.lang.Object,java.lang.Object) -> b
    java.lang.Object[] toArray() -> toArray
    java.lang.Object[] toArray(java.lang.Object[]) -> toArray
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.lists.PairWithPosition -> a.d.x:
    java.lang.String filename -> e
    int position -> f
    void setLine(int,int) -> g
    java.lang.String getFileName() -> r
    java.lang.String getPublicId() -> getPublicId
    java.lang.String getSystemId() -> getSystemId
    int getLineNumber() -> getLineNumber
    int getColumnNumber() -> getColumnNumber
    gnu.lists.PairWithPosition make(java.lang.Object,java.lang.Object,java.lang.String,int,int) -> a
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.lists.PositionConsumer -> a.d.y:
    void consume(gnu.lists.SeqPosition) -> a
    void writePosition(gnu.lists.AbstractSequence,int) -> a
gnu.lists.PositionManager -> a.d.z:
    gnu.lists.PositionManager manager -> a
    gnu.lists.SeqPosition[] positions -> b
    int[] ivals -> c
    int freeListHead -> d
    gnu.lists.SeqPosition getPositionObject(int) -> a
    void addToFreeList(int[],int,int) -> a
    int register(gnu.lists.SeqPosition) -> a
    void release(int) -> b
gnu.lists.PrintConsumer -> a.d.A:
    void startNumber() -> e
    void endNumber() -> f
    gnu.lists.PrintConsumer append(java.lang.CharSequence) -> a
    gnu.lists.PrintConsumer append(java.lang.CharSequence,int,int) -> b
    void write(java.lang.CharSequence,int,int) -> a
    void writeBoolean(boolean) -> a
    void writeFloat(float) -> a
    void writeDouble(double) -> a
    void writeInt(int) -> a
    void writeLong(long) -> a
    void startDocument() -> startDocument
    void endDocument() -> endDocument
    void startElement(java.lang.Object) -> a
    void endElement() -> c
    void startAttribute(java.lang.Object) -> b
    void endAttribute() -> b
    void writeObject(java.lang.Object) -> c
    boolean ignoring() -> d
    java.io.PrintWriter append(char) -> append
    java.io.PrintWriter append(java.lang.CharSequence,int,int) -> append
    java.io.PrintWriter append(java.lang.CharSequence) -> append
    java.io.Writer append(char) -> append
    java.io.Writer append(java.lang.CharSequence,int,int) -> append
    java.io.Writer append(java.lang.CharSequence) -> append
    java.lang.Appendable append(char) -> append
    java.lang.Appendable append(java.lang.CharSequence,int,int) -> append
    java.lang.Appendable append(java.lang.CharSequence) -> append
gnu.lists.S16Vector -> a.d.B:
    short[] data -> b
    short[] empty -> a
    int getBufferLength() -> a
    void setBufferLength(int) -> u
    java.lang.Object getBuffer() -> b
    int intAtBuffer(int) -> v
    java.lang.Object get(int) -> get
    java.lang.Object getBuffer(int) -> w
    java.lang.Object setBuffer(int,java.lang.Object) -> d
    void clearBuffer(int,int) -> g
    int getElementKind() -> c
    java.lang.String getTag() -> d
    boolean consumeNext(int,gnu.lists.Consumer) -> a
    void consumePosRange(int,int,gnu.lists.Consumer) -> a
    int compareTo(java.lang.Object) -> compareTo
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.lists.S32Vector -> a.d.C:
    int[] data -> b
    int[] empty -> a
    int getBufferLength() -> a
    void setBufferLength(int) -> u
    java.lang.Object getBuffer() -> b
    int intAtBuffer(int) -> v
    java.lang.Object get(int) -> get
    java.lang.Object getBuffer(int) -> w
    java.lang.Object setBuffer(int,java.lang.Object) -> d
    void clearBuffer(int,int) -> g
    int getElementKind() -> c
    java.lang.String getTag() -> d
    boolean consumeNext(int,gnu.lists.Consumer) -> a
    void consumePosRange(int,int,gnu.lists.Consumer) -> a
    int compareTo(java.lang.Object) -> compareTo
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.lists.S64Vector -> a.d.D:
    long[] data -> b
    long[] empty -> a
    int getBufferLength() -> a
    void setBufferLength(int) -> u
    java.lang.Object getBuffer() -> b
    long longAtBuffer(int) -> x
    java.lang.Object get(int) -> get
    java.lang.Object getBuffer(int) -> w
    int intAtBuffer(int) -> v
    java.lang.Object setBuffer(int,java.lang.Object) -> d
    void clearBuffer(int,int) -> g
    int getElementKind() -> c
    java.lang.String getTag() -> d
    boolean consumeNext(int,gnu.lists.Consumer) -> a
    void consumePosRange(int,int,gnu.lists.Consumer) -> a
    int compareTo(java.lang.Object) -> compareTo
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.lists.S8Vector -> a.d.E:
    int intAtBuffer(int) -> v
    java.lang.Object get(int) -> get
    java.lang.Object getBuffer(int) -> w
    java.lang.Object setBuffer(int,java.lang.Object) -> d
    int getElementKind() -> c
    java.lang.String getTag() -> d
    int compareTo(java.lang.Object) -> compareTo
gnu.lists.SeqPosition -> a.d.F:
    gnu.lists.AbstractSequence sequence -> c
    int ipos -> d
    gnu.lists.SeqPosition copy() -> a
    boolean hasMoreElements() -> hasMoreElements
    boolean hasNext() -> hasNext
    java.lang.Object getNextTypeObject() -> i
    boolean hasPrevious() -> hasPrevious
    java.lang.Object next() -> next
    boolean gotoNext() -> g
    boolean gotoPrevious() -> h
    java.lang.Object previous() -> previous
    java.lang.Object nextElement() -> nextElement
    java.lang.Object getNext() -> e
    java.lang.Object getPrevious() -> f
    int nextIndex() -> nextIndex
    int previousIndex() -> previousIndex
    boolean isAfter() -> c
    void set(java.lang.Object) -> set
    void setNext(java.lang.Object) -> a_
    void setPrevious(java.lang.Object) -> b
    void remove() -> remove
    void add(java.lang.Object) -> add
    int getPos() -> b
    void release() -> d
    void finalize() -> finalize
    java.lang.String toString() -> toString
gnu.lists.Sequence -> a.d.G:
    java.lang.Object eofValue -> b_
    int size() -> size
    java.lang.Object get(int) -> get
gnu.lists.SimpleVector -> a.d.H:
    int size -> c
    int size() -> size
    void setSize(int) -> y
    int getBufferLength() -> a
    void setBufferLength(int) -> u
    boolean isAfterPos(int) -> f
    int nextIndex(int) -> i
    int createPos(int,boolean) -> a
    int nextPos(int) -> o
    java.lang.Object getBuffer() -> b
    java.lang.Object get(int) -> get
    java.lang.Object getPosNext(int) -> a_
    int intAtBuffer(int) -> v
    long longAtBuffer(int) -> x
    java.lang.Object getRowMajor(int) -> a
    java.lang.Object getBuffer(int) -> w
    java.lang.Object set(int,java.lang.Object) -> set
    java.lang.Object setBuffer(int,java.lang.Object) -> d
    void shift(int,int,int) -> a
    boolean add(java.lang.Object) -> add
    int addPos(int,java.lang.Object) -> a
    void add(int,java.lang.Object) -> add
    boolean addAll(int,java.util.Collection) -> addAll
    void clearBuffer(int,int) -> g
    void removePosRange(int,int) -> b
    void removePos(int,int) -> a
    java.lang.Object remove(int) -> remove
    boolean remove(java.lang.Object) -> remove
    boolean removeAll(java.util.Collection) -> removeAll
    boolean retainAll(java.util.Collection) -> retainAll
    void clear() -> clear
    java.lang.String getTag() -> d
    int compareToInt(gnu.lists.SimpleVector,gnu.lists.SimpleVector) -> a
    int compareToLong(gnu.lists.SimpleVector,gnu.lists.SimpleVector) -> b
    void consume(int,int,gnu.lists.Consumer) -> b
    boolean consumeNext(int,gnu.lists.Consumer) -> a
    void consumePosRange(int,int,gnu.lists.Consumer) -> a
    int getNextKind(int) -> k
    int getElementKind() -> c
gnu.lists.SubSequence -> a.d.I:
    gnu.lists.AbstractSequence base -> a
    int ipos0 -> b
    int ipos1 -> c
    java.lang.Object get(int) -> get
    int size() -> size
    void removePosRange(int,int) -> b
    boolean isAfterPos(int) -> f
    int createPos(int,boolean) -> a
    int createRelativePos(int,int,boolean) -> a
    int getIndexDifference(int,int) -> c
    void releasePos(int) -> g
    int nextIndex(int) -> i
    int compare(int,int) -> e
    java.lang.Object getPosNext(int) -> a_
    int getNextKind(int) -> k
    int startPos() -> e
    int endPos() -> f
    java.lang.Object getPosPrevious(int) -> t
    gnu.lists.Sequence subSequencePos(int,int) -> f
    void clear() -> clear
    void finalize() -> finalize
gnu.lists.TreeList -> a.d.J:
    java.lang.Object[] objects -> b
    int oindex -> c
    char[] data -> d
    int gapStart -> e
    int gapEnd -> f
    int attrStart -> a
    int docStart -> g
    int currentParent -> h
    void clear() -> clear
    void ensureSpace(int) -> u
    void resizeObjects() -> h
    int find(java.lang.Object) -> d
    int getIntN(int) -> v
    long getLongN(int) -> E
    void setIntN(int,int) -> g
    void consume(gnu.lists.SeqPosition) -> a
    void writePosition(gnu.lists.AbstractSequence,int) -> a
    void writeObject(java.lang.Object) -> c
    void writeComment(char[],int,int) -> a
    void writeProcessingInstruction(java.lang.String,char[],int,int) -> a
    void startElement(java.lang.Object) -> a
    void startDocument() -> startDocument
    void endDocument() -> endDocument
    void beginEntity(java.lang.Object) -> e
    void endEntity() -> a
    void startElement(int) -> w
    void setElementName(int,int) -> h
    void endElement() -> c
    void startAttribute(java.lang.Object) -> b
    void startAttribute(int) -> x
    void endAttribute() -> b
    void write(int) -> write
    void writeBoolean(boolean) -> a
    void writeInt(int) -> a
    void writeLong(long) -> a
    void writeFloat(float) -> a
    void writeDouble(double) -> a
    boolean ignoring() -> d
    void writeJoiner() -> g
    void write(char[],int,int) -> write
    void write(java.lang.String) -> write
    void write(java.lang.CharSequence,int,int) -> a
    void writeCDATA(char[],int,int) -> b
    gnu.lists.Consumer append(java.lang.CharSequence,int,int) -> b
    boolean isEmpty() -> isEmpty
    int size() -> size
    int createPos(int,boolean) -> a
    int posToDataIndex(int) -> y
    int firstChildPos(int) -> q
    int gotoChildrenStart(int) -> z
    int parentPos(int) -> s
    int parentOrEntityI(int) -> A
    int firstAttributePos(int) -> r
    int gotoAttributesStart(int) -> B
    java.lang.Object get(int) -> get
    boolean consumeNext(int,gnu.lists.Consumer) -> a
    void consumePosRange(int,int,gnu.lists.Consumer) -> a
    int consumeIRange(int,int,gnu.lists.Consumer) -> b
    void toString(java.lang.String,java.lang.StringBuffer) -> a
    boolean hasNext(int) -> j
    int getNextKind(int) -> k
    int getNextKindI(int) -> C
    java.lang.Object getNextTypeObject(int) -> m
    java.lang.String getNextTypeName(int) -> l
    java.lang.Object getPosPrevious(int) -> t
    java.lang.Object copyToList(int,int) -> j
    java.lang.Object getPosNext(int) -> a_
    void stringValue(int,int,java.lang.StringBuffer) -> a
    int stringValue(int,java.lang.StringBuffer) -> a
    int stringValue(boolean,int,java.lang.StringBuffer) -> a
    int createRelativePos(int,int,boolean) -> a
    int nextNodeIndex(int,int) -> i
    int nextPos(int) -> o
    int nextDataIndex(int) -> D
    int compare(int,int) -> e
    int getIndexDifference(int,int) -> c
    int hashCode() -> hashCode
    void consume(gnu.lists.Consumer) -> a
    java.lang.Appendable append(char) -> append
    java.lang.Appendable append(java.lang.CharSequence,int,int) -> append
    java.lang.Appendable append(java.lang.CharSequence) -> append
gnu.lists.U16Vector -> a.d.K:
    short[] data -> a
    int getBufferLength() -> a
    void setBufferLength(int) -> u
    java.lang.Object getBuffer() -> b
    int intAtBuffer(int) -> v
    java.lang.Object get(int) -> get
    java.lang.Object getBuffer(int) -> w
    java.lang.Object setBuffer(int,java.lang.Object) -> d
    void clearBuffer(int,int) -> g
    int getElementKind() -> c
    java.lang.String getTag() -> d
    boolean consumeNext(int,gnu.lists.Consumer) -> a
    void consumePosRange(int,int,gnu.lists.Consumer) -> a
    int compareTo(java.lang.Object) -> compareTo
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.lists.U32Vector -> a.d.L:
    int[] data -> a
    int getBufferLength() -> a
    void setBufferLength(int) -> u
    java.lang.Object getBuffer() -> b
    int intAtBuffer(int) -> v
    long longAtBuffer(int) -> x
    java.lang.Object get(int) -> get
    java.lang.Object getBuffer(int) -> w
    java.lang.Object setBuffer(int,java.lang.Object) -> d
    void clearBuffer(int,int) -> g
    int getElementKind() -> c
    java.lang.String getTag() -> d
    boolean consumeNext(int,gnu.lists.Consumer) -> a
    void consumePosRange(int,int,gnu.lists.Consumer) -> a
    int compareTo(java.lang.Object) -> compareTo
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.lists.U64Vector -> a.d.M:
    long[] data -> a
    int getBufferLength() -> a
    void setBufferLength(int) -> u
    java.lang.Object getBuffer() -> b
    int intAtBuffer(int) -> v
    long longAtBuffer(int) -> x
    java.lang.Object get(int) -> get
    java.lang.Object getBuffer(int) -> w
    java.lang.Object setBuffer(int,java.lang.Object) -> d
    void clearBuffer(int,int) -> g
    int getElementKind() -> c
    java.lang.String getTag() -> d
    boolean consumeNext(int,gnu.lists.Consumer) -> a
    void consumePosRange(int,int,gnu.lists.Consumer) -> a
    int compareTo(java.lang.Object) -> compareTo
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.lists.U8Vector -> a.d.N:
    int intAtBuffer(int) -> v
    java.lang.Object get(int) -> get
    java.lang.Object getBuffer(int) -> w
    java.lang.Object setBuffer(int,java.lang.Object) -> d
    int getElementKind() -> c
    java.lang.String getTag() -> d
    int compareTo(java.lang.Object) -> compareTo
gnu.lists.UnescapedData -> a.d.O:
    java.lang.String data -> a
    java.lang.String getData() -> a
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    int length() -> length
    char charAt(int) -> charAt
    java.lang.CharSequence subSequence(int,int) -> subSequence
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.lists.VoidConsumer -> a.d.P:
    gnu.lists.VoidConsumer instance -> b
    gnu.lists.VoidConsumer getInstance() -> e
    boolean ignoring() -> d
gnu.lists.XConsumer -> a.d.Q:
    void writeComment(char[],int,int) -> a
    void writeProcessingInstruction(java.lang.String,char[],int,int) -> a
    void writeCDATA(char[],int,int) -> b
    void beginEntity(java.lang.Object) -> e
    void endEntity() -> a
gnu.mapping.CallContext -> a.e.a:
    java.lang.ThreadLocal currentContext -> m
    gnu.mapping.Procedure proc -> a
    int pc -> b
    gnu.mapping.ValueStack vstack -> n
    gnu.lists.Consumer consumer -> c
    java.lang.Object value1 -> d
    java.lang.Object value2 -> e
    java.lang.Object value3 -> f
    java.lang.Object value4 -> g
    java.lang.Object[] values -> h
    int count -> i
    int next -> j
    int where -> k
    java.lang.Object[][] evalFrames -> l
    gnu.mapping.CallContext getInstance() -> a
    java.lang.Object getArgAsObject(int) -> c
    java.lang.Object getNextArg() -> b
    java.lang.Object getNextArg(java.lang.Object) -> a
    java.lang.Object[] getArgs() -> c
    void runUntilDone() -> d
    int startFromContext() -> e
    java.lang.Object getFromContext(int) -> a
    void cleanupFromContext(int) -> b
    java.lang.Object runUntilValue() -> f
    void writeValue(java.lang.Object) -> b
gnu.mapping.CharArrayInPort -> a.e.b:
    gnu.text.Path stringPath -> a
    int read() -> read
gnu.mapping.CharArrayOutPort -> a.e.c:
    char[] toCharArray() -> a
    void close() -> close
    boolean closeOnExit() -> g
    java.lang.String toString() -> toString
    void writeTo(gnu.lists.Consumer) -> b
gnu.mapping.Entry -> a.e.d:
    gnu.mapping.Entry chain -> a
    java.lang.Object value -> b
    java.lang.Object key1 -> c
    java.lang.Object key2 -> d
gnu.mapping.Environment -> a.e.e:
    gnu.mapping.Environment global -> b
    int flags -> a
    gnu.mapping.Environment$InheritedLocal curEnvironment -> c
    void setGlobal(gnu.mapping.Environment) -> a
    void setLocked() -> f
    gnu.mapping.Location getLocation(gnu.mapping.Symbol,java.lang.Object) -> a
    gnu.mapping.Location getLocation(gnu.mapping.Symbol) -> a
    gnu.mapping.Location lookup(gnu.mapping.Symbol,java.lang.Object) -> b
    gnu.mapping.NamedLocation lookup(gnu.mapping.Symbol,java.lang.Object,int) -> a
    gnu.mapping.NamedLocation getLocation(gnu.mapping.Symbol,java.lang.Object,int,boolean) -> a
    gnu.mapping.NamedLocation getLocation(gnu.mapping.Symbol,java.lang.Object,boolean) -> a
    boolean isBound(gnu.mapping.Symbol,java.lang.Object) -> c
    java.lang.Object get(gnu.mapping.Symbol,java.lang.Object,java.lang.Object) -> b
    java.lang.Object get(gnu.mapping.EnvironmentKey,java.lang.Object) -> a
    java.lang.Object get(java.lang.String,java.lang.Object) -> a
    java.lang.Object get(gnu.mapping.Symbol) -> b
    java.lang.Object getFunction(gnu.mapping.Symbol,java.lang.Object) -> d
    java.lang.Object get(java.lang.Object) -> a
    void put(gnu.mapping.Symbol,java.lang.Object,java.lang.Object) -> c
    void define(gnu.mapping.Symbol,java.lang.Object,java.lang.Object) -> a
    java.lang.Object put(java.lang.String,java.lang.Object) -> b
    gnu.mapping.Namespace defaultNamespace() -> g
    gnu.mapping.Symbol getSymbol(java.lang.String) -> a
    gnu.mapping.LocationEnumeration enumerateLocations() -> d
    gnu.mapping.LocationEnumeration enumerateAllLocations() -> e
    gnu.mapping.Environment getCurrent() -> h
    gnu.mapping.Environment setSaveCurrent(gnu.mapping.Environment) -> b
    void restoreCurrent(gnu.mapping.Environment) -> c
    gnu.mapping.Environment user() -> i
    gnu.mapping.NamedLocation addLocation(gnu.mapping.Symbol,java.lang.Object,gnu.mapping.Location) -> a
    gnu.mapping.SimpleEnvironment make() -> j
    gnu.mapping.SimpleEnvironment make(java.lang.String) -> b
    gnu.mapping.InheritingEnvironment make(java.lang.String,gnu.mapping.Environment) -> a
    java.lang.String toString() -> toString
    gnu.mapping.SimpleEnvironment cloneForThread() -> k
gnu.mapping.Environment$InheritedLocal -> a.e.f:
    java.lang.Object childValue(java.lang.Object) -> childValue
gnu.mapping.EnvironmentKey -> a.e.g:
    java.lang.Object FUNCTION -> b
    gnu.mapping.Symbol getKeySymbol() -> b
    java.lang.Object getKeyProperty() -> d
gnu.mapping.HasNamedParts -> a.e.h:
    java.lang.Object get(java.lang.String) -> a
gnu.mapping.InPort -> a.e.i:
    gnu.mapping.InPort systemInPort -> a
    gnu.mapping.ThreadLocation inLocation -> g
    java.io.Reader convertToReader(java.io.InputStream,java.lang.Object) -> a
    gnu.mapping.InPort inDefault() -> a
    gnu.mapping.InPort openFile(java.lang.Object) -> a
    void print(gnu.lists.Consumer) -> a_
gnu.mapping.IndirectableLocation -> a.e.j:
    java.lang.Object DIRECT_ON_SET -> a
    java.lang.Object INDIRECT_FLUIDS -> a_
    gnu.mapping.Location base -> c
    java.lang.Object value -> d
    gnu.mapping.Symbol getKeySymbol() -> b
    java.lang.Object getKeyProperty() -> d
    boolean isConstant() -> f
    gnu.mapping.Location getBase() -> e
    void setBase(gnu.mapping.Location) -> a
    gnu.mapping.Environment getEnvironment() -> h
gnu.mapping.InheritingEnvironment -> a.e.k:
    int numInherited -> b
    gnu.mapping.Environment[] inherited -> c
    int baseTimestamp -> h
    gnu.mapping.NamedLocation lookupInherited(gnu.mapping.Symbol,java.lang.Object,int) -> d
    gnu.mapping.NamedLocation lookup(gnu.mapping.Symbol,java.lang.Object,int) -> a
    gnu.mapping.NamedLocation getLocation(gnu.mapping.Symbol,java.lang.Object,int,boolean) -> a
    gnu.mapping.LocationEnumeration enumerateAllLocations() -> e
    boolean hasMoreElements(gnu.mapping.LocationEnumeration) -> a
gnu.mapping.LazyPropertyKey -> a.e.l:
    java.lang.Object get(gnu.mapping.PropertySet,java.lang.Object) -> a
gnu.mapping.Location -> a.e.m:
    java.lang.String UNBOUND -> f
    gnu.mapping.Symbol getKeySymbol() -> b
    java.lang.Object getKeyProperty() -> d
    java.lang.String toString() -> toString
    java.lang.Object get(java.lang.Object) -> a
    java.lang.Object get() -> k
    void set(java.lang.Object) -> b
    boolean isBound() -> g
    boolean isConstant() -> f
    gnu.mapping.Location getBase() -> e
    java.lang.Object getValue() -> getValue
    java.lang.Object setValue(java.lang.Object) -> setValue
    gnu.mapping.IndirectableLocation make(gnu.mapping.Symbol) -> a
gnu.mapping.LocationEnumeration -> a.e.n:
    gnu.mapping.SimpleEnvironment env -> a
    gnu.mapping.NamedLocation prevLoc -> b
    gnu.mapping.NamedLocation nextLoc -> c
    int index -> d
    gnu.mapping.LocationEnumeration inherited -> e
    gnu.mapping.NamedLocation[] bindings -> f
    boolean hasMoreElements() -> hasMoreElements
    gnu.mapping.Location nextLocation() -> a
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
    java.lang.Object nextElement() -> nextElement
gnu.mapping.LogWriter -> a.e.o:
    void write(int) -> write
    void echo(char[],int,int) -> a
    void write(char[],int,int) -> write
    void write(java.lang.String,int,int) -> write
    void flush() -> flush
    void close() -> close
gnu.mapping.MethodProc -> a.e.p:
    java.lang.Object argTypes -> c
    gnu.bytecode.Type[] unknownArgTypes -> a
    int isApplicable(gnu.bytecode.Type[]) -> a
    int numParameters() -> e
    void resolveParameterTypes() -> d
    gnu.bytecode.Type getParameterType(int) -> a
    java.lang.RuntimeException matchFailAsException(int,gnu.mapping.Procedure,java.lang.Object[]) -> a
    java.lang.Object applyN(java.lang.Object[]) -> a
    gnu.mapping.MethodProc mostSpecific(gnu.mapping.MethodProc,gnu.mapping.MethodProc) -> a
    int mostSpecific(gnu.mapping.MethodProc[],int) -> a
gnu.mapping.Named -> a.e.q:
    java.lang.String getName() -> a
    java.lang.Object getSymbol() -> c
gnu.mapping.NamedLocation -> a.e.r:
    gnu.mapping.NamedLocation next -> e
    gnu.mapping.Symbol name -> g
    java.lang.Object property -> h
    gnu.mapping.Environment getEnvironment() -> h
    gnu.mapping.Symbol getKeySymbol() -> b
    java.lang.Object getKeyProperty() -> d
    boolean matches(gnu.mapping.Symbol,java.lang.Object) -> a
    java.lang.Object getKey() -> getKey
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
gnu.mapping.Namespace -> a.e.s:
    java.util.Hashtable nsTable -> b
    gnu.mapping.Namespace EmptyNamespace -> c
    java.lang.String name -> d
    java.lang.String prefix -> e
    gnu.mapping.SymbolRef[] table -> a
    int log2Size -> f
    int mask -> g
    int num_bindings -> h
    java.lang.String getName() -> b
    void setName(java.lang.String) -> b
    gnu.mapping.Namespace create() -> c
    gnu.mapping.Namespace getDefault() -> d
    gnu.mapping.Symbol getDefaultSymbol(java.lang.String) -> c
    gnu.mapping.Namespace valueOf(java.lang.String) -> d
    gnu.mapping.Namespace valueOf(java.lang.String,java.lang.String) -> b
    java.lang.Object get(java.lang.String) -> a
    gnu.mapping.Symbol getSymbol(java.lang.String) -> e
    gnu.mapping.Symbol lookup(java.lang.String) -> f
    gnu.mapping.Symbol add(gnu.mapping.Symbol,int) -> a
    gnu.mapping.Symbol lookup(java.lang.String,int,boolean) -> a
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
    java.lang.String toString() -> toString
gnu.mapping.OutPort -> a.e.t:
    gnu.text.Path path -> d
    java.io.Writer base -> e
    gnu.text.PrettyWriter bout -> a
    java.lang.Object unregisterRef -> f
    gnu.mapping.OutPort outInitial -> b
    gnu.mapping.OutPort errInitial -> g
    gnu.mapping.ThreadLocation outLocation -> h
    gnu.mapping.ThreadLocation errLocation -> i
    gnu.lists.AbstractFormat objectFormat -> c
    gnu.mapping.OutPort outDefault() -> h
    gnu.mapping.OutPort errDefault() -> i
    void echo(char[],int,int) -> c
    void print(int) -> print
    void print(long) -> print
    void print(double) -> print
    void print(float) -> print
    void print(boolean) -> print
    void print(java.lang.String) -> print
    void print(java.lang.Object) -> print
    void print(gnu.lists.Consumer) -> a_
    void startElement(java.lang.Object) -> a
    void endElement() -> c
    void startAttribute(java.lang.Object) -> b
    void endAttribute() -> b
    void writeWordEnd() -> j
    void writeWordStart() -> k
    void freshLine() -> l
    void clearBuffer() -> m
    void closeThis() -> n
    void close() -> close
    boolean closeOnExit() -> g
    void startLogicalBlock(java.lang.String,boolean,java.lang.String) -> a
    void startLogicalBlock(java.lang.String,java.lang.String,int) -> a
    void endLogicalBlock(java.lang.String) -> a
    void writeBreak(int) -> b
    void writeSpaceLinear() -> o
    void writeBreakLinear() -> p
    void writeSpaceFill() -> q
    void writeBreakFill() -> r
    void setIndentation(int,boolean) -> a
gnu.mapping.PlainLocation -> a.e.u:
    java.lang.Object get(java.lang.Object) -> a
    boolean isBound() -> g
    void set(java.lang.Object) -> b
gnu.mapping.Procedure -> a.e.v:
    gnu.mapping.Symbol validateApplyKey -> J
    gnu.mapping.LazyPropertyKey compilerKey -> K
    void setSourceLocation(java.lang.String,int) -> a
    java.lang.Object applyN(java.lang.Object[]) -> a
    java.lang.Object apply0() -> j
    java.lang.Object apply1(java.lang.Object) -> a
    java.lang.Object apply2(java.lang.Object,java.lang.Object) -> c
    java.lang.Object apply3(java.lang.Object,java.lang.Object,java.lang.Object) -> a
    java.lang.Object apply4(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> a
    int numArgs() -> e_
    void checkArgCount(gnu.mapping.Procedure,int) -> a
    void apply(gnu.mapping.CallContext) -> a
    int match0(gnu.mapping.CallContext) -> b
    int match1(java.lang.Object,gnu.mapping.CallContext) -> a
    int match2(java.lang.Object,java.lang.Object,gnu.mapping.CallContext) -> a
    int match3(java.lang.Object,java.lang.Object,java.lang.Object,gnu.mapping.CallContext) -> a
    int match4(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,gnu.mapping.CallContext) -> a
    int matchN(java.lang.Object[],gnu.mapping.CallContext) -> a
    void checkN(java.lang.Object[],gnu.mapping.CallContext) -> b
    boolean isSideEffectFree() -> g
    gnu.bytecode.Type getReturnType(gnu.expr.Expression[]) -> a_
    java.lang.String toString() -> toString
gnu.mapping.Procedure0 -> a.e.w:
    int numArgs() -> e_
    java.lang.Object apply0() -> j
    java.lang.Object apply1(java.lang.Object) -> a
    java.lang.Object apply2(java.lang.Object,java.lang.Object) -> c
    java.lang.Object apply3(java.lang.Object,java.lang.Object,java.lang.Object) -> a
    java.lang.Object apply4(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> a
    java.lang.Object applyN(java.lang.Object[]) -> a
gnu.mapping.Procedure0or1 -> a.e.x:
    int numArgs() -> e_
    java.lang.Object apply0() -> j
    java.lang.Object apply1(java.lang.Object) -> a
    java.lang.Object apply2(java.lang.Object,java.lang.Object) -> c
    java.lang.Object apply3(java.lang.Object,java.lang.Object,java.lang.Object) -> a
    java.lang.Object apply4(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> a
    java.lang.Object applyN(java.lang.Object[]) -> a
gnu.mapping.Procedure1 -> a.e.y:
    int numArgs() -> e_
    java.lang.Object apply0() -> j
    java.lang.Object apply1(java.lang.Object) -> a
    java.lang.Object apply2(java.lang.Object,java.lang.Object) -> c
    java.lang.Object apply3(java.lang.Object,java.lang.Object,java.lang.Object) -> a
    java.lang.Object apply4(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> a
    java.lang.Object applyN(java.lang.Object[]) -> a
gnu.mapping.Procedure2 -> a.e.z:
    int numArgs() -> e_
    java.lang.Object apply0() -> j
    java.lang.Object apply1(java.lang.Object) -> a
    java.lang.Object apply2(java.lang.Object,java.lang.Object) -> c
    java.lang.Object apply3(java.lang.Object,java.lang.Object,java.lang.Object) -> a
    java.lang.Object apply4(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> a
    java.lang.Object applyN(java.lang.Object[]) -> a
gnu.mapping.Procedure3 -> a.e.A:
    int numArgs() -> e_
    java.lang.Object apply0() -> j
    java.lang.Object apply1(java.lang.Object) -> a
    java.lang.Object apply2(java.lang.Object,java.lang.Object) -> c
    java.lang.Object apply3(java.lang.Object,java.lang.Object,java.lang.Object) -> a
    java.lang.Object apply4(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> a
    java.lang.Object applyN(java.lang.Object[]) -> a
gnu.mapping.ProcedureN -> a.e.B:
    java.lang.Object[] noArgs -> e
    java.lang.Object apply0() -> j
    java.lang.Object apply1(java.lang.Object) -> a
    java.lang.Object apply2(java.lang.Object,java.lang.Object) -> c
    java.lang.Object apply3(java.lang.Object,java.lang.Object,java.lang.Object) -> a
    java.lang.Object apply4(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> a
    java.lang.Object applyN(java.lang.Object[]) -> a
gnu.mapping.PropertyKey -> a.e.C:
    java.lang.Object get(gnu.mapping.PropertySet,java.lang.Object) -> a
gnu.mapping.PropertySet -> a.e.D:
    java.lang.Object[] properties -> a
    gnu.mapping.Symbol nameKey -> L
    java.lang.String getName() -> a
    java.lang.Object getSymbol() -> c
    void setSymbol(java.lang.Object) -> d
    void setName(java.lang.String) -> c
    java.lang.Object getProperty(java.lang.Object,java.lang.Object) -> a
    void setProperty(java.lang.Object,java.lang.Object) -> b
    java.lang.Object[] setProperty(java.lang.Object[],java.lang.Object,java.lang.Object) -> a
gnu.mapping.SharedLocation -> a.e.E:
    int timestamp -> i
    java.lang.Object get(java.lang.Object) -> a
    boolean isBound() -> g
    void set(java.lang.Object) -> b
gnu.mapping.SimpleEnvironment -> a.e.F:
    gnu.mapping.NamedLocation[] table -> d
    int log2Size -> e
    int mask -> b
    int num_bindings -> f
    int currentTimestamp -> g
    gnu.mapping.NamedLocation sharedTail -> c
    gnu.mapping.NamedLocation lookup(gnu.mapping.Symbol,java.lang.Object,int) -> a
    gnu.mapping.NamedLocation lookupDirect(gnu.mapping.Symbol,java.lang.Object,int) -> b
    gnu.mapping.NamedLocation getLocation(gnu.mapping.Symbol,java.lang.Object,int,boolean) -> a
    gnu.mapping.NamedLocation addUnboundLocation(gnu.mapping.Symbol,java.lang.Object,int) -> c
    void put(gnu.mapping.Symbol,java.lang.Object,java.lang.Object) -> c
    gnu.mapping.NamedLocation newEntry(gnu.mapping.Symbol,java.lang.Object,int) -> d
    void define(gnu.mapping.Symbol,java.lang.Object,java.lang.Object) -> a
    void redefineError$8c04e82(gnu.mapping.Symbol) -> c
    gnu.mapping.NamedLocation addLocation(gnu.mapping.Symbol,java.lang.Object,gnu.mapping.Location) -> a
    gnu.mapping.NamedLocation addLocation(gnu.mapping.Symbol,java.lang.Object,int,gnu.mapping.Location) -> a
    gnu.mapping.LocationEnumeration enumerateLocations() -> d
    gnu.mapping.LocationEnumeration enumerateAllLocations() -> e
    boolean hasMoreElements(gnu.mapping.LocationEnumeration) -> a
gnu.mapping.SimpleSymbol -> a.e.G:
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.mapping.Symbol -> a.e.H:
    java.lang.String name -> c
    gnu.mapping.Namespace namespace -> d
    gnu.mapping.Symbol FUNCTION -> e
    gnu.mapping.Symbol getKeySymbol() -> b
    java.lang.Object getKeyProperty() -> d
    java.lang.String getNamespaceURI() -> c
    java.lang.String getLocalPart() -> e
    java.lang.String getPrefix() -> f
    boolean hasEmptyNamespace() -> g
    java.lang.String getLocalName() -> h
    java.lang.String getName() -> i
    gnu.mapping.Symbol make(java.lang.String,java.lang.String,java.lang.String) -> a
    gnu.mapping.Symbol make(java.lang.Object,java.lang.String) -> a
    gnu.mapping.SimpleSymbol valueOf(java.lang.String) -> b
    gnu.mapping.Symbol valueOf(java.lang.String,java.lang.String,java.lang.String) -> b
    gnu.mapping.Symbol makeUninterned(java.lang.String) -> c
    int compareTo(java.lang.Object) -> compareTo
    boolean equals(gnu.mapping.Symbol,gnu.mapping.Symbol) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    gnu.mapping.Namespace getNamespace() -> j
    java.lang.String toString() -> toString
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.mapping.SymbolRef -> a.e.I:
    gnu.mapping.SymbolRef next -> a
    gnu.mapping.Symbol getSymbol() -> a
    java.lang.String toString() -> toString
gnu.mapping.Table2D -> a.e.J:
    gnu.mapping.Entry[] table -> a
    int log2Size -> b
    int mask -> c
    int num_bindings -> d
    java.lang.Object get(java.lang.Object,java.lang.Object,java.lang.Object) -> a
    java.lang.Object put(java.lang.Object,java.lang.Object,java.lang.Object) -> b
    gnu.mapping.Entry lookup(java.lang.Object,java.lang.Object,int,int,boolean) -> a
    java.lang.Object wrapReference(java.lang.Object) -> a
gnu.mapping.ThreadLocation -> a.e.K:
    int counter -> j
    java.lang.String ANONYMOUS -> i
    gnu.mapping.SharedLocation global -> k
    java.lang.ThreadLocal thLocal -> l
    int nextCounter() -> j
    void setGlobal(java.lang.Object) -> c
    gnu.mapping.NamedLocation getLocation() -> i
    java.lang.Object get(java.lang.Object) -> a
    void set(java.lang.Object) -> b
    java.lang.String getName() -> a
    java.lang.Object getSymbol() -> c
gnu.mapping.ThreadLocation$InheritingLocation -> a.e.L:
    gnu.mapping.ThreadLocation this$0 -> a
    java.lang.Object childValue(java.lang.Object) -> childValue
gnu.mapping.TtyInPort -> a.e.M:
    gnu.mapping.OutPort tie -> a
    gnu.mapping.Procedure prompter -> g
    boolean promptEmitted -> h
    void setPrompter(gnu.mapping.Procedure) -> a
    int fill(int) -> a
    void lineStart(boolean) -> a
    int read() -> read
    int read(char[],int,int) -> read
gnu.mapping.UnboundLocationException -> a.e.N:
    java.lang.Object symbol -> a
    gnu.mapping.Location location -> b
    java.lang.String filename -> c
    int line -> d
    int column -> e
    java.lang.String getMessage() -> getMessage
    java.lang.String toString() -> toString
gnu.mapping.ValueStack -> a.e.O:
    void clear() -> clear
gnu.mapping.Values -> a.e.P:
    java.lang.Object[] noArgs -> g
    gnu.mapping.Values empty -> h
    java.lang.Object[] getValues() -> h
    java.lang.Object make(gnu.lists.TreeList,int,int) -> a
    java.lang.Object canonicalize() -> i
    void print(gnu.lists.Consumer) -> a_
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
    void writeValues(java.lang.Object,gnu.lists.Consumer) -> a
gnu.mapping.WrappedException -> a.e.Q:
    java.lang.String toString() -> toString
    java.lang.RuntimeException wrapIfNeeded(java.lang.Throwable) -> a
gnu.mapping.WrongArguments -> a.e.R:
    int number -> b
    java.lang.String usage -> a
    gnu.mapping.Procedure proc -> c
    java.lang.String checkArgCount(gnu.mapping.Procedure,int) -> a
    java.lang.String checkArgCount(java.lang.String,int,int,int) -> a
    java.lang.String getMessage() -> getMessage
gnu.mapping.WrongType -> a.e.S:
    int number -> a
    java.lang.String procname -> b
    gnu.mapping.Procedure proc -> c
    java.lang.Object argValue -> d
    java.lang.Object expectedType -> e
    java.lang.String getMessage() -> getMessage
gnu.math.BaseUnit -> a.f.a:
    java.lang.String dimension -> j
    int base_count -> k
    int index -> a
    void init() -> a
    int hashCode() -> hashCode
    gnu.math.Unit unit() -> b
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.math.CComplex -> a.f.b:
    gnu.math.RealNum real -> a
    gnu.math.RealNum imag -> b
    gnu.math.RealNum re() -> i_
    gnu.math.RealNum im() -> c
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.math.CQuantity -> a.f.c:
    gnu.math.Complex num -> a
    gnu.math.Unit unt -> b
    gnu.math.Complex number() -> d
    gnu.math.Unit unit() -> b
    boolean isExact() -> e
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.math.Complex -> a.f.d:
    gnu.math.CComplex imOne -> a
    gnu.math.CComplex imMinusOne -> b
    gnu.math.Complex number() -> d
    boolean isExact() -> e
    gnu.math.CComplex imOne() -> f
    gnu.math.CComplex imMinusOne() -> g
    double doubleValue() -> doubleValue
    double doubleImagValue() -> h
    long longValue() -> longValue
    gnu.math.Complex make(gnu.math.RealNum,gnu.math.RealNum) -> a
    gnu.math.DComplex polar(double,double) -> a
    gnu.math.DComplex polar(gnu.math.RealNum,gnu.math.RealNum) -> b
    gnu.math.Complex power(gnu.math.Complex,gnu.math.Complex) -> a
    boolean equals(java.lang.Object) -> equals
    int compare(gnu.math.Complex,gnu.math.Complex) -> b
    int compare(java.lang.Object) -> a
    boolean isZero() -> i
    java.lang.String toString(int) -> a
    gnu.math.Numeric neg() -> j
    gnu.math.Complex add(gnu.math.Complex,gnu.math.Complex,int) -> a
    gnu.math.Numeric add(java.lang.Object,int) -> a
    gnu.math.Numeric addReversed(gnu.math.Numeric,int) -> a
    gnu.math.Complex times(gnu.math.Complex,gnu.math.Complex) -> c
    gnu.math.Numeric mul(java.lang.Object) -> b
    gnu.math.Numeric mulReversed(gnu.math.Numeric) -> a
    gnu.math.Complex divide(gnu.math.Complex,gnu.math.Complex) -> d
    gnu.math.Numeric div(java.lang.Object) -> c
    gnu.math.Numeric divReversed(gnu.math.Numeric) -> b
gnu.math.DComplex -> a.f.e:
    double real -> a
    double imag -> b
    gnu.math.RealNum re() -> i_
    double doubleValue() -> doubleValue
    gnu.math.RealNum im() -> c
    double doubleImagValue() -> h
    boolean isExact() -> e
    boolean equals(java.lang.Object) -> equals
    java.lang.String toString() -> toString
    java.lang.String toString(int) -> a
    gnu.math.Numeric neg() -> j
    gnu.math.Numeric add(java.lang.Object,int) -> a
    gnu.math.Numeric mul(java.lang.Object) -> b
    gnu.math.Numeric div(java.lang.Object) -> c
    gnu.math.DComplex power(double,double,double,double) -> a
    gnu.math.DComplex div(double,double,double,double) -> b
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.math.DFloNum -> a.f.f:
    double value -> a
    gnu.math.DFloNum one -> b
    gnu.math.DFloNum make(double) -> a
    gnu.math.DFloNum asDFloNumOrNull(java.lang.Object) -> d
    double doubleValue() -> doubleValue
    long longValue() -> longValue
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    gnu.math.Numeric add(java.lang.Object,int) -> a
    gnu.math.Numeric addReversed(gnu.math.Numeric,int) -> a
    gnu.math.Numeric mul(java.lang.Object) -> b
    gnu.math.Numeric mulReversed(gnu.math.Numeric) -> a
    gnu.math.DFloNum one() -> k
    gnu.math.Numeric div(java.lang.Object) -> c
    gnu.math.Numeric divReversed(gnu.math.Numeric) -> b
    gnu.math.Numeric power(gnu.math.IntNum) -> a
    gnu.math.Numeric neg() -> j
    int sign() -> l
    int compare(double,double) -> b
    int compare(gnu.math.IntNum,gnu.math.IntNum,double) -> a
    int compare(java.lang.Object) -> a
    int compareReversed(gnu.math.Numeric) -> c
    boolean isExact() -> e
    boolean isZero() -> i
    gnu.math.RatNum toExact(double) -> b
    java.lang.String toString() -> toString
    java.lang.String toString(int) -> a
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.math.DQuantity -> a.f.g:
    double factor -> a
    gnu.math.Unit unt -> b
    gnu.math.Unit unit() -> b
    gnu.math.Complex number() -> d
    gnu.math.RealNum re() -> i_
    double doubleValue() -> doubleValue
    boolean isExact() -> e
    gnu.math.Numeric add(java.lang.Object,int) -> a
    gnu.math.Numeric addReversed(gnu.math.Numeric,int) -> a
    gnu.math.Numeric mul(java.lang.Object) -> b
    gnu.math.Numeric mulReversed(gnu.math.Numeric) -> a
    gnu.math.Numeric div(java.lang.Object) -> c
    gnu.math.Numeric divReversed(gnu.math.Numeric) -> b
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.math.Dimensions -> a.f.h:
    gnu.math.BaseUnit[] bases -> a
    short[] powers -> c
    int hash_code -> d
    gnu.math.Dimensions chain -> e
    gnu.math.Dimensions[] hashTable -> f
    gnu.math.Dimensions Empty -> b
    int hashCode() -> hashCode
    void enterHash(int) -> a
    gnu.math.Dimensions product(gnu.math.Dimensions,int,gnu.math.Dimensions,int) -> a
    java.lang.String toString() -> toString
gnu.math.IntFraction -> a.f.i:
    gnu.math.IntNum num -> a
    gnu.math.IntNum den -> b
    gnu.math.IntNum numerator() -> k
    gnu.math.IntNum denominator() -> m
    int sign() -> l
    int compare(java.lang.Object) -> a
    int compareReversed(gnu.math.Numeric) -> c
    gnu.math.Numeric add(java.lang.Object,int) -> a
    gnu.math.Numeric addReversed(gnu.math.Numeric,int) -> a
    gnu.math.Numeric mul(java.lang.Object) -> b
    gnu.math.Numeric mulReversed(gnu.math.Numeric) -> a
    gnu.math.Numeric div(java.lang.Object) -> c
    gnu.math.Numeric divReversed(gnu.math.Numeric) -> b
    gnu.math.Numeric neg() -> j
    long longValue() -> longValue
    double doubleValue() -> doubleValue
    java.lang.String toString(int) -> a
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.math.IntNum -> a.f.j:
    int ival -> a
    int[] words -> b
    gnu.math.IntNum[] smallFixNums -> c
    gnu.math.IntNum make(int) -> b
    gnu.math.IntNum zero() -> n
    gnu.math.IntNum one() -> o
    gnu.math.IntNum ten() -> p
    gnu.math.IntNum minusOne() -> q
    gnu.math.IntNum make(long) -> a
    gnu.math.IntNum asIntNumOrNull(java.lang.Object) -> d
    gnu.math.IntNum makeU(long) -> b
    gnu.math.IntNum make(int[],int) -> a
    gnu.math.IntNum alloc(int) -> e
    void realloc(int) -> f
    gnu.math.IntNum numerator() -> k
    gnu.math.IntNum denominator() -> m
    boolean isNegative() -> r
    int sign() -> l
    int compare(gnu.math.IntNum,gnu.math.IntNum) -> a
    int compare(gnu.math.IntNum,long) -> a
    int compare(java.lang.Object) -> a
    boolean isOdd() -> s
    boolean isZero() -> i
    boolean isOne() -> t
    int wordsNeeded(int[],int) -> b
    gnu.math.IntNum canonicalize() -> u
    gnu.math.IntNum add(gnu.math.IntNum,int) -> c
    void setAdd(gnu.math.IntNum,int) -> d
    void set(int) -> g
    void set(long) -> c
    void set(int[],int) -> c
    void set(gnu.math.IntNum) -> c
    gnu.math.IntNum add(gnu.math.IntNum,gnu.math.IntNum,int) -> a
    gnu.math.IntNum times(gnu.math.IntNum,int) -> e
    gnu.math.IntNum times(gnu.math.IntNum,gnu.math.IntNum) -> b
    void divide(gnu.math.IntNum,gnu.math.IntNum,gnu.math.IntNum,gnu.math.IntNum,int) -> a
    gnu.math.IntNum quotient(gnu.math.IntNum,gnu.math.IntNum,int) -> b
    gnu.math.IntNum quotient(gnu.math.IntNum,gnu.math.IntNum) -> c
    gnu.math.IntNum toExactInt(int) -> c
    gnu.math.Numeric power(gnu.math.IntNum) -> a
    gnu.math.IntNum power(gnu.math.IntNum,int) -> a
    gnu.math.IntNum gcd(gnu.math.IntNum,gnu.math.IntNum) -> d
    gnu.math.IntNum shift(gnu.math.IntNum,int) -> b
    void format(int,java.lang.StringBuilder) -> a
    java.lang.String toString(int) -> a
    int intValue() -> intValue
    long longValue() -> longValue
    int hashCode() -> hashCode
    boolean equals(gnu.math.IntNum,gnu.math.IntNum) -> e
    boolean equals(java.lang.Object) -> equals
    gnu.math.IntNum valueOf(char[],int,int,int,boolean) -> a
    gnu.math.IntNum valueOf(java.lang.String,int) -> a
    gnu.math.IntNum valueOf(byte[],int,boolean,int) -> a
    double doubleValue() -> doubleValue
    boolean checkBits(int) -> h
    double roundToDouble(int,boolean,boolean) -> a
    gnu.math.Numeric add(java.lang.Object,int) -> a
    gnu.math.Numeric mul(java.lang.Object) -> b
    gnu.math.Numeric div(java.lang.Object) -> c
    void getAbsolute(int[]) -> a
    boolean negate(int[],int[],int) -> a
    void setNegative(gnu.math.IntNum) -> d
    gnu.math.IntNum abs(gnu.math.IntNum) -> e
    gnu.math.IntNum neg(gnu.math.IntNum) -> b
    gnu.math.Numeric neg() -> j
    int intLength() -> v
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
    boolean inRange(long,long) -> a
    boolean inIntRange() -> w
    boolean inLongRange() -> x
gnu.math.MPN -> a.f.k:
    int sub_n(int[],int[],int[],int) -> a
    int mul_1(int[],int[],int,int) -> a
    void mul(int[],int[],int,int[],int) -> a
    long udiv_qrnnd(long,int) -> a
    int divmod_1(int[],int[],int,int) -> b
    int chars_per_word(int) -> a
    int count_leading_zeros(int) -> b
    int cmp(int[],int[],int) -> a
    int rshift(int[],int[],int,int,int) -> a
    void rshift0(int[],int[],int,int,int) -> b
    int lshift(int[],int,int[],int,int) -> a
    int findLowestBit(int) -> c
    int intLength(int) -> d
gnu.math.MulUnit -> a.f.l:
    gnu.math.Unit unit1 -> a
    gnu.math.Unit unit2 -> b
    int power1 -> c
    int power2 -> d
    gnu.math.MulUnit next -> j
    java.lang.String toString() -> toString
    gnu.math.MulUnit make(gnu.math.Unit,int,gnu.math.Unit,int) -> a
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.math.NamedUnit -> a.f.m:
    java.lang.String name -> b
    double scale -> c
    gnu.math.Unit base -> d
    gnu.math.NamedUnit chain -> a
    void init() -> a
    java.lang.String getName() -> f
    gnu.math.NamedUnit lookup(java.lang.String) -> a
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.math.Numeric -> a.f.n:
    float floatValue() -> floatValue
    int intValue() -> intValue
    long longValue() -> longValue
    gnu.math.Numeric add(java.lang.Object,int) -> a
    gnu.math.Numeric mul(java.lang.Object) -> b
    gnu.math.Numeric neg() -> j
    java.lang.String toString(int) -> a
    java.lang.String toString() -> toString
    gnu.math.Numeric asNumericOrNull(java.lang.Object) -> e
    boolean isExact() -> e
    int compare(java.lang.Object) -> a
    int compareReversed(gnu.math.Numeric) -> c
    boolean equals(java.lang.Object) -> equals
    gnu.math.Numeric addReversed(gnu.math.Numeric,int) -> a
    gnu.math.Numeric mulReversed(gnu.math.Numeric) -> a
    gnu.math.Numeric divReversed(gnu.math.Numeric) -> b
    gnu.math.Numeric power(gnu.math.IntNum) -> a
gnu.math.Quantity -> a.f.o:
    gnu.math.Unit unit() -> b
    gnu.math.Dimensions dimensions() -> y
    gnu.math.Complex number() -> d
    gnu.math.RealNum re() -> i_
    gnu.math.RealNum im() -> c
    double doubleValue() -> doubleValue
    double doubleImagValue() -> h
    gnu.math.Quantity make(gnu.math.Complex,gnu.math.Unit) -> a
    gnu.math.Numeric neg() -> j
    int compare(gnu.math.Quantity,gnu.math.Quantity) -> a
    int compare(java.lang.Object) -> a
    int compareReversed(gnu.math.Numeric) -> c
    gnu.math.Quantity add(gnu.math.Quantity,gnu.math.Quantity,int) -> a
    gnu.math.Numeric add(java.lang.Object,int) -> a
    gnu.math.Numeric addReversed(gnu.math.Numeric,int) -> a
    gnu.math.Quantity times(gnu.math.Quantity,gnu.math.Quantity) -> b
    gnu.math.Numeric mul(java.lang.Object) -> b
    gnu.math.Numeric mulReversed(gnu.math.Numeric) -> a
    gnu.math.Quantity divide(gnu.math.Quantity,gnu.math.Quantity) -> c
    gnu.math.Numeric div(java.lang.Object) -> c
    gnu.math.Numeric divReversed(gnu.math.Numeric) -> b
    java.lang.String toString(int) -> a
gnu.math.RatNum -> a.f.p:
    gnu.math.IntNum ten_exp_9 -> a
    gnu.math.IntNum numerator() -> k
    gnu.math.IntNum denominator() -> m
    gnu.math.RatNum make(gnu.math.IntNum,gnu.math.IntNum) -> f
    gnu.math.RatNum valueOf(java.math.BigDecimal) -> a
    gnu.math.RatNum asRatNumOrNull(java.lang.Object) -> f
    boolean isExact() -> e
    boolean isZero() -> i
    gnu.math.RatNum infinity(int) -> d
    int compare(gnu.math.RatNum,gnu.math.RatNum) -> a
    boolean equals(java.lang.Object) -> equals
    gnu.math.RatNum add(gnu.math.RatNum,gnu.math.RatNum,int) -> a
    gnu.math.RatNum neg(gnu.math.RatNum) -> a
    gnu.math.RatNum times(gnu.math.RatNum,gnu.math.RatNum) -> b
    gnu.math.RatNum divide(gnu.math.RatNum,gnu.math.RatNum) -> c
    gnu.math.Numeric power(gnu.math.IntNum) -> a
    gnu.math.RatNum toExact() -> z
    gnu.math.IntNum toExactInt(int) -> c
    gnu.math.RealNum rneg() -> A
gnu.math.RealNum -> a.f.q:
    gnu.math.RealNum re() -> i_
    gnu.math.RealNum im() -> c
    gnu.math.RealNum asRealNumOrNull(java.lang.Object) -> g
    int sign() -> l
    gnu.math.RealNum add(gnu.math.RealNum,gnu.math.RealNum,int) -> a
    gnu.math.RealNum times(gnu.math.RealNum,gnu.math.RealNum) -> c
    gnu.math.RealNum divide(gnu.math.RealNum,gnu.math.RealNum) -> d
    gnu.math.Numeric add(java.lang.Object,int) -> a
    gnu.math.Numeric mul(java.lang.Object) -> b
    gnu.math.Numeric div(java.lang.Object) -> c
    gnu.math.RealNum rneg() -> A
    boolean isZero() -> i
    gnu.math.RatNum toExact() -> z
    gnu.math.IntNum toExactInt(int) -> c
    int compareTo(java.lang.Object) -> compareTo
    java.lang.String toStringScientific(java.lang.String) -> a
    int toStringScientific(java.lang.String,java.lang.StringBuffer) -> a
    java.lang.String toStringDecimal(java.lang.String) -> b
gnu.math.Unit -> a.f.r:
    gnu.math.Dimensions dims -> e
    double factor -> f
    gnu.math.MulUnit products -> g
    gnu.math.NamedUnit[] table -> h
    gnu.math.BaseUnit Empty -> i
    double NON_COMBINABLE -> a
    gnu.math.BaseUnit meter -> b
    gnu.math.BaseUnit duration -> c
    gnu.math.Unit cm -> d
    gnu.math.NamedUnit second -> j
    gnu.math.Unit minute -> k
    gnu.math.Dimensions dimensions() -> y
    double doubleValue() -> doubleValue
    int hashCode() -> hashCode
    java.lang.String getName() -> f
    gnu.math.Unit times(gnu.math.Unit,int,gnu.math.Unit,int) -> a
    gnu.math.Unit times(gnu.math.Unit,gnu.math.Unit) -> a
    gnu.math.Unit divide(gnu.math.Unit,gnu.math.Unit) -> b
    gnu.math.Unit define(java.lang.String,double,gnu.math.Unit) -> a
    gnu.math.Complex number() -> d
    boolean isExact() -> e
    gnu.math.Numeric power(gnu.math.IntNum) -> a
    gnu.math.NamedUnit lookup(java.lang.String) -> b
    java.lang.String toString() -> toString
    gnu.math.Unit unit() -> b
gnu.text.Char -> a.g.a:
    int value -> a
    gnu.text.Char[] ascii -> b
    gnu.text.CharMap hashTable -> c
    char[] charNameValues -> d
    java.lang.String[] charNames -> e
    void print(gnu.lists.Consumer) -> a
    void print(int,gnu.lists.Consumer) -> a
    char charValue() -> a
    int intValue() -> b
    int hashCode() -> hashCode
    gnu.text.Char make(int) -> a
    boolean equals(java.lang.Object) -> equals
    int nameToChar(java.lang.String) -> a
    java.lang.String toString() -> toString
    java.lang.String toScmReadableString(int) -> b
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
    int compareTo(java.lang.Object) -> compareTo
gnu.text.CharMap -> a.g.b:
    gnu.text.Char get(int) -> c
    java.lang.Object getKeyFromValue(java.lang.Object) -> a
gnu.text.FilePath -> a.g.c:
    java.io.File file -> b
    java.lang.String path -> c
    gnu.text.FilePath valueOf(java.lang.String) -> a
    gnu.text.FilePath valueOf(java.io.File) -> a
    gnu.text.FilePath makeFilePath(java.lang.Object) -> a
    boolean isAbsolute() -> a
    boolean isDirectory() -> b
    long getLastModified() -> c
    java.lang.String getPath() -> d
    java.lang.String getLast() -> e
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    java.net.URL toURL() -> f
    java.net.URI toUri(java.io.File) -> b
    java.net.URI toUri() -> g
    java.io.InputStream openInputStream() -> h
    gnu.text.Path resolve(java.lang.String) -> b
    gnu.text.Path getCanonical() -> i
    gnu.text.Path getParent() -> j
    int compareTo(java.lang.Object) -> compareTo
gnu.text.Lexer -> a.g.d:
    gnu.text.LineBufferedReader port -> b
    boolean interactive -> c
    int nesting -> a
    gnu.text.SourceMessages messages -> f
    char[] tokenBuffer -> d
    int tokenBufferLength -> e
    int saveTokenBufferLength -> g
    char pushNesting(char) -> a
    void popNesting(char) -> b
    gnu.text.LineBufferedReader getPort() -> e
    void close() -> close
    int read() -> read
    int readUnicodeChar() -> f
    int read(char[],int,int) -> read
    void unread(int) -> b
    int peek() -> g
    void skip() -> h
    void unread() -> i
    boolean checkNext(char) -> c
    gnu.text.SourceMessages getMessages() -> j
    void error(char,java.lang.String,int,int,java.lang.String) -> a
    void error(char,java.lang.String) -> a
    void error(java.lang.String) -> a
    void fatal(java.lang.String) -> b
    void eofError(java.lang.String) -> c
    void eofError(java.lang.String,int,int) -> a
    boolean readDelimited(java.lang.String) -> d
    java.lang.String getName() -> k
    int getLineNumber() -> l
    int getColumnNumber() -> m
    void setInteractive(boolean) -> a
    void tokenBufferAppend(int) -> c
    java.lang.String tokenBufferString() -> n
    void reset() -> reset
gnu.text.LineBufferedReader -> a.g.e:
    java.io.Reader in -> b
    char[] buffer -> c
    int pos -> d
    int limit -> e
    int highestPos -> a
    char readState -> f
    int flags -> g
    int lineStartPos -> h
    gnu.text.Path path -> i
    int lineNumber -> j
    int readAheadLimit -> k
    int markPos -> l
    void close() -> close
    boolean getConvertCR() -> b
    void setConvertCR(boolean) -> b
    void lineStart(boolean) -> a
    int fill(int) -> a
    void clearMark() -> a
    void setBuffer(char[]) -> a
    void reserve(char[],int) -> a
    int read() -> read
    int read(char[],int,int) -> read
    void setPath(gnu.text.Path) -> a
    java.lang.String getName() -> c
    int getLineNumber() -> d
    int getColumnNumber() -> e
    boolean markSupported() -> markSupported
    void mark(int) -> mark
    void reset() -> reset
    boolean ready() -> ready
    void skip() -> f
    void unread() -> g
    void unread_quick() -> h
    int peek() -> i
gnu.text.NullReader -> a.g.f:
    gnu.text.NullReader nullReader -> a
    int read(char[],int,int) -> read
    boolean ready() -> ready
    void close() -> close
gnu.text.Options -> a.g.g:
    gnu.text.Options previous -> a
    gnu.text.Options$OptionInfo first -> b
    gnu.text.Options$OptionInfo last -> c
    java.util.HashMap valueTable -> d
    java.util.HashMap infoTable -> e
    gnu.text.Options$OptionInfo add(java.lang.String,int,java.lang.Object,java.lang.String) -> a
    boolean getBoolean(gnu.text.Options$OptionInfo) -> a
gnu.text.Options$OptionInfo -> a.g.h:
    java.lang.String key -> a
    int kind -> b
    java.lang.Object defaultValue -> c
gnu.text.Path -> a.g.i:
    gnu.text.FilePath userDirPath -> a
    gnu.text.Path defaultPath -> b
    java.lang.ThreadLocal pathLocation -> c
    gnu.text.Path currentPath() -> k
    gnu.text.Path valueOf(java.lang.Object) -> b
    java.net.URL toURL(java.lang.String) -> c
    boolean uriSchemeSpecified(java.lang.String) -> d
    boolean isAbsolute() -> a
    boolean isDirectory() -> b
    long getLastModified() -> c
    java.lang.String getPath() -> d
    gnu.text.Path getParent() -> j
    java.lang.String getLast() -> e
    java.net.URL toURL() -> f
    java.net.URI toUri() -> g
    java.lang.String toURIString() -> l
    gnu.text.Path resolve(gnu.text.Path) -> a
    gnu.text.Path resolve(java.lang.String) -> b
    java.io.InputStream openInputStream() -> h
    java.lang.String relativize(java.lang.String,java.lang.String) -> a
    gnu.text.Path getAbsolute() -> m
    gnu.text.Path getCanonical() -> i
gnu.text.PrettyWriter -> a.g.j:
    java.io.Writer out -> c
    int lineLength -> d
    int miserWidth -> e
    gnu.mapping.ThreadLocation lineLengthLoc -> f
    gnu.mapping.ThreadLocation miserWidthLoc -> g
    gnu.mapping.ThreadLocation indentLoc -> h
    int prettyPrintingMode -> i
    int initialBufferSize -> j
    char[] buffer -> a
    int bufferFillPointer -> b
    int bufferOffset -> k
    int bufferStartColumn -> l
    int lineNumber -> m
    int[] blocks -> n
    int blockDepth -> o
    char[] prefix -> p
    char[] suffix -> q
    int[] queueInts -> r
    java.lang.String[] queueStrings -> s
    int queueTail -> t
    int queueSize -> u
    int currentBlock -> v
    int pendingBlocksCount -> w
    boolean wordEndSeen -> x
    int posnColumn(int) -> b
    int getQueueType(int) -> c
    int getQueueSize(int) -> d
    int getSectionColumn() -> g
    int getStartColumn() -> h
    int getPerLinePrefixEnd() -> i
    int getPrefixLength() -> j
    void writeWordEnd() -> a
    void writeWordStart() -> b
    void clearWordEnd() -> c
    void write(int) -> write
    void write(java.lang.String) -> write
    void write(java.lang.String,int,int) -> write
    void write(char[]) -> write
    void write(char[],int,int) -> write
    void reallyStartLogicalBlock(int,java.lang.String,java.lang.String) -> a
    int enoughSpace(int,int) -> a
    void setIndentation(int) -> e
    void reallyEndLogicalBlock() -> k
    int enqueue(int,int) -> b
    void enqueueNewline(int) -> f
    void writeBreak(int) -> a
    void addIndentation(int,boolean) -> a
    void startLogicalBlock(java.lang.String,boolean,java.lang.String) -> a
    void endLogicalBlock(java.lang.String) -> a
    int computeTabSize(int,int,int) -> a
    int indexColumn(int) -> g
    void expandTabs(int) -> h
    int ensureSpaceInBuffer(int) -> i
    boolean maybeOutput(boolean,boolean) -> a
    boolean isMisering() -> l
    int fitsOnLine(int,boolean) -> b
    void outputPartialLine() -> m
    void forcePrettyOutput() -> n
    void flush() -> flush
    void close() -> close
    void closeThis() -> d
    int getColumnNumber() -> e
    void clearBuffer() -> f
gnu.text.Printable -> a.g.k:
    void print(gnu.lists.Consumer) -> a_
gnu.text.SourceError -> a.g.l:
    gnu.text.SourceError next -> a
    char severity -> b
    java.lang.String filename -> c
    java.lang.String code -> d
    int line -> e
    int column -> f
    java.lang.String message -> h
    java.lang.Throwable fakeException -> g
    java.lang.String toString() -> toString
    int getLineNumber() -> getLineNumber
    int getColumnNumber() -> getColumnNumber
    java.lang.String getPublicId() -> getPublicId
    java.lang.String getSystemId() -> getSystemId
    java.lang.String getFileName() -> r
gnu.text.SourceLocator -> a.g.m:
    int getColumnNumber() -> getColumnNumber
    int getLineNumber() -> getLineNumber
    java.lang.String getPublicId() -> getPublicId
    java.lang.String getSystemId() -> getSystemId
    java.lang.String getFileName() -> r
gnu.text.SourceMessages -> a.g.n:
    int errorCount -> b
    gnu.text.SourceError firstError -> a
    gnu.text.SourceError lastError -> c
    gnu.text.SourceLocator locator -> d
    java.lang.String current_filename -> e
    int current_line -> f
    int current_column -> g
    boolean debugStackTraceOnWarning -> h
    boolean debugStackTraceOnError -> i
    gnu.text.SourceError lastPrevFilename -> j
    boolean seenErrors() -> a
    int getErrorCount() -> b
    void clear() -> c
    void error(gnu.text.SourceError) -> a
    void error(char,java.lang.String,int,int,java.lang.String) -> a
    void error(char,gnu.text.SourceLocator,java.lang.String) -> a
    void error(char,java.lang.String,int,int,java.lang.String,java.lang.String) -> a
    void error(char,java.lang.String) -> a
    void error(char,java.lang.String,java.lang.Throwable) -> a
    void printAll(java.io.PrintWriter,int) -> a
    java.lang.String toString(int) -> a
    boolean checkErrors(java.io.PrintWriter,int) -> b
    gnu.text.SourceLocator swapSourceLocator(gnu.text.SourceLocator) -> a
    void setLocation(gnu.text.SourceLocator) -> b
    java.lang.String getPublicId() -> getPublicId
    java.lang.String getSystemId() -> getSystemId
    java.lang.String getFileName() -> r
    int getLineNumber() -> getLineNumber
    int getColumnNumber() -> getColumnNumber
    void setLine(java.lang.String,int,int) -> a
gnu.text.SyntaxException -> a.g.o:
    gnu.text.SourceMessages messages -> a
    int maxToPrint -> b
    gnu.text.SourceMessages getMessages() -> a
    void printAll(java.io.PrintWriter,int) -> a
    void clear() -> b
    java.lang.String getMessage() -> getMessage
gnu.text.URIPath -> a.g.p:
    java.net.URI uri -> b
    gnu.text.URIPath makeURI(java.lang.Object) -> a
    gnu.text.URIPath valueOf(java.net.URI) -> a
    gnu.text.URIPath valueOf(java.lang.String) -> a
    boolean isAbsolute() -> a
    long getLastModified() -> c
    java.net.URI toUri() -> g
    java.lang.String toURIString() -> l
    gnu.text.Path resolve(java.lang.String) -> b
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    java.net.URL toURL() -> f
    java.io.InputStream openInputStream() -> h
    java.lang.String getPath() -> d
    gnu.text.Path getCanonical() -> i
    java.lang.String encodeForUri(java.lang.String,char) -> a
    int compareTo(java.lang.Object) -> compareTo
gnu.text.URIStringPath -> a.g.q:
    java.lang.String uriString -> c
    java.lang.String toURIString() -> l
gnu.text.URLPath -> a.g.r:
    java.net.URL url -> c
    gnu.text.URLPath valueOf(java.net.URL) -> a
    boolean isAbsolute() -> a
    long getLastModified() -> c
    long getLastModified(java.net.URL) -> b
    java.net.URL toURL() -> f
    java.net.URI toUri(java.net.URL) -> c
    java.net.URI toUri() -> g
    java.lang.String toURIString() -> l
    gnu.text.Path resolve(java.lang.String) -> b
    java.io.InputStream openInputStream() -> h
gnu.text.WriterManager -> a.g.s:
    gnu.text.WriterManager instance -> a
    gnu.text.WriterRef first -> b
    gnu.text.WriterRef register(java.io.Writer) -> a
    void unregister(java.lang.Object) -> a
    void run() -> run
    boolean registerShutdownHook() -> a
gnu.text.WriterRef -> a.g.t:
    gnu.text.WriterRef next -> a
    gnu.text.WriterRef prev -> b
gnu.xml.MappingInfo -> a.h.a:
    gnu.xml.MappingInfo nextInBucket -> a
    int tagHash -> b
    java.lang.String prefix -> c
    java.lang.String local -> d
    java.lang.String uri -> e
    gnu.mapping.Symbol qname -> f
    gnu.xml.NamespaceBinding namespaces -> g
    gnu.xml.XName type -> h
    int index -> i
gnu.xml.NamespaceBinding -> a.h.b:
    java.lang.String prefix -> a
    java.lang.String uri -> b
    gnu.xml.NamespaceBinding next -> c
    int depth -> e
    gnu.xml.NamespaceBinding predefinedXML -> d
    java.lang.String getPrefix() -> a
    java.lang.String getUri() -> b
    gnu.xml.NamespaceBinding getNext() -> c
    java.lang.String resolve(java.lang.String) -> a
    gnu.xml.NamespaceBinding commonAncestor(gnu.xml.NamespaceBinding,gnu.xml.NamespaceBinding) -> a
    int count(gnu.xml.NamespaceBinding) -> a
    java.lang.String toString() -> toString
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.xml.NodeTree -> a.h.c:
    int counter -> a
    int id -> g
    int nextPos(int) -> o
    int getId() -> j
    int stableCompare(gnu.lists.AbstractSequence) -> a
    gnu.lists.SeqPosition getIteratorAtPos(int) -> e
    java.lang.String posNamespaceURI(int) -> E
    java.lang.String posPrefix(int) -> F
    java.lang.String posLocalName(int) -> G
    boolean posIsDefaultNamespace$4f70807c() -> h
    java.lang.String posLookupNamespaceURI(int,java.lang.String) -> a
    java.lang.String posLookupPrefix$22c48cd8() -> i
    int posFirstChild(int) -> H
    boolean posHasAttributes(int) -> I
    int getAttribute(int,java.lang.String,java.lang.String) -> a
    int getAttributeI(int,java.lang.String,java.lang.String) -> b
    java.lang.Object typedValue(int) -> J
    java.lang.String posTarget(int) -> K
    gnu.text.Path baseUriOfPos(int,boolean) -> b
    java.lang.String toString() -> toString
gnu.xml.XMLFilter -> a.h.d:
    gnu.lists.TreeList tlist -> c
    gnu.lists.Consumer out -> a
    gnu.lists.Consumer base -> d
    int copyNamespacesMode -> b
    java.lang.Object[] workStack -> e
    gnu.xml.NamespaceBinding namespaceBindings -> f
    gnu.text.SourceLocator locator -> g
    int nesting -> h
    int previous -> i
    int stringizingLevel -> j
    int stringizingElementNesting -> k
    int ignoringLevel -> l
    int[] startIndexes -> m
    int attrCount -> n
    java.lang.String attrLocalName -> o
    java.lang.String attrPrefix -> p
    boolean namespacePrefixes -> q
    gnu.xml.MappingInfo[] mappingTable -> r
    int mappingTableMask -> s
    gnu.xml.NamespaceBinding findNamespaceBinding(java.lang.String,java.lang.String,gnu.xml.NamespaceBinding) -> a
    void endAttribute() -> b
    void closeStartTag() -> e
    boolean checkWriteAtomic() -> f
    void write(int) -> write
    void writeBoolean(boolean) -> a
    void writeFloat(float) -> a
    void writeDouble(double) -> a
    void writeInt(int) -> a
    void writeLong(long) -> a
    void consume(gnu.lists.SeqPosition) -> a
    void writePosition(gnu.lists.AbstractSequence,int) -> a
    void writeObject(java.lang.Object) -> c
    void write(char[],int,int) -> write
    void write(java.lang.String) -> write
    void write(java.lang.CharSequence,int,int) -> a
    void writeJoiner() -> g
    void writeCDATA(char[],int,int) -> b
    void startElement(java.lang.Object) -> a
    gnu.xml.NamespaceBinding mergeHelper(gnu.xml.NamespaceBinding,gnu.xml.NamespaceBinding) -> a
    void startAttribute(java.lang.Object) -> b
    void endElement() -> c
    void writeComment(char[],int,int) -> a
    void writeProcessingInstruction(java.lang.String,char[],int,int) -> a
    void processingInstructionCommon(java.lang.String,char[],int,int) -> b
    void startDocument() -> startDocument
    void endDocument() -> endDocument
    void beginEntity(java.lang.Object) -> e
    void endEntity() -> a
    gnu.xml.XMLFilter append(char) -> a
    gnu.xml.XMLFilter append(java.lang.CharSequence,int,int) -> b
    gnu.xml.MappingInfo lookupTag(gnu.mapping.Symbol) -> a
    void ensureSpaceInWorkStack(int) -> b
    void error(char,java.lang.String) -> a
    boolean ignoring() -> d
    void setDocumentLocator(org.xml.sax.Locator) -> setDocumentLocator
    void startElement(java.lang.String,java.lang.String,java.lang.String,org.xml.sax.Attributes) -> startElement
    void endElement(java.lang.String,java.lang.String,java.lang.String) -> endElement
    void startElement(java.lang.String,org.xml.sax.AttributeList) -> startElement
    void endElement(java.lang.String) -> endElement
    void characters(char[],int,int) -> characters
    void ignorableWhitespace(char[],int,int) -> ignorableWhitespace
    void processingInstruction(java.lang.String,java.lang.String) -> processingInstruction
    void startPrefixMapping(java.lang.String,java.lang.String) -> startPrefixMapping
    void endPrefixMapping(java.lang.String) -> endPrefixMapping
    void skippedEntity(java.lang.String) -> skippedEntity
    java.lang.String getPublicId() -> getPublicId
    java.lang.String getSystemId() -> getSystemId
    java.lang.String getFileName() -> r
    int getLineNumber() -> getLineNumber
    int getColumnNumber() -> getColumnNumber
    java.lang.Appendable append(char) -> append
    java.lang.Appendable append(java.lang.CharSequence,int,int) -> append
    java.lang.Appendable append(java.lang.CharSequence) -> append
gnu.xml.XMLPrinter -> a.h.e:
    int printIndent -> d
    boolean printXMLdecl -> e
    boolean inDocument -> f
    boolean inAttribute -> g
    boolean inStartTag -> h
    int inComment -> i
    boolean needXMLdecl -> j
    boolean canonicalize -> k
    int useEmptyElementTag -> l
    boolean escapeText -> m
    boolean escapeNonAscii -> n
    boolean isHtml -> o
    boolean isHtmlOrXhtml -> p
    boolean undeclareNamespaces -> q
    gnu.mapping.ThreadLocation doctypeSystem -> r
    gnu.mapping.ThreadLocation doctypePublic -> s
    gnu.mapping.ThreadLocation indentLoc -> t
    gnu.xml.NamespaceBinding namespaceBindings -> u
    gnu.xml.NamespaceBinding[] namespaceSaveStack -> v
    java.lang.Object[] elementNameStack -> w
    int elementNesting -> x
    int prev -> y
    char savedHighSurrogate -> z
    boolean mustHexEscape(int) -> c
    void write(int) -> write
    void startWord() -> s
    void writeBoolean(boolean) -> a
    void startNumber() -> e
    void endNumber() -> f
    void closeTag() -> t
    void setIndentMode() -> u
    void startDocument() -> startDocument
    void endDocument() -> endDocument
    void beginEntity(java.lang.Object) -> e
    void endEntity() -> a
    void writeQName(java.lang.Object) -> d
    void startElement(java.lang.Object) -> a
    java.lang.String getHtmlTag(java.lang.Object) -> f
    void endElement() -> c
    void startAttribute(java.lang.Object) -> b
    void endAttribute() -> b
    void writeDouble(double) -> a
    void writeFloat(float) -> a
    java.lang.String formatDouble(double) -> b
    java.lang.String formatFloat(float) -> b
    java.lang.String formatDecimal(java.math.BigDecimal) -> a
    java.lang.String formatDecimal(java.lang.String) -> b
    void print(java.lang.Object) -> print
    void writeObject(java.lang.Object) -> c
    boolean ignoring() -> d
    void write(java.lang.String,int,int) -> write
    void write(char[],int,int) -> write
    void writePosition(gnu.lists.AbstractSequence,int) -> a
    void writeComment(char[],int,int) -> a
    void writeCDATA(char[],int,int) -> b
    void writeProcessingInstruction(java.lang.String,char[],int,int) -> a
    void consume(gnu.lists.SeqPosition) -> a
gnu.xml.XName -> a.h.f:
    gnu.xml.NamespaceBinding namespaceNodes -> a
    gnu.xml.NamespaceBinding getNamespaceNodes() -> a
    java.lang.String lookupNamespaceURI(java.lang.String) -> a
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
    boolean isNameStart(int) -> a
    boolean isNamePart(int) -> b
    boolean isNCName(java.lang.String) -> d
kawa.Shell -> b.a:
    java.lang.Class[] noClasses -> a
    java.lang.Class[] boolClasses -> b
    java.lang.Class[] xmlPrinterClasses -> c
    java.lang.Class[] httpPrinterClasses -> d
    java.lang.Object portArg -> e
    boolean run(gnu.expr.Language,gnu.mapping.Environment) -> a
    java.lang.Throwable run(gnu.expr.Language,gnu.mapping.Environment,gnu.mapping.InPort,gnu.mapping.OutPort,gnu.mapping.OutPort,gnu.text.SourceMessages) -> a
    java.lang.Throwable run(gnu.expr.Language,gnu.mapping.Environment,gnu.mapping.InPort,gnu.lists.Consumer,gnu.mapping.OutPort,java.net.URL,gnu.text.SourceMessages) -> a
    void printError(java.lang.Throwable,gnu.text.SourceMessages,gnu.mapping.OutPort) -> a
kawa.lang.AutoloadProcedure -> b.a.a:
    java.lang.String className -> a
    gnu.mapping.Procedure loaded -> b
    java.lang.Class classModuleBody -> c
    void throw_error(java.lang.String) -> a
    void load() -> e
    gnu.mapping.Procedure getLoaded() -> d
    int numArgs() -> e_
    java.lang.Object apply0() -> j
    java.lang.Object apply1(java.lang.Object) -> a
    java.lang.Object apply2(java.lang.Object,java.lang.Object) -> c
    java.lang.Object apply3(java.lang.Object,java.lang.Object,java.lang.Object) -> a
    java.lang.Object apply4(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> a
    java.lang.Object applyN(java.lang.Object[]) -> a
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
    java.lang.Object getProperty(java.lang.Object,java.lang.Object) -> a
kawa.lang.Lambda -> b.a.b:
    java.lang.Object optionalKeyword -> a
    java.lang.Object restKeyword -> c
    java.lang.Object keyKeyword -> d
    gnu.expr.Keyword nameKeyword -> e
    gnu.expr.Expression defaultDefault -> f
    void setKeywords(java.lang.Object,java.lang.Object,java.lang.Object) -> a
    gnu.expr.Expression rewriteForm(gnu.lists.Pair,kawa.lang.Translator) -> a
    gnu.expr.Expression rewrite(java.lang.Object,kawa.lang.Translator) -> a
    void rewrite(gnu.expr.LambdaExp,java.lang.Object,java.lang.Object,kawa.lang.Translator,kawa.lang.TemplateScope) -> a
    void addParam(gnu.expr.Declaration,gnu.expr.ScopeExp,gnu.expr.LambdaExp,kawa.lang.Translator) -> a
    java.lang.Object rewriteAttrs(gnu.expr.LambdaExp,java.lang.Object,kawa.lang.Translator) -> a
    void rewriteBody(gnu.expr.LambdaExp,java.lang.Object,kawa.lang.Translator) -> b
    void print(gnu.lists.Consumer) -> a_
kawa.lang.Macro -> b.a.c:
    java.lang.Object expander -> a
    boolean hygienic -> c
    gnu.expr.Expression rewriteForm(gnu.lists.Pair,kawa.lang.Translator) -> a
    java.lang.String toString() -> toString
    void print(gnu.lists.Consumer) -> a_
    java.lang.Object expand(java.lang.Object,kawa.lang.Translator) -> b
    void scanForm(gnu.lists.Pair,gnu.expr.ScopeExp,kawa.lang.Translator) -> a
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
kawa.lang.PatternScope -> b.a.d:
kawa.lang.Quote -> b.a.e:
    kawa.lang.Quote plainQuote -> a
    boolean isQuasi -> c
    java.lang.Object WORKING -> d
    java.lang.Object CYCLE -> e
    gnu.bytecode.Method vectorAppendMethod -> f
    gnu.bytecode.ClassType quoteType -> g
    gnu.bytecode.Method consXMethod -> h
    gnu.bytecode.Method appendMethod -> i
    gnu.bytecode.Method makePairMethod -> j
    gnu.bytecode.Method makeVectorMethod -> k
    java.lang.Object expand(java.lang.Object,int,kawa.lang.Translator) -> a
    java.lang.Object quote(java.lang.Object,kawa.lang.Translator) -> b
    gnu.expr.Expression coerceExpression(java.lang.Object,kawa.lang.Translator) -> c
    gnu.expr.Expression leaf$1006e394(java.lang.Object) -> a
    java.lang.Object expand(java.lang.Object,int,kawa.lang.SyntaxForm,java.lang.Object,kawa.lang.Translator) -> a
    gnu.expr.ApplyExp makeInvokeMakeVector(gnu.expr.Expression[]) -> a
    gnu.expr.Expression rewrite(java.lang.Object,kawa.lang.Translator) -> a
kawa.lang.Syntax -> b.a.f:
    java.lang.Object name -> b
    java.lang.String getName() -> a
    java.lang.Object getSymbol() -> c
    void setName(java.lang.String) -> a
    gnu.expr.Expression rewrite(java.lang.Object,kawa.lang.Translator) -> a
    gnu.expr.Expression rewriteForm(gnu.lists.Pair,kawa.lang.Translator) -> a
    void scanForm(gnu.lists.Pair,gnu.expr.ScopeExp,kawa.lang.Translator) -> a
    boolean scanForDefinitions(gnu.lists.Pair,java.util.Vector,gnu.expr.ScopeExp,kawa.lang.Translator) -> a
    void print(gnu.lists.Consumer) -> a_
kawa.lang.SyntaxForm -> b.a.g:
    java.lang.Object getDatum() -> a
    kawa.lang.TemplateScope getScope() -> d
kawa.lang.SyntaxForms -> b.a.h:
    java.lang.Object makeForm(java.lang.Object,kawa.lang.TemplateScope) -> a
    java.lang.Object fromDatumIfNeeded(java.lang.Object,kawa.lang.SyntaxForm) -> a
    java.lang.String toString(kawa.lang.SyntaxForm,java.lang.String) -> a
kawa.lang.SyntaxForms$PairSyntaxForm -> b.a.i:
    gnu.lists.Pair datum -> e
    kawa.lang.TemplateScope scope -> f
    java.lang.Object getDatum() -> a
    kawa.lang.TemplateScope getScope() -> d
    java.lang.Object getCar() -> b
    java.lang.Object getCdr() -> c
    java.lang.String toString() -> toString
kawa.lang.SyntaxForms$SimpleSyntaxForm -> b.a.j:
    java.lang.Object datum -> a
    kawa.lang.TemplateScope scope -> b
    int counter -> c
    int id -> d
    java.lang.Object getDatum() -> a
    kawa.lang.TemplateScope getScope() -> d
    java.lang.String toString() -> toString
kawa.lang.TemplateScope -> b.a.k:
    java.lang.String toString() -> toString
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
kawa.lang.Translator -> b.a.l:
    gnu.mapping.Environment env -> ao
    kawa.lang.Macro currentMacroDefinition -> ah
    java.util.Stack renamedAliasStack -> ap
    java.util.Stack formStack -> ai
    int firstForm -> aj
    java.lang.Object pendingForm -> ak
    gnu.expr.LambdaExp curMethodLambda -> al
    gnu.xml.NamespaceBinding xmlElementNamespaces -> am
    gnu.expr.Declaration getNamedPartDecl -> aq
    gnu.expr.Expression errorExp -> ar
    kawa.lang.Syntax currentSyntax -> an
    gnu.expr.Declaration macroContext -> as
    gnu.lists.PairWithPosition positionPair -> at
    gnu.mapping.Environment getGlobalEnvironment() -> v
    gnu.expr.Expression rewrite_car(gnu.lists.Pair,kawa.lang.SyntaxForm) -> a
    gnu.expr.Expression rewrite_car(gnu.lists.Pair,boolean) -> a
    gnu.expr.Expression apply_rewrite(kawa.lang.Syntax,gnu.lists.Pair) -> a
    gnu.expr.ReferenceExp getOriginalRef(gnu.expr.Declaration) -> b
    boolean selfEvaluatingSymbol(java.lang.Object) -> c
    boolean matches(java.lang.Object,java.lang.String) -> a
    boolean matches(java.lang.Object,kawa.lang.SyntaxForm,java.lang.String) -> a
    boolean matches(java.lang.Object,kawa.lang.SyntaxForm,gnu.mapping.Symbol) -> a
    java.lang.Object matchQuoted(gnu.lists.Pair) -> a
    kawa.lang.Syntax check_if_Syntax(gnu.expr.Declaration) -> d
    gnu.expr.Expression rewrite_pair(gnu.lists.Pair,boolean) -> b
    gnu.mapping.Namespace namespaceResolvePrefix(gnu.expr.Expression) -> d
    gnu.mapping.Symbol namespaceResolve(gnu.mapping.Namespace,gnu.expr.Expression) -> a
    gnu.mapping.Symbol namespaceResolve(gnu.expr.Expression,gnu.expr.Expression) -> b
    java.lang.Object stripSyntax(java.lang.Object) -> d
    int listLength(java.lang.Object) -> e
    void rewriteInBody(java.lang.Object) -> k
    gnu.expr.Expression rewrite(java.lang.Object) -> f
    java.lang.Object namespaceResolve(java.lang.Object) -> g
    gnu.expr.Expression rewrite(java.lang.Object,boolean) -> b
    void setLine(gnu.expr.Expression,java.lang.Object) -> a
    void setLine(gnu.expr.Declaration,java.lang.Object) -> a
    java.lang.Object pushPositionOf(java.lang.Object) -> h
    void popPositionOf(java.lang.Object) -> i
    void setLineOf(gnu.expr.Expression) -> e
    gnu.bytecode.Type exp2Type(gnu.lists.Pair) -> b
    gnu.expr.Expression rewrite_with_position(java.lang.Object,boolean,gnu.lists.PairWithPosition) -> a
    java.lang.Object wrapSyntax(java.lang.Object,kawa.lang.SyntaxForm) -> a
    java.lang.Object popForms(int) -> d
    void scanForm(java.lang.Object,gnu.expr.ScopeExp) -> a
    gnu.lists.LList scanBody(java.lang.Object,gnu.expr.ScopeExp,boolean) -> a
    gnu.lists.Pair makePair(gnu.lists.Pair,java.lang.Object,java.lang.Object) -> a
    gnu.expr.Expression rewrite_body(java.lang.Object) -> j
    gnu.expr.Expression makeBody(int,gnu.expr.ScopeExp) -> a
    void finishModule(gnu.expr.ModuleExp) -> a
    void vectorReverse(java.util.Vector,int,int) -> a
    void resolveModule(gnu.expr.ModuleExp) -> b
    gnu.expr.Declaration makeRenamedAlias(gnu.expr.Declaration,gnu.expr.ScopeExp) -> a
    void pushRenamedAlias(gnu.expr.Declaration) -> c
    void popRenamedAlias(int) -> c
kawa.repl -> b.b:
    gnu.expr.Language language -> a
    java.lang.Object apply0() -> j
    java.lang.Object apply1(java.lang.Object) -> a
kawa.standard.Scheme -> b.b.a:
    gnu.mapping.Environment nullEnvironment -> h
    gnu.mapping.Environment r4Environment -> i
    gnu.mapping.Environment r5Environment -> j
    gnu.mapping.SimpleEnvironment kawaEnvironment -> k
    gnu.kawa.lispexpr.LangPrimType booleanType -> l
    kawa.standard.Scheme instance -> f
    gnu.kawa.reflect.InstanceOf instanceOf -> g
    gnu.kawa.functions.IsEq isEq -> m
    gnu.kawa.functions.ApplyToArgs applyToArgs -> n
    gnu.expr.Declaration applyFieldDecl -> o
    gnu.lists.AbstractFormat writeFormat -> p
    gnu.lists.AbstractFormat displayFormat -> q
    java.util.HashMap types -> r
    java.util.HashMap typeToStringMap -> s
    gnu.mapping.Namespace unitNamespace -> t
    java.lang.String getName() -> e
    gnu.lists.AbstractFormat getFormat(boolean) -> b
    int getNamespaceOf$746c69b6() -> f
    java.util.HashMap getTypeMap() -> i
    gnu.bytecode.Type getNamedType(java.lang.String) -> e
    gnu.bytecode.Type getTypeFor(java.lang.Class) -> a
    java.lang.String formatType(gnu.bytecode.Type) -> b
    gnu.bytecode.Type string2Type(java.lang.String) -> f
    gnu.bytecode.Type getTypeFor(java.lang.String) -> c
    gnu.bytecode.Type exp2Type(gnu.expr.Expression) -> b
    gnu.expr.Expression checkDefaultBinding(gnu.mapping.Symbol,kawa.lang.Translator) -> a
    gnu.expr.Expression makeApply(gnu.expr.Expression,gnu.expr.Expression[]) -> a
    gnu.kawa.lispexpr.ReadTable createReadTable() -> h
kawa.standard.SchemeCompilation -> b.b.b:
    kawa.lang.Lambda lambda -> a
kawa.standard.begin -> b.b.c:
    kawa.standard.begin begin -> a
    gnu.expr.Expression rewrite(java.lang.Object,kawa.lang.Translator) -> a
    void scanForm(gnu.lists.Pair,gnu.expr.ScopeExp,kawa.lang.Translator) -> a
kawa.standard.expt -> b.b.d:
    kawa.standard.expt expt -> a
    java.lang.Object apply2(java.lang.Object,java.lang.Object) -> c
kawa.standard.object -> b.b.e:
    kawa.standard.object objectSyntax -> e
    kawa.lang.Lambda lambda -> f
    gnu.expr.Keyword accessKeyword -> a
    gnu.expr.Keyword classNameKeyword -> g
    gnu.expr.Keyword interfaceKeyword -> h
    gnu.expr.Keyword throwsKeyword -> c
    gnu.expr.Keyword typeKeyword -> i
    gnu.expr.Keyword allocationKeyword -> d
    gnu.expr.Keyword initKeyword -> j
    gnu.expr.Keyword initformKeyword -> k
    gnu.expr.Keyword init_formKeyword -> l
    gnu.expr.Keyword init_valueKeyword -> m
    gnu.expr.Keyword init_keywordKeyword -> n
    gnu.mapping.Symbol coloncolon -> o
    gnu.expr.Expression rewriteForm(gnu.lists.Pair,kawa.lang.Translator) -> a
    void rewriteClassDef(java.lang.Object[],kawa.lang.Translator) -> a
    void rewriteInit(java.lang.Object,gnu.expr.ClassExp,gnu.lists.Pair,kawa.lang.Translator,kawa.lang.SyntaxForm) -> a
    boolean matches(java.lang.Object,java.lang.String,kawa.lang.Translator) -> a
    long addAccessFlags(java.lang.Object,long,long,java.lang.String,kawa.lang.Translator) -> a
    long matchAccess2(gnu.lists.Pair,kawa.lang.Translator) -> b
    long matchAccess1$26bdc9a8(java.lang.Object) -> a
kawa.standard.require -> b.b.f:
    kawa.standard.require require -> a
    java.util.Hashtable featureMap -> c
    void map(java.lang.String,java.lang.String) -> a
    boolean scanForDefinitions(gnu.lists.Pair,java.util.Vector,gnu.expr.ScopeExp,kawa.lang.Translator) -> a
    gnu.expr.ModuleInfo lookupModuleFromSourcePath(java.lang.String,gnu.expr.ScopeExp) -> a
    boolean importDefinitions(java.lang.String,gnu.expr.ModuleInfo,gnu.mapping.Procedure,java.util.Vector,gnu.expr.ScopeExp,gnu.expr.Compilation) -> a
    gnu.expr.Expression rewriteForm(gnu.lists.Pair,kawa.lang.Translator) -> a
org.json.JSONArray -> c.a.a:
    java.util.ArrayList myArrayList -> a
    int length() -> a
    java.lang.Object opt(int) -> a
    java.lang.String toString() -> toString
    java.lang.String toString(int) -> b
    java.io.Writer write(java.io.Writer,int,int) -> a
org.json.JSONException -> c.a.b:
    java.lang.Throwable cause -> a
    java.lang.Throwable getCause() -> getCause
org.json.JSONObject -> c.a.c:
    java.util.Map map -> b
    java.lang.Object NULL -> a
    java.lang.Object get(java.lang.String) -> a
    java.util.Iterator keys() -> a
    java.lang.String numberToString(java.lang.Number) -> a
    java.lang.Object opt(java.lang.String) -> d
    org.json.JSONObject put(java.lang.String,java.lang.Object) -> a
    java.lang.String quote(java.lang.String) -> b
    java.io.Writer quote(java.lang.String,java.io.Writer) -> a
    java.lang.Object stringToValue(java.lang.String) -> c
    void testValidity(java.lang.Object) -> b
    java.lang.String toString() -> toString
    java.lang.String toString(int) -> a
    java.lang.Object wrap(java.lang.Object) -> a
    java.io.Writer writeValue(java.io.Writer,java.lang.Object,int,int) -> a
    void indent(java.io.Writer,int) -> a
    java.io.Writer write(java.io.Writer,int,int) -> a
org.json.JSONObject$Null -> c.a.d:
    java.lang.Object clone() -> clone
    boolean equals(java.lang.Object) -> equals
    java.lang.String toString() -> toString
org.json.JSONString -> c.a.e:
    java.lang.String toJSONString() -> a
org.json.JSONTokener -> c.a.f:
    long character -> a
    boolean eof -> b
    long index -> c
    long line -> d
    char previous -> e
    java.io.Reader reader -> f
    boolean usePrevious -> g
    void back() -> a
    char next() -> d
    java.lang.String next(int) -> a
    char nextClean() -> b
    java.lang.Object nextValue() -> c
    org.json.JSONException syntaxError(java.lang.String) -> a
    java.lang.String toString() -> toString
